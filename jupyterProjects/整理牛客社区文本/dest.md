## 1.3 Spring入门

这次课我们来学习Spring，Spring之前我们也提到过，它不是一个框架，是一套框架。我们项目中基本上所有的需求 Spring都能帮我们解决，它能够给我们提供了非常全面的解决方案。么Spring这套框架把他们加在一起，我们通常称其为Spring全家桶。Spring全家桶它大体上分为4个方面，第一个方面就是space，框架它是基石，它是核心。

第二个是Spring，Boot我们可以利用它的构建项目，在这个项目的基础上去做Spring开发，会更容易更方便，上次课我们也做了演示。

第三个是Spring，cloud就是做微服务的，如果说我们有一个很大的项目维护起来比较困难，我们可以利用 Screen cloud把它拆分成若干个子项目，把他们再集中在一起，每一个子项目它的规模比较小，就便于维护了，但同时开发的难度会有所提高，是这样的。

第四个是Spring cloud data flow，就是Spring做数据集成的这么一个功能，比如说你的应用有很多客户端，包括移动设备传感器，还有可穿戴设备，甚至是汽车等等，有很多客户端，这些客户端所采集到的数据形态各异，怎么把它们集成在一起，整合在一起，形成更有价值的数据是他所做的事情。

当然这4部分功能我们不会都用上，因为我们这个项目本身它就是牛客网的一个模块，他还没有必要去往下拆分，所以微服务就不用去做了。

我们这个项目只有浏览器一种客户端，也没有多客户端，所以 data flow也用不上，我们会用前两种。

 Spring全家桶它所有的内容文档手册，都在它的官网上， Spring点l上能够查阅到，咱们可以看一下。这个就是它的官网，你往下看，它这里有一些大概的介绍，你的应用如果只是做基本的外部相关的开发，你用死不让步的是可以搞定的。

 Spring是build安全性能构建一切，如果你想做微服务，Spring cloud可以帮你搞定，它是call it安全性，就是说它能够协调一切，如果你想有更多的客户端数据集成可以用 data flow，它能连接一切，这就是它的整个产品的一个生态的结构。

总之无论是什么样的应用都能用它来解决。当然这些内容它都是基于思维框架的，它是基础是核心。

这一页是对整个 Spring产品的一个概要的介绍，更详细的内容你可以在这里找到projects，包括Spring得什么work得服了，我可闹的等等，其他的模块其实也是死不用的子模块，因为它相对独立，也比较用的比较多，因此它也单独的拿出来，让你能够直接方便查到我们的课程里后面会用到斯通贝特访问数据库，用到 Spring的secret做安全的控制，权限管理，还有 amqp用来做这个消息队列，主要是用到这些内容。

好了，我们再回到 PPT，我们这次课重点是讲 Spring， Spring它有很多功能，我们课程中也不会都用到，我们用到的是4大部分，第一部分是Spring的核心，它包括IOC和aopaop两部分， IOC和aop它都是用来管理对象的一种思想，由死不硬所管理的对象，我们通常叫做BIM，它是用来管理病人的思想。

 Ioc也是基于面向对象的一种管理对象的思想，而aop是一种面向切面编程的思想，它是对面向对象思想的一种补充，总之是不愿有了这两种思想能够管理一切病。

所以说哪怕是你有一个别的框架，第三方的框架，拿过来他也能够进行管理进行整合。所以Spring它牛不是牛来说它的功能多，而是它牛在它有这两种管理病人的思想能够管理一切。

那今天我们重点学的是 IOC后面的课程里我们会学LP第二个是Spring data access，就是Spring的访问数据库的功能，我们会用到用它来管理事物，我们会用它来整合my best。

第三个是外部开发，我们会用到它的 Spring MVC这一块。最后一部分是集成，我们会用 Spring去发邮件去做定时任务，去做消息队列，发送消息，去做安全控制，这是我们课程中要用到的内容。

Spring还有更多的内容，你可以从官方的手册里面能够查阅到，咱们简单看一下。就 Spring进来以后这是一个概要的介绍，详细的是在论之内。

标有Ga的是它的正式发布的版本，最高的版本是5.1.7，你可以点这个reference，这里面它是归类，核心有测试，有访问数据库等等。我们课程中所体现的内容其实就是这些内容中的一部分，你想看哪一块点进去看就是了。

好，因为这个内容比较长，所以说我们课堂上不去给大家看了，这个是你们课后自己可以去查阅的，作为一个课堂内容的补充。

好，我再回到 PPT，关于Spring我们首先要学的是IOC其实Spring所有其他的这些个功能都是构建着LC之上的，或者说他们都是以LC为基础的，所以必须先学好LC，其他的功能才容易学会。关于IOC首先你要理解什么是IOCIOC它是一组单词的缩写，叫做 it wasn't of control。

翻译过来就是控制反转的意思，这是一种面向对象编程的设计思想。

初步解释一下，比如说我们不用 Lc，我们自己管理对象通常是这样的，我new一个对象a再new一个对象b a点site传入b这样的话 a和b就有了联系，我可以通过a去调用b对吧？这是我们经常会做这样的事情，这样做的话是比较直观的，也比较直接，但是它有一个缺点就是a和b产生了耦合，直接就耦合在一起了。

当我们的项目规模变得比较大的时候，可能就会不好去维护，可能你改了a b改b也要顺带改a这是他的问题。

LC思想就是说他不用这种方式去建立病人之间的关系，他用另外的办法去建立病人之间的关系，从而减少病人之间的耦合度，让这个项目能够便于维护，是这样的。他是怎么去实现这个思想的，主要靠的是依赖注入的一种方式，这是它的实现方式，而依赖注入的实现方式。它又基于IOC Ioc容器，它是实现依赖度的关键，其实它本质上就是一个工厂，一会我们看代码能够深有体会。

右侧这个图是我从官网手册上截取了一个图，他演示的是 LC大概的一个原理，其中 Spring container就是LC容器，容器帮我们管理BIM的前提，于是你要给他提供两份数据，两种数据，一种是你要管理哪些病，这个病的类型你要给他第二个你要给他配置文件，给他配置，通过配置描述这些病人之间的关系，它就能够自动的实例化这个病，让你去调用，所以说在容指标容器管理病人的前提下，这个病与病之间不会直接产生关联，他们的关联关系是体现在配置当中的，病人的耦合度就降低了。

好，这个思想还是有点抽象，没关系，下面我们写一些代码，通过代码去体会一下它到底是怎么回事。

好，下面我就打开这个IDEA，在写代码之前我先解释一下我们上次课所写的代码当中的核心的类，community application，就解释一下这个类它运行的时候它都做了哪些事情，你了解了大概的过程以后，对理解 LC也是有帮助的。

类其实代码挺简单的，类方法就一句话，Spring application点乱，就是Spring应用运行了启动了。

当然我们知道它的底层启动的Tomcat对不对？因为我们访问过，其实它的底层不只是启动了Tomcat，除了启动他们开的之外，他还做了另外一件事儿，他自动的帮我们创建了这个Spring容器，就是说在外部项目当中是不用容器，不需要我们主动去创建，它是被自动的创建的，在这个方法底层做了这样的事情。

 Space容器被创建以后，它会自动的去扫描某些包下的某些并将这些并装配到容器里，哪些病会被扫描到，我们得看这个类，它是乱方法的参数。

 Spring应用在启动的时候，它是需要配置的，这个类其实就是一个配置文件，因为你看这个类上不有注解所标识的类，就表示说它是一个配置文件，我们可以点controller进到类的底层去详细看一下，这个注解是由其他注解所组成的，你看注解，Spring Boot condition表示类似一个配置文件，再看注解你内部outcome，微信比方说要启动启用自动配置，所以为什么我们几乎不用做配置，也能把服务启动起来呢？

因为它启用了自动配置，给我们配了很多东西，这个是组件扫描，那意思是它会自动的扫描某些报社的某些病，装配到容器里，所以说为什么它会自动装配？并因为你启动了组件扫描它会扫描哪些？B不是全部的，是这样，它会扫描配置类所在的包以及子包下的币，你想我们的程序当中像controller以后还会建别的包，所有的类都在这个包下，都是它的子包对吧？所以说所有的病都有机会被扫描到，这是第一。第二个还有一点，这个病上需要有像controller这样的注解才能够被扫描，如果没有这样的注解就不会被扫描。

和这个controller就是等价的功能一样的，还有几个注解，还有搜一下看还有 service在这，service就是说如果你加service注解也是能够让这个病人被扫描，你看这个service其实它是由 control的来实现的，所以说如果在bean加上complement也可以实现被扫描，还有一个叫 repository，它也是有可能的实现的，所以说你加它也可以被扫描，其实这个control也是有control的实现的也可以被扫描，就是说我们平时一共有4个注解，可以用你把任何一个注解加到一个类上，这个类就能够被容器所扫描了。他们的实现机制其实都一样，他们都是有恐怖的来实现的，所以说他们的功能都一样，那区别是在于语义上的区别，就是说如果说你开发的是一个业务组件，你最好用 service注解来标明，如果你开发的是一个处理请求的组件，你用controller来标识，如果你开发的是一个数据库，访问的组件，你用这个注解，如果你开发的它在任何地方都能用访问数据库处理请求或者是处理业务都能用，你可以用 computer通用的好了，总之这4个注解加到并上，使得这个并都能被自动扫描到，我们用哪1个都行，但是最好是按照刚才所说的建议去做，你一开始可能记不住，没关系，后面的话我们的课程里会经常的用熟了就好了。

好，关于 community application这个类，他大致做了哪些事情以及注解，他主要做了哪些事情，我们做了一个解释，让你知道了这个容器是什么时候被创建的容器中的，并是怎么来的，了解到这一点。LC的话，其他的内容就容易理解了。好了，介绍完以后，接下来我们就来写一些代码，来演示一下 LC的使用方式，这个代码我在这个测试类里进行演示，在测试类的演示。

我们正式运行程序是运行这个类，刚才也说了，它也是个配置类，一运行就以它为配置类来执行程序，我们测试的代码当中肯定也希望也用配置类，也希望和正式环境用的配置类是一样的，对不对？

怎么在测试代码中启用类作为配置类呢？其实也很容易就加一个注解叫context，computer reason，括号里面加上classes等于类型community application，点class，我们一会运行的测试代码就是以它为配置类的。

我们IOC刚才说了，它的这个核心是Spring容器，而容器又是被自动创建的，我们怎么去得到这个容器其实也很方便，哪个类想得到Spring容器，你就实现这样一个接口，叫application，context aware，容易有一个方法需要你实现。

这个测试代码我先不要了，一会用的时候再加上，这是一个赛的方法，传入参数，叫application context这个参数其实就是space，容器它是一个接口，看一下这个接口它继承于接口，这个接口要继承于它并factory，并fact就是并工厂，它其实 space容器的顶层接口， application context是它的子接口，它比父接口扩展出了更多的方法，它的功能更强一点。

所以通常我们会用子接口、application、contacts。

好再回到测试类当中，如果说我一个类实现了接口的方法，使用容器会检测到，使用容器在扫描组件的时候会检测到这样的，并调用它的赛的方法把自身传进来，把容器传进来。

所以我们只需要把这个容器暂存一下，记录下来引用一下，我们后面的话就能够使用它了，所以我在这个类当中加一个成员变量，用来记录什么？容器空态。

好，加个成分变量，这里边把它记录一下。好了，当这个当程序运行的时候， Application就自动的被传进来，我就自动的做了记录，我在其他的地方就可以去使用了。

下面我就写一个测试方法，在这个测试方法里面去使用一下，十分容器这个方法名我叫做test application contact测试，Spring容器在这儿怎么测，我就这样，我就直接把这个对象打印出来看，看它有没有值，看它是一个什么样的对象。

好，我就运行一下测试方法。

好，我们看通用台，你看它打印出来信息，打印出来的是类名希克的，这是对象的输出的形式。这个类型是generic web application context，这是实现类的一个类名，我们 application contact是接口好了，那就证明了这个容器是存在的，是可见的。

下面我们演示一下这个容器我们怎么去用它来管理BIM，当然你要用它管理bean，首先你得有bean让它去管理对不对？

下面我们就写一个bean，这样我再建一个包，比如说我要访问数据库，我要去查询某些数据，我再建一个包，这个包下专门存放访问数据库的那些个病，好这个包我叫做dao就是data access ok数据库访问的对象，我的包下创建一个访问数据库的接口，这选成接口，这个接口名字我们现在不是真正去访问数据库，就是一个演示，所以我就取得稍微随意一点这个名字叫阿尔法do。

这个接口我需要定义一些方法，因为是演示我也简单一点，定义一个非常简单的方法，谁来比如说我要查询没有参数，返回一个字符串就可以了。当然了这个接口还不能直接用，你还得有实现对吧？我再给它加一个实现类，我再创建一个该接口的实现类，这个类我叫阿尔法 dao，haven't apple假如说这个时间内我是采用haven't的技术来实现的查询，所以我叫哈尔滨的叫IMP l实现的意思， Ok。

当然它需要实现刚才的接口，阿尔法道增加接口的未实现的方法，这个方法我也简单一点，就直接返回一个字符串， habit完了就这样，当然这样还有所欠缺，你这样的话，这个病是不能够被容器所管理的，或者说容器是不能够扫描并装配它的，容器扫描并对什么样的病包下他满足了对吧？

其次它的上面有一个注解，所以说我给他加一个注解，访问数据库的b应该加什么？ Reporter。好，这样就可以了，只要我们运行程序，Spring容器会自动的扫描到这个病，把它装配到容器里，我们可以看一下，再回到 test方法。

好，我还是在刚才的测试方法里进行一个演示，这回我要从这个容器里获取它自动装配的病，好，它的类型我可以把它向上造型为接口，阿尔法道等于application，content，容器你获取病就调它的获取病的方法，get你可以通过名字获取，可以通过类型获取，我们通常可以按照类型获取，这个并的类型就这个类型，当然你写成接口类型也可以，阿尔法到there class，我要从容器中获取类型的病，得到了得到以后，我调用一下阿尔法到点select，我调用它的查询方法，并且将结果输出出来。

好了，下面我们运行一下这个方法，再看你看最终的输出结果还有问题，成功了对吧？我们成功的获取到了这个病，得到了查询的结果，没有问题。有的同学可能会有所怀疑，我倒是看明白了，但是这样有点麻烦，还不如我们自己实例化，这有什么好处，我们得了解它背后有什么好处。下面我再写一个病再写一个病，通过这个病你去体会它的优势。

比如说有一天我们这个项目发展到一定阶段，有一个新的技术诞生了，比如说买卖类似，假设它比heaven更为更有优势，我们在项目中想把 happiness替换为my best，在这样的项目中我可以这样做，我可以再新建一个到的实现类，而不用把它删掉，我叫阿尔法到I bet is apple也是实现类，好，也是要实现接口增加待实现的方法。

这个方法我要返回的是my best，说白了实现方式和刚才同时它也得加上注解，也可以被扫描到被抛弃的人。但是你注意这样还不行，这样还不够，你这样去运行刚才的程序就会有问题了，有什么问题呢？就是说我要按照类型去获取，并这个类型是个接口，这个接口满足条件的并有两个，一个是一个是它对吧？

这俩都满足接口，所以说死病容器就不知道该给你哪一个病了，有歧义了，这个时候就会报错，这种情况怎么解决也好办，我只需要呢在我希望的病上再加一个主角 prime，加上以后这个病会被优先的装配，或者会当你调用的时候，它会优先给你，它有更高的优先级，好，加上以后咱们再试。

我再回到刚才的测试方法，再次运行一下，好，你看这回它打印的结果就是买卖点，所以你想一下，这就是它的优势，就是我的程序当中，原先所有的到的时间内都是由happen的实现的。

我调用这个并的地方会很多的，会很多的。当有一天我想把这个病替换掉的时候，其实很简单，我只需要再加一个病，多加一个promise，prime注解就行了。

我们调用的地方完全不用变，因为我们调用的这个地方依赖的不是这个病本身，依赖的是它的接口，这也是利用了面向接口变成的思想，我依赖的是接口，它实现类变了，我这是不用动的，这非常的容易好。

所以说space容器就通过这种办法降低了并执行的额度，我们调用方和时限内不会发生任何的直接的关系，是这样的。

但是这样可能会带来一个就是新的问题，比如说我程序的某一块儿，我还想用这个habit，我不想用 my best，就比较特别，我就这一块儿要用 habit，但是你这样获取的话，永远都获取的是my best的实现，我怎么能得到哈尔滨的实现的病也好办，其实病每一个病它都是有这个名字的，being的默认的名字是类名，首字母小写，如果你觉得这个类名比较长，你也可以拿去自定义一下他的名字，我们怎么定义一个病的名字，还是用注解加个括号，括号里面写上字符串就是并的名字，比如说这里我写上阿尔法，还有问题，这个病的名字阿尔法还有问题。

好了，给这个病重新自定义完名字以后，我可以通过名字强制容器返回这个并给我，我们来演示一下看看。

在这个位置我再重新的获取一次病，阿尔法到等于 application context点get，并这回你要通过名字获取就不是类型了，那名字是阿尔法到阿尔法还不能听，他得到的类型是默认是object，因为他不知道是什么类型的，因为你这样get并没有给它类型，它返回的是一个object，你需要强制转型，或者是你可以再加一个参数。阿尔法到克拉斯意思是说你得到的 Offer价格你帮我转型成它也可以，我就再访问一下到时代，写完以后我再次执行这个方法好。你看第一次输出的是my business，因为它优先级高，第二次我是指定了病人的名字，就得到了哈尔滨的病，没有问题。

好了，以上就是我们从这个容器中获取病人的基本的方式，这个容器管理病不只是局限在能帮我们创建病，它还有更多的管理并的手段，下面我再给大家演示 Spring容器管理病的更多的方式方法，使用容器它除了创新病之外，它还能够帮我们管理病的初始化以及销毁的方法，接下来我再写一个病给你演示一下，这样我这回就不用这个道了，我怕把道的代码改给它改乱了，我们再新建一个病，假如说我要开发一些业务组件，处理一些业务，我们通常会把业务组件单独放一个包下，这个包叫做service会有很多这样的组件，现在我在我就新建一个例子，比如说我取名叫阿尔法service，这个名字也是比较随意的，我也希望这个病是由通过容器进行管理，所以我需要在类上增加一个注解，它是一个业务组件加的注解，应该就是service。

好了，刚才我说了，说这个病我希望由容器来管理，不只是创建，它还希望容器管理它的初始化和销毁的方法，怎么管理？我首先给并增加初始化方法in it。这里我随便的打印一句话，叫做初始化阿尔法service。

要想让容器帮你管理这个方法，其实就像容器在合适的时候自动的调这个方法，你只需要在这个方法之前加上一个注解叫post construct，注解的意思是这个方法会在构造器之后调用，初始化方法通常是在构造之后调用用来初始化某些数据，为了便于观察这个方法，它调用的时刻到底是不是在构造器之后，我给这个类加一个构造器，好，咱们好对比一下。

构造器里我也是打印一句话，就是实例化阿尔法service除了管理初始化方法，还能够管理销毁方法，我再给这个类加一个销毁方法，叫destroy。

好，这里也打印一句话说销毁阿尔法service，这个方法上也需要加一个注解，这个容器会自动的调用它，注解是I destroy就是说在销毁对象之前去调动它，为什么销毁之前，因为如果是在对象效果以后你就没法调了，对吧？

一定是在销毁之前调一下，你可以在这里释放某些资源，写完以后咱们测试一下，看一看我们通过容器能不能自动的去调初始化以及销毁的方法，我再回到测试类进行演示。我就再写一个新的测试方法，这个方法我叫test，并 many的就是测试一下病的管理的方式。

首先我要演示的是我要通过容器去获取 Service，看一下会出现什么样的情况，阿尔法service等于application。Contact点get我们就按照类型去获取，因为这个阿尔法service就是它是一个类，我没有写接口，这样方便一点。阿尔法service their class。好，获取到 b以后，我去把 b就直接打印出来，看一下这个对象是否存在。好，我就运行一下，看一看会是什么样的结果看控制台最终他确实打出了这个对象，说明确实能够实例化， b没有问题。

我们看一下这个点，这个是程序启动的过程，输出的内容，包括 space容器的一个创建的过程。

在这个过程当中你会看到有这样的输出，实例化，阿尔法service，初始化阿尔法service，最后销毁阿尔法service，也就是说并的初始化方法确实是在构造期之后被调用的，销毁方法确实是在程序结束之前，对象销毁之前调用的，在初始化和销毁之间，我们打印出来病人的实力没有问题，好了，因为我们看到了这样的现象，就是说在程序启动的时候， BIM被实例化，程序停止的时候，BIM被销毁，能说明一个什么问题呢？

就说明这个病其实它只被实例化一次，它只被销毁一次，它在容器中只有一个实例，它是单立的，为什么这么说？你想象一下我们的外部程序是不是只启动一次对吧？ Main方法只启动一次，所以说并被实例化一次，它就只有一个实例，不信的话我们可以再来一次，我再去获取一下这个病，再获取一下这个病，把它打印出来。

我们看一下它是实例化两次还是一次就能就知道了，这个结果我运行一下这个方法，首先你看打印结果，打印出来这两个对象好奇客户的是一样的，是一个对象。

在程序启动的过程中看日志，也只实例化了一次，就说明被容器使用容器管理的病，它默认是单个实例单立的。如果说你不希望它单立，你希望每次get并它都新建一个实例，也不是不可以也可以怎么办呢？我们就需要在并上再加一个注解，叫scope。它的作用范围是整个容器中有一个还是整个容器中有多个？死扣不它的默认参数就是辛苦的，心都疼，这是单例的，这你不用写，如果是想多个实例，你要写这样一个单词，PRO to tap。

当加上这个单词以后，我们每次访问遍，他就会给我们创造一个新的实例，咱们来试一下，再运行刚才的测试方法，好，你看这个控制台输出结果，这回就不是启动时初始化了，而是在具体我们盖的病的时候，每次盖的病他都实例化一个，每次盖的病都实例化一个，是这样，所以实例化两次就是两个病奇克的也不一样。

当然了，我们通常情况下都用它默认的方式，这个并都是用单例的形式，很少说有用多实例的形式比较少，基本上我们的项目中都是单立的，所以说我把注掉，以免让大家以为我们要经常这么做，以免对你造成误解。

好了，这是Spring它能帮我们管理这个病，其实是管理病的作用域，它的有效的范围这么一种情况。

以上我们用死病容器管理的都是我们自己写的病，都是我们自己写的类，有些时候我们可能希望这样做，我希望在容器中装配一个第三方的笔类是人家写的是在Jar 包里，这个时候我就不能像这样，我去类加上一个注解，因为那是人家写的类对吧？

你不能轻易改，再一个他打到Jar 包里去了，可能还没有源码，这种情况怎么做？其实也很方便，我们需要自己写一个配置类，在配置类当中通过并注解进行声明来解决这个问题，下面我就给大家写一个配置类，装配一个第三方的BIM。

好，我们项目当中会把以后会有更多的配置类，我们会把所有的配置类都放到同一个包下，新建一个包叫我在这建一个配置类的示例，也是没有什么业务含义，我还是叫阿尔法可能这一块。

好，当然了我们标识配置类也可以用类似于这样的注解，什么Spring application，但是其实没有必要，通常是程序的入口用注解，我们一个普通的配置类，一般我们用叫腾飞哥瑞森表示这个类是一个配置类，不是一个普通的类，你要定义第三方的BIM需要加一个并注解在方法之前，这里要定义一个方法，我要装成一个什么，并假如说我要把咱们 Java自带的 simple date format装配到容器当中，因为simple的，因为我们在一个项目当中可能是几乎所有的地方日期的格式都一样，我把 simple对对方卖的实例化一次，装配到b类，可以反复用，达到这样一个目的。

好，我要装配的是c不对的放卖的，所以这个方法的返回的类型就得是same不对的方面，给它取一个方法名，注意这个方法名就是bin的名字，BIM的名字是以方法命名的， BIM类当中这个方法当中，我就实例化 cmd的方面，给他指定一个格式，好这样就可以了。

这段话的意思就是说这个方法的返回的对象将被装配到容器里，这个病的名字，写完以后我们再回到这个测试类，我们去看一下能不能取到这个病，我就再写一个测试方法，这个方法名我取名叫taste，并挺big病的配置，我要从病中从容器中取的是cmd的方脉，先说明这个类型，我换个行按照类型来get，simple date for MAC点plus。

好，我就使用一下，我就用 cmpod的方脉去格式化一个当前的日期，看看能不能达到我的预期。好，我就执行一下这个方法。咱们看结果是当前的年月日时分秒。没错就是这样，好了，使用容器基本上就是这样去用的，但这种用法是我们主动的去获取容器，去从容器中的拿一个并过来去用，但其实这种方式很麻烦，这个Spring死不用的，还有更简便的使用一个容器的方式。

刚才我们PPT上不是说了，它的 Lc的实现方式是依赖注入，而我们现在主动获取感觉也不是主流，对吧？

所以说这种方式还是一个比较笨拙的方式，为什么要演示之前这种主动的获取的笨拙的方式，因为我是希望你能够理解死笨容器它到底是一个什么东西，它的底层到底有什么方法，我们到底是怎么去直接使用，这是它的底层的一些内容，你需要了解。

我们从使用角度来说怎么方便怎么用，下面我再给你演示一下，怎么用会更方便一些，什么叫依赖注入？

比如说我当前的病要使用阿尔法道，我没有必要去通过容器去get获取，我只需要声明，我要给当前的币注入阿尔法道就可以了。注入的话需要用一个注解叫 o to o to where加在一个程序变量之前就可以我加了一个阿尔法到程序变量之前，这句话的意思是说我希望十分容器能够把阿尔法道注入给属性，我就可以直接使用属性就可以了。好，咱们试一下，我再写一个测试方法，叫test。

 Di是什么意思呢？就是依赖注入，对攀登c infection的缩写，测试依赖注入。好，我在这个测试方法里面直接使用这个程序变量，看看能不能取到这个病，我就直接把它打印出来看一下运行。好，你看打印出来结果是这个 my best这个时间内没有问题对吧？同理，你想获取阿尔法service，也可以这样做，你想获取 simply的放卖也是可以的，好，我在这也把那两个病打印出来看，再执行这个方法看，结果这个是my business实现这个是阿尔法service，这个是safety的方面都取到了，比方说没有问题可以用，注意还有一种情况，比如说我二发到我希望注入的不是 my best，不是默认的优先级，我希望注入的还是happened，怎么办？

这种情况我们需要再加一个注解，叫考利菲尔，括号里边写上 Bing的名字，阿尔法 happily，此病容器就会把这个病你认为这个的病注入给他，我们再来测试一下，你看这个病就变成了heaven的实现。

所以你看说Spring他管理并就是用这样的方式，就是依赖注入的方式，我们只要声明一个属性，写一个注解，这个病就有了，我就可以直接拿来用了。像这种情况，我当前病依赖的是接口，底层的实现我是不直接跟它耦合的降低了耦合度，好，而且它也很方便对吧？不用你去实地化。

好了，依赖注入的基本的使用方式就是这样的，非常的方便非常的简单，我们通常都是这样用的，其实注入注解，也可以加在类的构造器的前面，通过构造器注入也可以或者是把注解加到赛的方法之前，通过赛的方法注入也行。

但通常我们都是把它加在属性之前，直接注入给属性，这样更简洁更方便，我们项目中基本上都是这样去做的，所以另外的两种方法我就不给大家演示了，如果你有兴趣的话，可以翻翻手册去自己查阅一下。

好了，以上是我们演示的一些语法小例子，我们在实际的项目的开发的过程中怎么去运用，下面我们在综合一下来演示一下依赖注入，演示一下我们项目中怎么去使用这种思想解决问题。

我们的开发的过程中是这样的，由controller来处理浏览器的请求，它在处理浏览器的请求的过程中，会调用业务组件去处理当前的业务，业务组件会调用deo去访问数据库，所以说是这样的，d controller调 Service调deo他们是彼此互相依赖的，他们的依赖关系就可以用这种依赖注入的方式去实现。

好，我们来演示一下，首先我打开阿尔法service，比如说我要调道，阿尔法道我就可以把阿尔法道注入给阿尔法service，当然你需要加 how to win，我希望注入默认的my best的实力就可以了，所以我就不加科雷菲尔了，加上一个注解，成分变量，好这就注入了。

我在处理查询的业务的时候就可以调用它了，下面我就写一个方法，模拟实现一个查询的业务，这个方法我返回死菌方法名叫犯的，这里我调的是阿尔法到来实现的查询，我直接把查询结果返回，这就是service依赖于到的方式。

 controller在处理请求的过程中可以叫service，同样的道理，我首先在 controller那里将service注入给他好，我这里写一个处理查询请求的方法，模拟处理一个查询请求，这个方法比如说我还是简单点返回字符串，因为是查询叫get查询某些数据，我就直接return阿尔法service点find，把 find的结果返回给浏览器。

当然浏览器要访问这个方法的前提是它得有注解声明声明它的路径就和一样，按照 copy路径我给它改名叫data写完以后，我们可以运行一下正式的代码，访问一下试试。

好，运行一下，运行完以后我打开浏览器访问一下，阿尔法 data，你看它的结果是什么？是买卖s怎么来的？是因为我掉了 service的饭的方法，而service的饭的方法调用的是 Dao的 select方法。

 deo我们注入的时候，注入的是默认的优先级的，也就是买卖点，实现了这个病好了，所以说你通过这个例子可能就更容易去理解我们之前所讲的 LC的概念。在这个思想的管理BIM的前提下，我们项目中的BIM不是我们自己去实例化，也不是我们自己去赛的，而是通过容器统一的管理，降低了病人之间的吻合度。好了，这次课我们关于LC的内容就演示到这里，咱们下次课再见。