# 1 JVM 运行时内存划分

## 第5页

方法区是一个规范，不同的厂商、不同的JDK版本实现不一样。在HotSpot虚拟机中，JDK 1.8之前使用永久代实现方法区，JDK1.8及以后，使用元数据空间实现方法区。

方法区主要存放类加载器从class字节码文件中加载的进来的类信息和常量池，类信息包括字段、方法父类等；常量池包括动态常量池和静态常量池，静态常量池是用来保存字面量、符号引用等信息，动态常量池用来保存类加载解析阶段时生成的直接引用等信息。

## 第6页

我们首先来看这段代码，这段代码存在于“.java”后缀的文件里，这个文件就是java源代码文件。但是这个文件是面向我们程序员的，计算机他是看不懂我们写的这段代码的。所以此时就得通过编译器，把“.java”后缀的源代码文件编译为“.class”后缀的字节码文件。这个“.class”后缀的字节码文件里，存放的就是对你写出来的代码编译好的字节码了。

字节码才是计算机可以理解的一种语言，而不是我们写出来的那一堆代码。“字节码指令” 对应了一条一条的机器指令，计算机只有读到这种机器码指令，才知道具体应该要干什么。所以现在大家首先明白一点：**我们写好的Java代码会被翻译成字节码，对应各种字节码指令** 

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。所以当JVM加载类信息到内存之后，实际就会使用自己的**字节码执行引擎**，去执行我们写的代码编译出来的代码指令。那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”



程序计数器用于记录字节码指令执行到哪个位置，JVM是支持多线程的，每一个线程都有自己的程序计数器，专门记录当前线程执行到哪一条字节码指令了，在线程上下文切换时用来保存当前线程的执行信息。

## 第7页

Java代码在执行的时候，一定是线程来执行某个方法中的代码。比如这里代码，虽然程序员没有创建线程，但JVM也会创建一个main线程来执行main()方法里的代码。在main线程执行main()方法的代码指令的时候，就会通过main线程对应的程序计数器记录自己执行的指令位置。

但是在方法里，我们经常会定义一些方法内的局部变量。比如这里的main()方法里，其实就有一个“replicaManager”局部变量，他是引用一个ReplicaManager实例对象的。

因此，JVM必须有一块区域是来保存每个方法内的**局部变量**等数据的，这个区域就是Java虚拟机栈。每个线程都有自己的Java虚拟机栈，比如这里的main线程就会有自己的一个Java虚拟机栈，用来存放自己执行的那些方法的局部变量。如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧。**栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西。**





比如main线程执行了main()方法，那么就会给这个main()方法创建一个栈帧，压入main线程的Java虚拟机栈。同时在main()方法的栈帧里，会存放对应的“replicaManager”局部变量。然后假设main线程继续执行ReplicaManager对象里的方法，比如下面这样，就在“loadReplicasFromDisk”方法里定义了一个局部变量：“hasFinishedLoad” 那么main线程在执行上面的“loadReplicasFromDisk”方法时，就会为“loadReplicasFromDisk”方法创建一个栈帧压入线程自己的Java虚拟机栈里面去。

然后在栈帧的局部变量表里就会有“hasFinishedLoad”这个局部变量。

接着如果“isLocalDataCorrupt”方法执行完毕了，就会把“isLocalDataCorrupt”方法对应的栈帧从Java虚拟机栈里给出栈

然后如果“loadReplicasFromDisk”方法也执行完毕了，就会把“loadReplicasFromDisk”方法也从Java虚拟机栈里出栈。





这段入栈出栈的内容就描述了就是JVM中的“Java虚拟机栈”这个组件的作用：调用执行任何方法时，都会给方法创建栈帧然后入栈在栈帧里存放了局部变量表、操作数栈、动态链接、方法出口等数据，方法执行完毕之后就出栈。



1、在执行Java代码的时候，一定是某个线程在执行。线程在执行方法中的代码时，需要保存方法内部定义的局部变量等数据，这个区域就是Java虚拟机栈。

2、每个线程都有自己的Java虚拟机栈，线程里面执行方法时会为该方法创建一个栈帧并入栈，栈帧里面有该方法的局部变量表、操作数栈、动态链接、方法出口等数据。当方法执行完毕，就会把对应的栈帧出栈。

## 第9页

现在大家都知道了，main线程执行main()方法的时候，会有自己的程序计数器。此外，还会依次把main()方法，loadReplicasFromDisk()方法，isLocalDataCorrupt()方法的栈帧压入Java虚拟机栈，存放每个方法的局部变量。

那么接着我们就得来看JVM中的另外一个非常关键的区域，就是Java堆内存，这里就是存放我们在代码中创建的各种对象的

比如这段代码“new ReplicaManager()”这个代码就是创建了一个ReplicaManager类的对象实例，这个对象实例里面会包含一些数据，这个“ReplicaManager”类里的“replicaCount”就是属于这个对象实例的一个数据。



类似ReplicaManager这样的对象实例，就会存放在Java堆内存里。，然后我们因为在main方法里创建了ReplicaManager对象的引用变量，那么在线程执行main方法代码的时候，就会在main方法对应的栈帧的局部变量表里，让一个引用类型的“replicaManager”局部变量来存放ReplicaManager对象的地址，相当于你可以认为局部变量表里的“replicaManager”指向了Java堆内存里的ReplicaManager对象。



堆是线程共享的区域，堆用于存放代码中创建的各种对象。堆被划分为“新生代”和“老年代”，新生代又被进一步划分为Eden区和Surrvior区，这是垃圾回收相关的知识。

## 第12页

首先，你的JVM进程会启动，就会先加载Kafka类到方法区里。

然后有一个main线程，开始执行Kafka中的main()方法。main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧。

接着会发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存里来。

然后会创建一个ReplicaManager的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个“replicaManager”变量，让他引用ReplicaManager对象在Java堆内存中的地址。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈。

其实大家理解了这个过程，那么JVM中的各个核心内存区域的功能和对应的我们的Java代码之间的关系，就彻底理解了

# 3 JVM线程模型

## 第17 页

内核线程（Kernel Thread, KLT）是直接由操作系统内核支持的线程，由操作系统内核来完成内核线程切换，内核通过操作调度器对内核线程进行调度。

## 第22页

**内核线程模型即完全依赖操作系统内核提供的内核线程（Kernel-Level Thread ，KLT）来实现多线程。**在此模型下，线程的切换调度由系统内核完成，系统内核负责将多个线程执行的任务映射到各个CPU中去执行。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。

## 第23页

使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。 因而使用用户线程实现的程序一般都比较复杂，此处所讲的“复杂”与“程序自己完成线程操作”，并不限制程序中必须编写了复杂的实现用户线程的代码，使用用户线程的程序，很多都依赖特定的线程库来完成基本的线程操作，这些复杂性都封装在线程库之中，除了以前在不支持多线程的操作系统中（如DOS）的多线程程序与少数有特殊需求的程序外，**现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它**。

## 第24页

将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。 用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。 在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系。

## 第29页

堆溢出也就是内存溢出 OOM，一般是由于创建的对象太多，导致超过了堆的最大容量。排查时可以通过性能检测工具如 jconsole，获取堆内存快照，然后观察溢出的对象是否是必要的，是的话就需要检查代码中对象的生命周期是否过长，或者优化算法，实在不行可以调整 JVM 的堆参数设置 -Xmx 和 -Xms，增加 JVM 最大内存和启动初始内存；如果溢出的对象不是必要的，就表明发生了内存泄漏，这时可以查看泄漏对象的 GC Roots 引用链，找到具体泄漏的位置。

如果是虚拟机栈溢出，很可能就是存在死循环，过多的递归调用导致把栈撑满了，此时可以直接看控制台的堆栈信息，比较容易定位。