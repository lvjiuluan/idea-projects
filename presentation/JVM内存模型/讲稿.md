# 1 JVM 运行时内存划分

## 第5页

方法区是一个规范，不同的厂商、不同的JDK版本实现不一样。在HotSpot虚拟机中，JDK 1.8之前使用永久代实现方法区，JDK1.8及以后，使用元数据空间实现方法区。

方法区主要存放类加载器从class字节码文件中加载的进来的类信息和常量池，类信息包括字段、方法父类等；常量池包括动态常量池和静态常量池，静态常量池是用来保存字面量、符号引用等信息，动态常量池用来保存类加载解析阶段时生成的直接引用等信息。

## 第6页

我们首先来看这段代码，这段代码存在于“.java”后缀的文件里，这个文件就是java源代码文件。但是这个文件是面向我们程序员的，计算机他是看不懂我们写的这段代码的。所以此时就得通过编译器，把“.java”后缀的源代码文件编译为“.class”后缀的字节码文件。这个“.class”后缀的字节码文件里，存放的就是对你写出来的代码编译好的字节码了。

字节码才是计算机可以理解的一种语言，而不是我们写出来的那一堆代码。“字节码指令” 对应了一条一条的机器指令，计算机只有读到这种机器码指令，才知道具体应该要干什么。所以现在大家首先明白一点：**我们写好的Java代码会被翻译成字节码，对应各种字节码指令** 

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。所以当JVM加载类信息到内存之后，实际就会使用自己的**字节码执行引擎**，去执行我们写的代码编译出来的代码指令。那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”



程序计数器用于记录字节码指令执行到哪个位置，JVM是支持多线程的，每一个线程都有自己的程序计数器，专门记录当前线程执行到哪一条字节码指令了，在线程上下文切换时用来保存当前线程的执行信息。

## 第7页

Java代码在执行的时候，一定是线程来执行某个方法中的代码。比如这里代码，虽然程序员没有创建线程，但JVM也会创建一个main线程来执行main()方法里的代码。在main线程执行main()方法的代码指令的时候，就会通过main线程对应的程序计数器记录自己执行的指令位置。

但是在方法里，我们经常会定义一些方法内的局部变量。比如这里的main()方法里，其实就有一个“replicaManager”局部变量，他是引用一个ReplicaManager实例对象的。

因此，JVM必须有一块区域是来保存每个方法内的**局部变量**等数据的，这个区域就是Java虚拟机栈。每个线程都有自己的Java虚拟机栈，比如这里的main线程就会有自己的一个Java虚拟机栈，用来存放自己执行的那些方法的局部变量。如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧。**栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西。**





比如main线程执行了main()方法，那么就会给这个main()方法创建一个栈帧，压入main线程的Java虚拟机栈。同时在main()方法的栈帧里，会存放对应的“replicaManager”局部变量。然后假设main线程继续执行ReplicaManager对象里的方法，比如下面这样，就在“loadReplicasFromDisk”方法里定义了一个局部变量：“hasFinishedLoad” 那么main线程在执行上面的“loadReplicasFromDisk”方法时，就会为“loadReplicasFromDisk”方法创建一个栈帧压入线程自己的Java虚拟机栈里面去。

然后在栈帧的局部变量表里就会有“hasFinishedLoad”这个局部变量。

接着如果“isLocalDataCorrupt”方法执行完毕了，就会把“isLocalDataCorrupt”方法对应的栈帧从Java虚拟机栈里给出栈

然后如果“loadReplicasFromDisk”方法也执行完毕了，就会把“loadReplicasFromDisk”方法也从Java虚拟机栈里出栈。





这段入栈出栈的内容就描述了就是JVM中的“Java虚拟机栈”这个组件的作用：调用执行任何方法时，都会给方法创建栈帧然后入栈在栈帧里存放了局部变量表、操作数栈、动态链接、方法出口等数据，方法执行完毕之后就出栈。



1、在执行Java代码的时候，一定是某个线程在执行。线程在执行方法中的代码时，需要保存方法内部定义的局部变量等数据，这个区域就是Java虚拟机栈。

2、每个线程都有自己的Java虚拟机栈，线程里面执行方法时会为该方法创建一个栈帧并入栈，栈帧里面有该方法的局部变量表、操作数栈、动态链接、方法出口等数据。当方法执行完毕，就会把对应的栈帧出栈。

## 第9页

现在大家都知道了，main线程执行main()方法的时候，会有自己的程序计数器。此外，还会依次把main()方法，loadReplicasFromDisk()方法，isLocalDataCorrupt()方法的栈帧压入Java虚拟机栈，存放每个方法的局部变量。

那么接着我们就得来看JVM中的另外一个非常关键的区域，就是Java堆内存，这里就是存放我们在代码中创建的各种对象的

比如这段代码“new ReplicaManager()”这个代码就是创建了一个ReplicaManager类的对象实例，这个对象实例里面会包含一些数据，这个“ReplicaManager”类里的“replicaCount”就是属于这个对象实例的一个数据。



类似ReplicaManager这样的对象实例，就会存放在Java堆内存里。，然后我们因为在main方法里创建了ReplicaManager对象的引用变量，那么在线程执行main方法代码的时候，就会在main方法对应的栈帧的局部变量表里，让一个引用类型的“replicaManager”局部变量来存放ReplicaManager对象的地址，相当于你可以认为局部变量表里的“replicaManager”指向了Java堆内存里的ReplicaManager对象。



堆是线程共享的区域，堆用于存放代码中创建的各种对象。堆被划分为“新生代”和“老年代”，新生代又被进一步划分为Eden区和Surrvior区，这是垃圾回收相关的知识。

## 第12页

首先，你的JVM进程会启动，就会先加载Kafka类到方法区里。

然后有一个main线程，开始执行Kafka中的main()方法。main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧。

接着会发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存里来。

然后会创建一个ReplicaManager的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个“replicaManager”变量，让他引用ReplicaManager对象在Java堆内存中的地址。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈。

其实大家理解了这个过程，那么JVM中的各个核心内存区域的功能和对应的我们的Java代码之间的关系，就彻底理解了