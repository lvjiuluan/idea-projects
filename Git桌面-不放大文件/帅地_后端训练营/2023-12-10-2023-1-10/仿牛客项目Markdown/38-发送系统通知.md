38-发送系统通知.mp4

这次课咱们来实现发布系统通知的功能。那么具体来说是当有一个用户他发表了评论以后，那么我们系统要通知被评论的那个人，同理点赞的时候，关注的时候，我们都要通知了被点赞被关注的那个人，所以你可想而知发布通知的操作它是非常的频繁，因为我们用户群有很多这个点赞评论关注的行为是很频繁的，对吧？

系统的发布通知是一个非常频繁的行为，所以重也要考虑性能的问题，那么为了保证性能提高性能，我们就需要用到我们刚刚所学的卡夫卡消息队列，为什么需要用到消息队列解决问题呢？

这里我们要阐述一下，因为如果我们采用消息对立的方式解决问题，很显然评论点赞关注就是三类，不同的事儿我们可以定义三类，不同的主题，评论一种主题，然后点赞一个主题，关注一个主题。

一旦这件事发生的时候，我们就可以把这件事包装成一条消息，然后扔到队列里，扔到它相应的队列里，扔到队列里以后，那么我当前这个线程其实就是生产者消息的生产者，他就可以继续处理下一条消息，继续做别的事情，他就不用再管后续的业务了，而后续的业务是由消费者线程去处理的。

也就是说生产者和消费者，其实他们在处理的业务的时候，其实它是并发的，它是可以同时进行的，这种方式我们称之为异步。

好，我们再总结一下，我们在评论点赞关注以后，我们不是要发通知，其实就是要发一条消息，我把这个消息让他队列里就不用管了，我可以继续处理别的事情，然后由专门的消费者线程去处理它，这样的话我们称这种方式为并发的方式为e5的方式，同时进行的方式。

具体来说消费者现场要干什么？它主要是从队列中读到这个消息，然后的话最终往 Message表里存一条数据，因为你看我们之前做过私信，我们发一条消息无非就是往这个表里存一条相关的数据就可以了，对吧？

所以他就是做这样一件事。

好，那么怎么说，从这个技术角度来说，我们用的是卡夫卡消息队列来解决问题，然后不同的操作我们用不同的主题来解决，这是技术角度。那么从业务的角度，我们称解决问题的方式是这种事件驱动的方式，我们称评论是一个事件，点赞是一个事件，关注是一个事件，这个好理解三件事对吧？

我们在解决问题的时候，是以这个事件为。

这个目标。

以事件为主体来解决的，所以我们在开发的时候是基于事件对这个代码的逻辑再进一步的封装，在卡夫卡的框架的基础上，以事件为主体进行封装，而不是这个消息，这是我们通常的解决这类问题的一种习惯。

那么具体来说我们称评论点赞关注这个时候发布通知，这是触发这个事件，这是事件的触发时机。

我们具体要开发的时候需要第一个我们需要把这个事件对象定义出来，对事件发生的时候所需的数据进行封装，而不是说我们就发一条消息就拼一个字符串，那样的话太简陋了，我们拼一个事件对象，这个事件对象中包含了这条消息所需要的所有的数据，至于说你消费者想怎么拼，那就是你的事，这样的话会更具有扩展性一些，而不是拼死一个字符串。

好。我们封装了这样一个事件对象以后，我们因为是产生消息对的解决问题，所以说我们需要开发生产者开发消费者，生产什么？我们生产的是事件，消费的也是事件。当然你消费了这个事件的时候，最终你是要把这个事件转换成一条消息插入到数据库里，所以整个我们的开发是做了一个更高级的抽象，更高层的设计是面向事件驱动编程的。

好了，那么大致了解我们要解决问题的方式以后，接下来我们就来写这个程序，我打开我的开发工具，刚才也说了，首先我们需要定义一个对象对事件进行封装，要封装什么？事件触发的时候，相关的一切的信息。

好，其实这也就是一个实体封装数据的实体。

那么我在安贴包下新建一个类叫int实践，然后这里我提供一些属性，首先 Topic主题，不同类型其实就是事件的类型，我们再从卡夫卡的角度来说，管它叫主题，就是事件的类型好，然后这个事件是谁发出的，你要加以记录，我好能追溯到它的来源对吧？

因此我再加一个user，ID这是事件的触发的人，然后这个人做了什么操作，他是点了赞还是回复了还是关注了对吧？

那么我们要知道这个事件发生在哪个实体之上，因此我们还需要记录 NTT太实体类型以及 nttid实体ID另外实体的作者是谁？帖子也好，评论也好，它的作者是谁？我们顺便也记录一下，因为后面也会用到帖子作者，实体作者我叫安 itt user ID这样。

好，那么除此以外，那么因为我们这个事件对象它要具有通用性，那么有可能在某些其他的业务，我们现在只处理这三种事件，将来可能还会有更多的事件。

那么在处理其他的事件的时候，那么可能还有一些其他的特殊的数据需要记录，但我又没法去预判我到底还需要哪些字段，哪些属性怎么办？我再加一个map，我把其他的所有的额外的数据全都存到 Map里，这样的话让它具有一定的扩展性。我就叫data，数据然后我先给它识别化一下新卖的。

好了，那么有了这些属性以后，我们当前的业务很容易用这些字段封装，那么其他的业务也差不多，然后如果实在不够用map来封装基本上就ok了。

当然了。

接下来我得生成对应的 Set。

好，那么生成盖特赛的以后，这里我再稍微的改一下这些方法，为的是什么呢？为的是我们在构造这个对象的时候方便怎么改造，你看我这样做盖的方法有反馈值了，而sat没有反馈值，那么我把它加一个返回值返回就返回当前的类型，然后这里我有一天类似这样做有什么好处？

就是当我们在调用 set方法的时候，我set了 topic，肯定我还要set的其他的属性，我set完topic以后又返回了当前的对象，我又可以调用当前对象的其他的set方法，所以我们在写代码的时候就可以一曼特点赛的topic，再点赛的优质ID在点在的什么，这样就方便，当然有的同学可能会质疑你为啥不写一个有参的构造器，然后一股脑把参数传进去，那样也可以，但问题是我们的属性比较多，如果说你加一个很多参数的构造器其实也很麻烦。

再一个有的时候可能某一个字段，比如字段有的时候不需要传对吧？你构造器里又声明了，有的时候也很麻烦，我这样的方式它既灵活，然后的话又方便，所以说我们通常可以这样做。

好 Site Top给我做这样的处理以后，其他的site也是类似的处理，然后这个也是返 site返回emit券类似site itt type一样， set Entity ID悠哉ID。

好，那么最后对于卖法我要稍微再就特殊处理一下，那么 get data返回整个map中的数据不动了，那么这个site data。

我。

也是做类似的处理，但是其实我site data我想这样，我不想直接让外界传过来，整个一个麦我稍微改造一下我改造成什么，外界调用时只穿一个p以及一个value，然后这里边我这样做，我把 key value data点put key外流，原来它生成的是直接传整个 map，但是我现在改了成只传一对k外流，然后我把 k外流存到 map里，这样外界调用方便直接调对象点set data就传一个值，在set data又传一个值。

当然为了调这个site就是方便能连续调，我也让他返回去慢点，我听对c那么如果你有多个值要往 map里传，你就可以 event点set data传，一个再点set data传，另外一个我们这个方法可以无限的掉下去，这样很方便。

好了，那么事件对象我们就处理完了，当然如果你不用这样做，你不这样做，你用以前的方式做也是ok的，但是这里面我们稍微设计一下，为了以后方便，因为其实以后我们会处理很多的事件，到时候你就知道它的便捷之处了。

有了这个事件对象以后，接下来我们就开发这个事件的生产者与消费者，那么生产者与消费者要做什么？我们上节课通过测试类其实也演示了，只不过这里

我们所关注的或者。

说我们所处理的不是一个字符串，而是一个对象，就这样。

好，为了写这个代码这样我再建一个新的包，事件的生产者与消费者，我建一个新的包。对他家里封装这个包名我就叫一麦，然后先写生产者，生产者我叫 invent producer，然后 B需要交给容器管理，所以说加上complaint，我们上次课演示测试代码你也知道生产者他需要调用卡夫卡template去发一个消息对吧？

所以我需要把卡夫卡template给它注入进来。

另外生产者我们需要提供一个方法，事件的发送消息的方法，当然我们现在的处理的主体是事件，我就要处理事件就不要发布消息了，咱们从业务角度来阐述处理事件。当然了处理事件的本质就是发一个消息，那么这个方法拥有的方便外，外界调用不需要返回值，通常我们习惯于管这种方法叫发1万就触发一个事件。

当然你外界调用的调用这个事件触发的方法的时候，你肯定需要把事件对象传给我，谁调谁传，因为你调用方才知道我是什么事件，它包含哪些数据对吧？

你传进来我们封装的对象就有用了，emat好，那么我们这里要做的就是发一个消息，把这个事件所包含的数据发出去，我就写个注释说将事件发布到指定的主题，那就卡夫卡template这样，那很显然首先它需要两个数据，一个是主题，主题的话咱们阴暗的点不是有吗对吧？然后其次我们要发一个字符串过去，那这个字符串应该包含事件对象中所有的数据怎么办？

最好的方式是我们把一曼转换成一个Jason杰森字符串，那么消费者得到这个字符串以后能把它还原为int，这样的话他就得到了一般的事件中所有的数据，然后做进一步的处理，至于说他怎么处理，那是根据业务情况而定，我们这里只是负责发出去就可以了，所以我这样写节省 object，ok，然后节省词句，然后把英曼传进来，这样的话我就发了一个消息，只不过这个消息的内容是一个计算字符串。

Ok了，那么有了生产者以后，我们需要再去开发消费者，我在1万的包下再创建一个新的类是事件的消费者跟summer，那么我在这儿也需要把它声明到这个容器里加上一个control的注解，然后这里边我一会在写代码的过程中，我需要记日志，因为你处理这个事件发布这个消息这个过程可能会有一些隐含的问题出现，我们一旦发现问题要记日志。

好，所以我先声明一个记录日志的组件，然后传入当前的类。

另外我们处理这个事件最终要干什么？咱们刚才不是也讲了，我处理了这个事件其实就是最终是要给某一个人发送一条消息，而发消息我们最终是要往 Max表里插入一条数据，这就是发消息在我们系统里要往max表里插入数据，你是不是得依赖于 max service，对吧？

所以我把 my sister service重新来依赖它。

好，接下来我们就要开始写处理事件就是消费事件的方法。

那么。

我们可以写一个方法，消费一个主题可以这样做，也可以就是一个方法消费多个主题，因为我们上次在想卡夫卡里森那然后 topics等于大括号，就是说一个方法可以消费多个主题，这是可以的，同理同时一个主题也可以被多个方法消费，其实他们是一个多对多的关系。

那么你看我们业务当前这个业务是评论时点赞时关注时发一个通知，而这个通知最终的形式是非常接近的，我们可以看一下精神一面看这个消息，最终通知的形式是非常接近的，就是说了某某点赞了你的帖子，某某关注了你，这个形式非常接近，所以因为他们很相似，这个逻辑，其实我们可以写一个方法，把这三个主题都处理掉，他们一类似是吧？

所以我这样写卡夫卡listen topics等于好等于主题，我们现在得定义一下主题常量，不然的话这里怎么引用对吧？我们定义常量，这样我找到长城接口好，现在我定义的是主题时间的主题，首先是评论好这个主题我把它定义成4种类型，然后的话是topic。Comment等于comment。同理再来主题。

点赞。

Topic Like，好，再来主题关注。好了，那么这三个主题我就定义好了，以后我再回到刚才的消费者这个类当中去，然后我实现接口，便于引用它里面的常量。我说了这个方法我要消费，三这三个主题我都要消费，我就这样写topic，comment。

Topic like topic followed。

好，然后我来定义方法，消费者这个方法probably why Handle我要处理的是多种主题，这里我咋写我写这样handle选一个代表 handle comment卖水，然后同时也把另外两个处理了，就是这样的。然后我们也知道这个方法需要加一个参数，用来接收相关的数据，那么这个参数就要啃萨玛瑞靠的，别看了。

那么在这个方法之内，为了让程序更严谨，因为这是一个公共的组件，尽可能的严谨。

所以首先我做个判断，如果说return它等于not或者record来了，它等于浪，假如万一说这个值是空的，发了一个空的消息，我需要我就不进行接下一步处理了，我就直接明确了，但是我要记个日志，那个点l的消息的内容为空，所以说我没有处理。

那么如果消息的内容不为空，我们知道我们发的消息它里面的内容是一个杰森格式的字符串，我们可以把这个字符串恢复成相关的对象，恢复成emat我就节省 Object。

然后第二 pass，ok解析为对象，那么我们需要传入的是阶层格式的字符串，那就是recall点value点to string。另外你要指定具体的类型，就是这个字符串它对应的类型是什么？是emat叫class。

好，那么转了以后我们再做一个判断，emat如果等于二，如果你转换以后对象结果是空的，这个时候我还是认为不对，还要做一个判断说消息格式错误，如果说有值，但是你还原不回来，那就是格式不对，这个时候还是好，那么如果说内容也没问题，格式也对了，我们就可以大胆的利用这个数据去发送站内通知，所谓的发送战略通知其实就是一个发战略性，是把这个就是构造一个message，数据插到message表里。

好，我们再回顾一下 message表，这里面有ID，然后有消息发布人的ID，有消息接收者的ID，另外还有消息内容状态以及消息传递时间。然后之前是有一个叫 conversation，ID是会话ID是两个ID，拼在一起小的在前，大的在后。

但是你要注意，我们现在发的消息和之前的私信有所区别，私信是张三发给李四是两个用户之间发，而现在我发通知是我们的系统后台发给用户，后台的话， user其实真实不存在，这样我们可以假设后台也是一个优点，比如说假设 user ID是一我们招一个虚拟的用户，永远都是一向某人发消息，这个时候你康c是ID，你再去存两个ID拼在一起就没有意义了，因为肯定from ID是一固定的，对吧？

因此你看就像这样，这之前有以前的就是测试的数据， from，ID发通知的时候它一定是一所以你康ccid存这样的数据没有必要，这个时候我们这里存什么，我们这里就改存为主题，你是评论点赞存主题，因为我们要存一个主题对吧？通知对应的主题。

另外内容里头我们存的就不是一个具体的一句话，我们就存的是纯什么？纯，我们将来在页面上要拼出这句话所依赖的条件的字符串，一个介词字符串，我们存一个Jason字符串，这个字符串中包含了我们要拼这句话的各种条件，我们到页面上得到这个对象就能拼这个条件这个意思。

好，你从我之前给的测试的数据中也能看到，大概的意思我们就按照这种方式来存，同时也是复用这张表，或者说这张表它存了两类数据，一类是人与人之间的私信，一类是系统给你发的通知，他们存的时候有所变通，注意。

好，那么说完了这个规则以后，回过头来我就开始要发送站内通知了，我要构造 Message，这里我写个注释，发送站内通知，主要就是构造一个message对象，然后首先 message site。

我们先site from ID，ID不用ID是自增长的对吧？

From ID刚才也说了from ID系统用户我们给他规定就是一第一个用户，你看我们的表里有这表里，因为这表里莫干山有条数据就是系统用户我们就要它当然了你这里可以直接写成一个一，或者最好把一定义成常量，这样别人一读好明白这个一是啥意思？

为什么是一这样我在这里再加一个常量，这是系统用户的ID，因为我要这里要存的就是ID系统用户ID，那么就是个整数，然后的话我给它取名字叫sister，我们就在ID等于一表里已经有了，好，回过头来这里就应该写system就是ID。

好，这是消息的发布者。

那么接下来我们还得去构造或者说设置这个消息的接收者 site to ID我们这个消息是发给谁？你看一下 Invent。那么是当前这个事件的触发的，那个人比如说点赞，张三给李四点赞，这就是张三。张三给李四点赞，我们应该通知给李四，李四是谁呢？这个是李四发的帖子的作者，他对吧？

所以回过头来你这里要设计的设置的是until又在ID，那么我就写event，从event里取event，点get Entity有个ID，然后再往下要处理 Conversation ID site，conversation ID刚才也说了，这里我们存的不是真的是conversation，我们存的是主题，主题我们也可以从银滩那里获取掏给他，然后再来接下来我可以那个状态默认是0就是有效的，所以我就不用去设置了，默认这个对象里那个值就是0。

然后是site create time，当天时间就可以了。

除了这个以外，我们还要设置什么 content，这个内容应该是里边是包含的是一个对象，这对象包含的是页面上，我要拼这句话的数据，好拼这句话应该是或者说进去以后，那么这是评论的详情，那么这句话中应该包含什么？应该包含这件事是谁触发的，然后他是对哪个实体做了一个什么操作实体你要存下来。

另外你看点击查看能练到哪去，因为他评论的是你的帖子，你要练到在这里没有具体做，你要列到帖子上去，而列到帖子上面我们知道其实就是列到帖子详情页面，列到这个页面我们需要知道帖子的ID是多少，我们才能练过来，因为这个路径上面是包含了帖子的ID，好，所以我们需要这样的一些数据回到这个代码里，我可以这样处理，我做到一个map， Map就是纯的是具体的内容，最终我把它转成阶层格式的字符串，存进去就可以了。

好迈克。等于6，好新map。

好首先 map点put我要存一个优质ID，就是纯这个事件是谁触发的？优质的ID，优质ID我可以从一般的里得到。好，那么有了uzid我就能知道这个事件是谁触发的，我就能知道这个人的名字以及相关的其他的内容就可以了。然后再来map点put anti tap实体的类型。

因为我要知道你是评论了一个帖子，你还是处理了哪个，你是对哪个尸体做出了一个处理，所以这个类型也要记录下来，这个类型我可以从事件对象中获取，因曼特太好，然后再来map点put NTT ID，具体实体的ID我们也需要记录起来，这个也是从这个事件对象中可以获取。好，那么注意大家这块不要乱，就是说我们这个事件对象是事件触发时封装了相关的数据，那么我们事件的消费者在消费这个事件的时候，我得到是原始的数据，但我最终需要把这个数据转化成一个message，这个message里包含了一些基础数据又包含内容，最终这个内容你是要拼出拼出这样的话，而拼出这样的话，我们需要知道的是用户的ID，还有我们操作的目标相关的信息，所以说我把这些内容都拼进来，所以说这里需要一个数据的转化，不要乱。

然后当然了，我 invent里可能还有一些其他的数据，可能还会有一些其他的数据，当触发事件的时候，如果你这个时间稍微特殊一点，可能还会有其他的数据，这些数据我也不方便存到message的其他字段里，你存到什么康复c这里啥都不太合适，我也一股脑存到 content里，总之不方便存的字段我们统统的存到content里。好，那就这样做。

我就先判断一下。

看一看那个事件对象里 map有没有值。一曼特点get data。

第二判断一下is empty加个感叹号。如果说它不为空，不为空，我就要把 In one的map里的所有数据拿出来，存到 map里，也就是存到 content的字段里，好，我就遍历一下慢点安全。

好，那么我便liemandt每次便利得到一个安全，然后的话in Mandt点get date安吹sat，然后遍历的是一个p86的集合，那么每次我能得到一个q86，每次我要把 q86怎么办？存到这个是内容，这样我把跟他们去写叫content，这样的话大家能够这个表里字段对应起来，这from ID to ID这是content这样好一点。

好，然后这里我就写了content点put的安全 get key entry点。Get value我就把 p value直接存到 map里， content里存了这些数据以及可能存在的一些额外的数据，就这样它存的数据比较多。

最后 counter我是构造了一个map对象，我还得把它存到放到 message里，不用message点site，content，我这里需要的是一个字符串，我需要把它转成一个Jason字符串， Jason object，然后点to Jason词句，然后 content。

好，那么现在 message我终于构造好了，构造好以后我就可以存了，我就掉message service，然后点ed message。

好到这儿我终于把这个方法写完了，这个方法它消费的是三个主题中的数据，而消费的逻辑都一样，就是发送一条消息，而消息的构造的方式也一样，就这样。

好，那么处理完以后，那么接下来我们需要调这个程序，现在还没有地方调，当然义卖这个我们不用去主动去调，它就是一个封装数据的实体，我们主要是要调这个生产者与消费者，对吧？你什么时候要触发事件，就去调一下生产者处理这个事件就可以了。

那么消费者我们知道他是被动触发的，只要你对这种有数据它就自动就执行了，对吧？这个不用我们主动去调，我们只要主动去调这个producer就行。

按照我之前所讲的业务，我们应该是在这三个地方去调的，评论的时候点赞的时候关注的时候是吧？所以那么我就打开对应的CTRL了，首先是评论，咱们一个来评论是comment controller，然后还有点赞like controller，还有是关注 Follow controller，那么这三个controller这里边我都需要做相应的处理。

一个来首先我先处理 comment controller。好，那么 comment control我需要处理事件，我需要注入 producer，当然了另外两个CTRL也需要调，也需要注入，我干脆copy，然后再回头逐个处理。

那么你看这个方法是添加评论的方法，添加评论以后我就要通知了，以后通知，所以我在爱的comment之后做通知的行为，这里我要做的事情就是触发评论事件，那么触发评论事件首先你要构造事件对象，把事件相关的内容包含进来，好，你看我就谬1万，然后的话直接调这个对象点site topic的方法，因为是评论事件，所以说那个事件的主题应该是topic，我要引用常量，implements，community constant，那么另外两个也需要做类似的处理，我直接copy有了，不用了，好，那么这里应该写的是 topic，comment，然后因为我们这个方法直接委托了类似，所以我还可以继续调对象点，其他的site、方法、site又在ID，你看这样是不是方便？

好，这个事件是谁触发的？肯定是当前的登录者对吧？登录的人是谁？不就是他，所以 site UI d应该是它，然后 Site on TT type。那么这个on TT type，我们可以从当前的com的数据里得到他们的概念，安迪地带的然后再点sat，安迪的ID，安迪的ID我们依然可以从 comment里得到。

好，然后最后我们在拼，刚才我也说了，我们在拼那句话的时候，最终的话拼完那句话以后还有一个点击查看，而点击查看要练到帖子详情页面，对吧？

练到帖子详情页面，而练到帖子详情页面，我们是需要有一个帖子ID的，所以我这里还要传一个帖子ID，但不是每个事件都需要帖子ID，所以我在设置设计 EMAIL的对象的时候，没有一个明显的帖子ID的属性，我可以把帖子ID存到 map里，site data，那么 key我叫post ID，那么值对应的值帖子ID，咱们这个参数不是有吗？

好，这样，我消费这个事件的时候所需要的数据我都放到 EMAIL里，可能有些用不上，但我们宁多别少就好了，这里还还有一个小小的欠缺，实体的作者安推推优质ID，这里我没有拼，为什么没有拼呢？因为我评论的目标可能是帖子也可能是评论，对吧？我评论给你的可能是帖子也可能是评论。那么 Nttuzid我们就得查了，如果是帖子你要查帖子表，如果是评论你要查评论表，所以这个得有所区分的。

所以这里我做个判断，然后去查我这样，而且comment点get itt type，如果说这个类型是itt type post。如果我是给帖子做评论， indtuzid应该是存的是帖子的uzid在这里我需要查查帖子，查帖子这里我可能还需要再注入帖子的service。

回到刚才的位置，这就查了。就是discuss post service然后的话点fine的白底。这个ID就是comment to get anti ID，评论的实体的ID，此时是帖子类型是这个好我得到了当前的帖子， discus我管它叫它盖的，这是我们评论的目标。

好，因曼特我再补充一个属性，site安推优质ID， Uzid就是他要get uzid应该是这样的，形式应该是这个数据。

好，再来，还有一个可能是我当前评论的是评论的是一个评论 comment的get empty tap等于comment等于的是ntat comment这个时候我这个to get就是一个评论了，我这也需要查他们to get等于 comment service点find。

应该是find comment by ID但是目前我 service里还没有，我还需要做一个补充，好，我首先看一下 find不是不知道哪儿是他们的map，没有这样的方法。我没有我做一个补充，好，就是我根据ID查一个comment，我需要对它做一个实现。

我搜一下 comment，map摘写一个select，他的ID copy一下，然后 without是卡门类型，我查询的话可以这样copy一下，好。这个很简单，select这些字段 From common，然后再加一个条件就好了。 Id等于ID。好 Map实现完以后，我再去找到 service，然后在这里加一个方法，这方法public fund come by ID。很简单，直接就return。Come to my book。点c ID就行了。好，简单补充完以后，我再回到刚才的我程序进行不下去的位置，我再继续下去这个地方。

犯的他们的白d这个com的应该是什么？是com的点get安吉的ID，我评论的实体ID我的目标，那么这个目标里头包含了一个uzid我要把它存到 Email里，一曼特点site，Entity。

Use ID那就是它 get use ID这样总之这块稍微麻烦，在不同的类型，你要获取它的作者需要稍微的处理一下，到这儿我们一曼的数据就全了，那么全了以后我就可以发布这个消息了，我就调 producer in mind，producer然后去处理这个事件点fair in mind存进去。

那么你看我这个位置构造完一曼特以后，我只要调一下发一曼，那么我当前线程立刻向下执行，立刻去处理我这个页面的响应就完了，而后续说你这个消息的发布，那就是由这个消息队列去处理了，它可能略有一点点延迟个若干毫秒，顶多一两秒就发布到目标头上去了，所以这就是并行的，并发的我在处理后面业务的同时那个消息来处理了，或者说也叫异步的，我后续的业务在处理的同时，另外一个线程也在处理那件事，所以这样的方式就处理效率高。

而且一旦说现在有一个热帖评论的人非常多，我当前的线程只需要把一曼丢到堆这里我就不管了，那么它的处理的能力就提高了，处理能力就提高了，现场也可以攒着很独整息，他慢慢处理好。这就是消息对立的好处，它起到一个缓冲的作用。

好，你了解了以后其他的什么点赞，这个follow其实就类似了，也是做类似的处理。好我们再去处理一下。下面处理点赞，好那点赞的话应该也是在这儿，我点赞完以后，然后我去触发这个点赞事件，我在这加一段代码。好，触发点赞事件，你注意我这个点赞其实是一个具有双重能力的一个方法，它一个是你点一下它是赞，再点一下是取消赞对吧？我们给用户发消息发通知，显然是你赞的时候发个通知他就行了，如果是取消他就没必要通知了，那就太恶心了，对吧？

所以这里我们得判断一下，如果说这个like status它等于的是一的话，假如说我当前的逻辑是点赞这个时候我才去触发这个事件，否则的话你不是点赞，我就不去触发这个事件了。好，那么触发这个事件无非就是还是构造 Email的，因为EMAIL的然后点site这个topic是topic like。好，然后点site优质ID，site。优质ID。那 c点的站还是当前用户对吧？那就是household get user get idea，好再来，然后这个实体类型site安推推 tap，安迪的tap这里不有吗？

好，然后再来site inttid参数里也有，我就直接写过来，好，然后再来 sat安推推又是ID，这里也有，好，然后注意最终我们拼了点的这是点赞的通知，你查看的时候也是说是某某人，其实这里这个页面应该是提示应该换了某某人，占了你的什么东西，然后的话点击查看，占了你的帖子，占了你的评论点击查看，一点击查看也是去到帖子详情页面，所以我们也需要一个条件就是帖子ID这里也需要帖子ID，好，所以这帖子ID我还是要site，data放到data里，还是叫poss的ID，但是我当前的方法里我是得不到帖子ID，当然你可以去判断，如果点赞的是可以点赞给谁我去查，这样麻烦我这样我重构一下这个方法。

我要求这个方法在家在多接受一个参数，就是post ID我要求你点赞的时候把它传进来，因为我们是在帖子下面应用去点赞的，那个时候很容易得到 ID传进来就好了。

所以这里我就传进来，当然一会我们需要改一下那个页面，改一下 GS，这样才行，好到这就可以了，咱们这个EMAIL就构造好了，观察完以后我们还是触发一下实践就invent producer，然后的话点发一卖把对象传进去。

Ok那么最后这个就是关注事件的处理，我们再打开 follow controller，那么关注的时候你要去发通知，取消关注不用。

好，那么同样的我也需要在关注之后做这样的事情， follow之后做这样的事情，这里我要触发关注实践还是构造 invent，点site，topic这个topic topic点topic follow，然后的话site user ID那是谁关注的？

肯定是当前的登录用户对吧？House头的get，user的get ID，然后 site itt type目前我们关注你看他也闯进来的 itt type和ittid所以说你直接就写这个参数就行了。

然后是site ittid也是这个参数直接有了，然后我们现在其实只能关注人，所以其实安得太不一定是个优质ID，所以说我就这样写了一点 site。

On，ttuzid然后还是on ttid的，当然如果说将来我们可以关注更多的类型的实体，这个时候我们在这个地方还要再变通一下，当前我们这样处理就ok。然后关注和评论点赞不一样。

关注是这样的，就是说某某人关注了你，完了他关注了你完了，而不是你的帖子，你的评论他是关注了你这个人对吧？

所以说这里边我们通过这条消息，如果链接的话不是链到帖子详情上去，而是链到某一个人的主页上去，比如张三关注了你，你就链到张三主页上去，你看他关注了我，而这个评论点赞点赞的是帖子是评论你要练到帖子详情页面，所以他们需要post ID，这个不需要，所以这里我就不再带data pose ID了，这样就可以了，然后的话一曼特丢手点饭1万，好到这儿我终于就把这三三种事件触发完了，触发完以后别忘了咱们这个点赞刚才不是说要重构一下，加了一个post ID对吧？

为了方便，那么为了加 POS ID，我需要改一下帖子详情页面点赞的方法。

好我搜一下 xx点q点前面我们调的是 like方法，我们要找到这个like方法，然后依次的进行一个处理。

好，那就是给他再多传一个参数，最后你看这是两个三个，最后再来一个参数，这个参数是帖子ID，而帖子我们当前页面上就是post，所以 post点ID就可以了，我copy一下，然后我们再往下找，那么其他的两个方法其实也是一样，处理方式非常简单，就是在后面加这么一个条件就行，再找这有一个like也是加个条件，这有一个like加条件，好处理完了，当然你调的方法多了一个参数，你这个方法得改一改，这个方法我是定义在 GS上的 discourse点GS那么我就需要在这个方法的上面加上参数， post ID，然后我需要把这个参数传给后台，所以我再加上一个post ID问号，post ID好了，到这儿我就处理完了，当然我这只是说处理了这个事件的触发以及消费，那么至于说将来在页面上怎么显示，我们现在还没做，我们这次课先不去处理显示，下次课再去搞定显示，这次课就是说当我做评论做点赞做关注的时候，我能把这个消息发成功，我上表里一看这数据有了，表示说这一步完成了就ok了，做到这一步就可以了。

好，写完以后咱们测一下，我启动一下这个服务，然后你这回我们在启动服务之前一定是要把组keep卡夫卡服务器启动的，因为我们当前的应用已经依赖于这样的服务器了，如果你不启动的话这会有问题。

然后这里关于卡夫卡的服务多说一句，组keep一般没什么问题。

卡夫卡应用，它 windows的客户端做得不好，就这个客户端经常会由于某些原因崩溃，如果你去看他的报错日，他经常会说某一条数据被锁死了或者怎么样，有了问题有了冲突他起不来，经常会出现这样的情况，你说这个东西还能用吗？

这个东西其实它windows客户端不稳定，但是它Linux没有问题，Linux很稳定的，而你要知道我们外部应用的服务器基本上都是Linux，基本上没有人用 windows服务器，所以说在上线的时候这个问题不会有，但是我们在练习的时候，因为我们大家用的常用的都是windows系统，所以我们就装了这么一个不稳定的客户端，希望你理解，那么一旦说你说我发现了启动这个事我启动不起来了，一启动它就自动就没了就关了，这个时候怎么办？

也很好解决，我告诉你你就打开这个就是你卡夫卡日志存放的位置，你直接把这个目录删了就行，你把这个目录删了，它里边什么数据都没有了，自然也不会什么锁死了，就解决了，这个问题就很简单。

好了，我这个数据服务已经启动起来了，我们测一下。

好我先访问一下首页，当然我需要登录好登录，然后比如说我要对 AAA的帖子做出评论，好我要评论你就随便写一个别CC了，你好好这就评论了，评论完以后我去看一下我这个表里有没有对应的那么一个通知出现。我查询 Message，奥特曼ID d SC倒序，没查到，看一下有没有报错，估计是有一些问题。

报错了。

报错的时候我们看其实主要就一般看第一句话，看他大概报的什么错，他说在这里在 can some record里，肯萨姆也靠它弹出来这个消息，然后这儿有说明说在憨豆肯萨 comment message这个方法里报了错，然后报的是控制人异常的错误，然后就没有具体的说到底是哪个报的错，我们再往下看。

下面的话是底层的代码，我们不用去看底层代码，它一般比较严谨，不那么容易有漏洞，主要还是看一下和我们的程序有关的地方控制异常。你看这个类是我们以前写的 LP的类对吧？他说这里报的错点一下，如果说这句话报控制人异常的话，那很显然是这个对象为空，调这个方法就会报错了，对对象有可能为空吗？

 H表示是和请求有关的对象还真有可能为空，那么之前我们没有生产者与消费者，因为我们当前的LP是拦截的是 service，我们所有对service的访问都是通过CTRL访问的，但现在我们有特殊情况了，刚才我们写了一个肯萨姆消费者，消费者里面我们也调了一个controller，那是通过消费者去调的，不是CTRL去调的，消费者调的service不是通过CTRL去调的，所以这个时候在这次调研里它就没有request得不到，所以这块就出现了控制异常，这是我们当时写代码其实不是特别严谨。

好，那就做一个判断判断 request，这样如果我简单处理，如果h表示他等于那表示说这是一个特殊的调用，不是一个常规的页面的调用，这个时候我就不去记日志了，或者说你也可以做更其他的处理，就是说你在这种情况下你记日志就不记这个IP了，也可以这里我就干脆我就不记日志了，就退了算了。好总之逻辑你可以自行处理，这里我就做了一个简单的处理。

好，改完以后你得重新编译一下，它已经重启了，然后我们再来试一下，好。再评论一下还是你好，再看有没有报错，这个应该没报错，看一下表里的数据是否有变化。你看有了系统一给111发了一个通知，通知的主题评论，这里边包含了一些一些我们需要的数据 Uzid and the type等等，这就行了可以了。

好再是除了评论以外还有赞，我已经点过赞了，这样我把它取消掉，然后我再给他点一次。好，然后再看like又是一条通知对吧？好然后这样我再评论点对AAA点评论，我找到一个AAA这个是AA的评论，我要给他点赞，好，然后再看又一个like，你看刚才那个点赞的是这一类型是一对帖子这个类型是二，对AA的评论点的赞，好。然后关注已关注我取消掉，重新关注一下AAA然后看一下表里的数据，follow a to111，对吧？

Tap是三，那么到这儿就基本上证明我们对事件的处理是通的。当然中间出现了一个小问题，就是我们之前写代码的不严谨，所以说你在写程序的时候，尽可量的要去多做判断它是否为空什么的，让代码更严谨，不然的话出现问题的话也比较恶心。好了，至于说后面根据这个内容，我们怎么去做展现，那是我们下次可能要继续探讨的话题。好，这节课我们就演示到这里，咱们下节课再见。