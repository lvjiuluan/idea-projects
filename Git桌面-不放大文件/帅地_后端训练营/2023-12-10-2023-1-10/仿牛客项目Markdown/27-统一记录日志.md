27-统一记录日志.mp4

这次课我们来实现统一记录日志这样一个功能。那么有的同学可能会想，我能不能利用上次课我们所学的控制器通知来统一处理，你注意控制器通知它是在控制器发生异常的时候，我们可以统一的处理。而我这里所说的统一记录日志并不是说一定是发生异常，平时不发生异常我也要记录日志，控制器通知可能就不太管用了。

再有同学可能会想我能不能利用拦截器对吧？

你可以拦截所有的请求，但是拦截器也是它是针对控制器的一个处理，那么我们记日志可能未必一定是要针对控制器，记日志也可能是针对业务组件，甚至可能是针对数据访问层，而我们这次课的需求恰恰是针对业务组件，你看咱们现在不是已经开发了几个模块，包括帖子模块，评论模块、消息模块等等，而将来我们这个系统越来越完善，这个模块会越来越多，那么就会有越来越多的service。

比如说我有这样一个需求，我想对所有的service所有的方法即日志好，那么既然通知或者是拦截器解决不了这个问题，我们用传统的方式也可以解决，可能有的同学可能也很容易会想到，那也很好办。我把记录日志的代码分成了一个组件里，然后的话我在不同的service的方法里去调就可以了。

比如说你要在方法一开始记日志，你就在写的业务方法时就先记日志，然后处理业务，当然这样肯定是可以解决问题的。

不过这种解决问题的方式比较原始，它有非常大的弊端，它的弊端在哪里？我们这个方法是业务组建的方法，它的主要的功能是用来处理业务的，而在处理业务的同时，我业务代码业务需求的前面或某一个地方，我却需要去加入记录日志这样的需求，而记录日志其实它不是业务需求，它属于什么需求，它属于系统需求。

我们系统当中很多功能都具备的同一类需求，我们把它归纳为系统需求，所以我们在这个业务方法里偶合了就系统需求系统需求、业务需求偶合在一起了，这样是很有坏处的，你可以这样想，比如说将来有一天我的系统需求要发生变化，比如说我不想在前面记日志，我想在后面接着治，你想我们这个程序中会有多少个业务组件，有多少个业务方法，你要改多少遍对吧？

或者说我不要在前面或后面记日志，我要在这个抛异常的时候记日志，或者是我要在某些方法中记日志，某些不记日志，一旦这个业务发生变化，那么你的改动是非常大的。好，这就是问题。

那么有没有一种办法能够很好地解决这个问题？有。而解决问题的最好的办法就是我们将这个系统需求，像记录日这样的系统需求拆分出去单独去实现，而不是硬编码到业务方法里什么样的方式能做到这一点，咱们看新的技术叫aop，但是 Aop我早先在介绍 spring的时候就提过，那么我们先来了解一下它的概念， aop它是这样一组单词的缩写叫aspect oriented programming，那么翻译过来就是面向方面编程，那么也有人把它翻译成面向切面编程都无所谓了，不过我们从表面上其实很难理解这个方面切面是什么意思，这种辩证方式代表什么意思？

确实就这项技术它是一个比较抽象的概念，我们学aop其实很多的篇幅主要就是理解这个概念，理解aop的术语，理解它能解决什么问题，而至于说AP的使用，那个代码确实非常简单的，所以我们这次课我们需要花一点时间把 aop的概念给大家说清楚。

然后接着说 aop它其实就是一种编程思想，那么这种思想是面向方面的编程思想，它是对面向对象 op思想的一个补充，那么有了这种补充以后，我们在开发的时候就可以进一步提高的编程效率了。

好，我们再回到刚才的业务当中去，你想我们用普通的op思想放到一个b点去调用，去解决那个问题，有不好的地方对吧？那么我们aop就能很好的解决。所以说它是aop的一个补充，你注意 AP和op它是互补的，它并不是一个就是竞争的一种状态。

好了，那么如果我们采用aop思想解决问题，可以做到这样的一种程度，看这个图，比如说我们程序中有多个业务模块，而每一个业务模块都有相同的这个系统需求，比如说我要对他们统一记日志，我要对他们统一做权限检查，我要对他们统一做事务管理，那么我们使用aop就可以统一解决这个问题。

而我们使用aop解决系统需求的时候，我们只需要单独定义一个组件，这个组件和业务组件不发生任何直接的关系，你不用在业务组件里去调它。我们额外的定义了一个系统组件，那么把这些个所有的业务组件的通用的逻辑都封装到那里面去。

所以如果画图来看的话，就好像这样一种感觉，就是我这个组件它横跨了多个业务组件，它横向的扩展了业务组件的一些需求，横着切了一刀，所以说那么从直观的感官上给它命名，这叫面向方面，编程就是我们编程的角度是面向这样的一个横切的组件的。

好了，当然这样的话也并不能够让你彻底理解 Aop的概念，下面我们再往下细看，你要想理解aop首先你要了解aop的相关的术语，它的术语还挺多的，我们一一来介绍，首先我们要想处理的那些业务组件，那一批业务组建的系统需求，这一批业务组建，一个的业务组建是我们要处理的需求的目标，这个目标我们叫套盖，叫目标对象，而我们采用aop解决问题，不是在目标对象上直接写代码，而是我们需要把代码单独封装到一个组件里。

我们封装业务需求的组件叫aspect就叫方面，或者说就叫切面，我们整个的编程的过程完全是针对 aspect来编程的，所以叫面向方面，编程 aspect里写什么咱们一会再说，把这个系统的逻辑封装到这里，这个地方怎么能知道，所以说我们就需要利用这个框架做一个植入的行为，把这个方面组件的代码植入到目标对象里，所以这有一个植入。

当然这是框架给我们提供的功能，而植入可以分为不同的时机，不同的框架，它采用不同的实现方式，那么可以在编译时植入，如果你在编译时植入，就需要使用特殊的编译器，或者可以在装载类的时候植入，你就需要使用特殊的类装载器，也可以在运行时置入，那么就需要在运行时为目标对象生成代理。所以不同的置入方式有不同的要求。

好，总体来说支柱方式越原始，编译式支柱它越原始，它的好处就是程序在运行的时候代码已经制好了，运行时速度快，但是因为你织的时机比较早，你在编译时植入可能很多运行时的条件你还不知道，可能有些特殊情况，你可能还怎么说处理的没有那么精细，而运行式植入它的好处是我程序已经运行起来了，我这个时候所有的条件我都知道，你想植入什么代码我都能解决，它比较灵活，但是缺点是我程序一边要运行，你一边还要植入代码对吧？

限制入网效率是比这种情况要低的，但是各有利弊，然后你注意还有一个概念叫连接点drop point，drop point指的是什么？你植入代码植入到目标目标对象里，你植入到哪个位置？其实目标对象可以有很多地方允许你植入代码，比如说我植入到属性上，比如说我植入到构造器里，我植入到静态块里，我植入到一个成员方法里，就是目标对象上，允许你有可能让你植入代码的那个位置，我们称之为连接点装part。

好了，最后我们再来看一下这个方面组件里都要做什么事情，其实主要做两件事儿，第一件事儿我们要声明point cut，声明切点，那么这个声明切点是用表达式来声明，什么意思呢？就是说是你目标对象有这么多地方可以允许我植入代码，我到底要植入哪些对象的哪些位置呢？对吧？你不可能说所有位置我都要植一遍，肯定是我有选择的去植入。

那么part card就是声明，我具体来说要把代码植入到哪些对象的哪些位置，然后是还有一方面的代码叫 or the west通知，那通知就是实现了我具体的系统逻辑我到底要做什么，而且呢我做的具体的位置在哪里？

我现在我知道了，比如说我要把代码植入到成员方法里，我是植入到成人方法的一开头，还是结束的位置，还是抛异常的地方，还是有返回值的地方对不对？

所以说这个通知解决的是具体植入的逻辑。

好了，以上包括目标对象、连接点、支柱方面，切点，通知这么多概念，我就介绍完了，但是我想你初次接触 Aop这些概念可能一下会非常的绕，因为这个概念太多了，而LP本身又是一个抽象的东西是吧？可能你一时记不住，然后甚至有些混乱，这样我们再稍微理一下，如果理完了你还没有记住，你把这段这个视频你再听一遍，把它搞清楚了，我们再进行下一个环节。

好，首先我们程序当中的已经开发好了，处理业务逻辑的一个并，我们称之为目标对象，这好理解。

第二个，目标对象上有很多地方可以被植入代码，那么它的那些能够被植入代码的地方，我们统称为连接点。那么aop解决统一处理这些系统需求的方式，是将代码定义到一个额外的并叫方面组件里。

那么这个方面组件在程序运行的时候或之前就需要被框架植入到某些连接点之上，那么方便组件里我们需要通过point card切点，说明我代码到底要植入到哪些对象的哪些位置，我们需要再写上通知列的方法来声明我这个方面组件到底要处理什么样的逻辑。

好了，以上就是aop的这么几个相关的术语，那么除了了解aop的术语以外，下面我们再去了解一下 aop我们到底怎么实现，因为aop它是一种编程思想，对吧？我们怎么实现这种思想呢？其实实现 Aop的思想的技术框架有很多的，这里我没有列举全，因为没必要我们也不会都用。

然后这里我只列举了两项，一个叫aspect接，一个就是 spring LP，好，那么 aspect j它是语言级的实现，什么叫语言级的实现？就是说它是一门新的语言，当然它是基于Java语言扩展而来的一门新的语言，然后他利用了这门新的语言定义了aop语法，所以说它是一门新的语言，专门解决aop的问题。

很明显它的功能会非常强大，aop所有的问题它都能解决，这是它的优势，但是它的缺点就是我们要用这项技术还得再学一门语言对吧？这个代价比较高，所以说有利也有弊，然后艾斯拜克街它是在编译期植入代码比较早的时候植入代码，然后它里边有一个专门的编译器用来生成遵守Java字节码规范的克拉斯，这是艾斯拜克街，然后艾斯派科技它支持所有的连接点，你想在哪植入这个程序都是可以的，它功能非常强大。

然后第二个要说的是spring aop它是aop的一种具体的实现，那么spring aop它是使用纯Java实现的，它的好处就是说你不用去学一门新的语言，我们就用账号就能搞定这个问题，这就很方便就能上手。然后所以他也不需要专门的编译过程，编译器也不需要什么特殊的什么类加载器，这些都不需要。

然后是不是LP它是在运行时植入代码的，那么是通过代理的方式植入的，代理我们一会还会再说，但是它只支持方法类型的连接点，就是说你只能将方便组件中的代码植入到目标对象的方法里，其他的地方你植入不了，它比较有局限性，但是你注意我们平时在处理这方面的逻辑是我们绝大部分情况至少是80%以上的情况，我们都要植入到目标对象的方法里。

这只是理论上，其实实际上我们所做的项目其实百%都是要知道放哪里。所以说其实是这样的，是不是LP它是采用了一种灵活的方式，因为它是运行时植入，运行时植入我们能知道运行时的一切上下文的条件，所以说一切逻辑我都好实现。

而它植入的位置只支持一种就是最常见的方式，就是说它采用了一种最灵活的方式，解决了一种对常见的问题，他追求的是一个性价比，那么所以是不是LP它不是一个全面的解决方案，而是一个性价比最高的解决方案。

有人会想到万一说LP有他解决不了的问题的时候怎么办？你可以再去用aspect接，这个时候 spring它是支持对aspect接的支持的集成的，所以你看spring在这个方面它追求的是一个高的性价比，而不是一个全面的解决方案，是这样的，所以这是很有效的。

好了，那么了解了aop的实现以后，我们再看最后再说一下， spring LP它在运行时植入程序采用的是代理的方式，代理是怎么回事？其实代理有两种方式，一种叫 jdk动态代理是jdk自带的一种代理方式，一种是叫siji Labbe，动态代理是第三方的一个技术。

那么jdp动态代理是Java提供的，代理技术自带的，那么它有一个要求，所就是所谓的代理，就是我们对某一个对象给它生成一个代理对象来代替它，你调的时候去调代理对象，而是不调原始对象，我们植入代码就是植入到代理对象里，那么我们使我们 spring的应用，我们所调用的b都是通过容器去调的，那么我们通过容器去调目标对象的时候，然后他一看这个目标对象上有LP的作用，你就需要他就知道我需要调代理对象，他就找到代理对象，调代理对象就可以了，而代理对象上又有植入的代码就能解决问题了。

那么我们采用jdk代理，它有一个要求，目标对象必须得有接口我才能带，在代理的时候是生成接口的一个实现类，它自动生成一个接口的实现类，然后代替了原实现类，是这样的。

所以spring它默认是采用这种方式，然后在接口的代理的实例中植入代码，但是如果说你这个目标组件没有接口，你像我们写的service没有接口，这时候怎么办呢？这时候就不能用jdk动态代理了，就需要用cg lab动态代理，而cg lab动态代理它是采用底层的自解码技术，那么在程序运行时，它会创建一个子类的代理实例，就是说你不是没有接口吗？

我可以创建目标对象的子类，我用子类来代理原来的对象，我们知道正好是支持这个多态的，那么我们可以用子类型来代替父类型，这是没有问题的。

所以当你的目标对象没有接口的时候，那么是不容易，LP就会用这种方式，这种方式也被spring的集成进来了，它会在子类的实例中植入代码。

好了，以上就是我们关于 aop的一些概念和一些实现的基本原则的一个介绍。下面我们再写一个小例子，然后来体会一下 Aop它到底是怎么回事。然后了解了它的语法以后，我们再去实现我们最终的目标，统一记录业务层的日志。好。那么我打开开发工具，然后我要统一处理，比如说业务层的某一项通用的需求，咱们先不说什么需求了，反正就是解决他们统一的需求。

我们看 aop怎么来解决，首先我在包下新建一个包，专门来存放方便组件，那么这个包我就叫aspect，方面然后我先创建一个事例，我先写一个类，实力我叫阿尔法s back，这里没有什么业务需求，反正就随便写点代码，什么体会一下 spring LP它的语法。

然后首先我需要把这个方面组件声明为一个b然后让容器来管理它，所以我需要加上一个component的注解，它不属于特定的某一层，另外还需要加一个新的注解，叫aspect表示，这是一个方面组件，它可不是一个普通的组件。

然后刚才我们说了，这个方面组件你要定义什么？要定义两个内容，第一个缺点，你要定义针对我项目中的b我要把代码植入到具体的哪些病人的哪些位置。好，那么定义这个切点非常简单，首先我就说明一个方法，这个方法没有返回值，方法名你随便取，这个方法名我就叫power in the cut，方法里不用写任何逻辑，这个切点我们是通过一个注解在方法上加一个注解来定义的，这注解就叫point cut。

好，然后在括号里我们需要写一个表达式来描述哪些b哪些方法是我要处理的目标我先写好，然后的话再跟你解释。

好了，好，其实这个很容易理解，你看这就是一个固定的关键字，然后的话星代表的方法的返回值，就是说新人表示什么反馈这都行，我不关注反馈值，然后 com点 Q点.community点service就是报名表示 service包下的星，所有的业务组件，再点星表示所有的方法，就是所有的service组件里边的所有的方法，括号里边点点表示说所有的参数，那就是说所有的业务组建的所有的方法，所有的参数，所有的反馈值，那么我都要处理，是这样的，这样的一个表达式就匹配了所有的业务水平，所有的方法就这个意思。

当然你也可以比如说这不写某不写星，而且一个具体的返回值，这里不写两点，而且一个具体的参数来明确筛选出某一些特定的方法也是可以的。

或者比如说这个地方方法名你可以选爱的心，比方说以爱的开头的方法也可以，总之这个表达是很灵活，我们利用它能够很快速的筛选出一切你想要的连接点。当然我们现在选中一切就可以了。那么有了这个切点以后，下面我们就可以来定义这个通知了，然后利用这个通知来明确的解决一些问题。

然后通知分为好几类，我可以在连接点的开始做什么事情，结束时做什么事情，返回值返回的数据以后做什么事情，还有抛异常的时候做什么事情，还有连接点前后，同时都要做什么事情，就是说它有好几类，有你我看1234有5类5类通知，而这5种通知我们是用5种注解来实现的方式大同小异，我挨个给大家实现一下，但是我的实现很简单，就是打印一句话，如果你想在连接点的一开始，开头的地方记日志，你就写注解before，然后你这里要说明哪些连接点呢？

其实就是一个切点，所以说我们需要这样写，把这个方法写到这儿来，比如说我要以此为切点，我逻辑是针是针对这个缺点，针对这些连接点有效的，好，然后我说明这个方法，这个方法不需要反馈值，方法名你随便取，我为了直观的还要比放，这里我就随便的打印一些内容。

好，你在前面植入代码是这样的，后面的话和它类似，我就copy一下，如果你想在后面记日志，你这个地方就不要写before，写成after也是缺点，方法名我改成叫after，写错了，after。

好，那么还有一种情况就是说比如说我想在有了返回值以后再处理一些逻辑，我这块可以这样写。After returning这会写after returning，那也有可能你希望在抛异常的时候植入代码，你可以这样，那就是after studio。

好，然后还有一种特殊情况是我既想在前面植入逻辑，又想在后面植入逻辑，但前后都植入逻辑，我可以用单写叫run，然后切点也是point cut。

好，那么这种情况我们就需要有返回值，返回一个object，然后还得有个参数，它的方法名忘了写了，这个就叫around，它得有个参数叫proceed专判，这个参数就是连接点，就是我目标植入的部位代表部位，方法参数名叫张胖子，好，然后我的声明抛出异常好了，写错了stress。

好，那么这个怎么去记在前面，这个处理逻辑又在后面，同时处理逻辑其实主要是利用这个参数，连接点指代的是我程序植入的部位，我可以调用这个参数，然后点proceed，不是点 proceed，那点proceed其实就是调目标对象被处理的方法的逻辑，就是说说白了就是调我们要处理的目标组件的方法，这句话就是调用目标组件的方法，然后当然目标组件可能有反馈值，你可以这样反馈一下，然后我就把目标组件的反馈值为确认掉，那么因为程序在执行的时候会执行当前的会执行一个代理对象，这个逻辑被植入到代理对象里，用来代替原始对象，而我们这段制度的逻辑是我利用它去调用原始对象的方法，这样的话原始对象方法被调了，我在这句话之前做什么事情，这句话之后做什么事情不都是可以的吗？

这样我在这句话射雕目标组件前后各加一段代码就解决了这样的前后同时处理一些逻辑的问题，是这样的。好，这里我写什么？

 Around的地方，然后这边我写a round，after，然后我们程序执行的时候，我们可以看一下这些个标志它在什么时候输出出来的。好了，这就写完了，写完以后目前这些代码就针对所有的service就都有效了，而我对service是一行代码都不用改，你可见这个死不是LP它有多强大。

好，写完以后咱们来测一下，我把这个项目启动一下，启动完以后我把控制台清空一下，这样我一会看控制台内容比较清楚一点，那么首先我访问一下首页，你看不耽误它的使用，不影响它的使用。

然后我们看一下控制台输出了多次这样的这样的标志，为什么？因为咱们首页上不是查询了帖子的列表，而每一个帖子我们又查了优字对吧？所以说我们调了多次业务组件，而针对每一个业务组件，我们这个方法都会被触发，所以说这里有多次这很正常。然后你看首先 around before环绕开始，around，后面还有around，after。环绕结束被调用了是吧？然后前置通知被调用了，后置通知after被调用了，还有返回以后after returning被调用了，这些调用的顺序我们也能够看得出来它是这样一个顺序，然后后面有第二次这样的一个逻辑。

第二次循环我们就不去看第二次了，但是这里边没有输出这个东西，为什么？因为咱们程序没报错，如果报错的话就会输出了，这个可以你自己试一下，我就不去照这个错了，因为其他的都好使，这个也没有问题，好。

所以你看这个LP虽然不好理解，但是很好用，咱们就写这么简单的代码，就能够对这么多业务组间就统一处理他们的业务逻辑非常的方便。

好了，有了这么好用的一种方式以后，接下来我们就处理我们最终最开始所说的那项需求，我就要把所有的业务组件对他们的记录日志，而我什么时候记录日志，我希望在这个程序的就是在业务组间调用的一开始进入制就是用比方的方式，然后记录日志的格式是这样的，就是说用户某某不是用户名，而是IP地址，因为可能有的用户没登录，用户某某某在某一个时刻访问了某功能某方法，就是这样的一一句话的提示。

好，这样我把实例把它注掉，因为我不想每次都输出这些内容，举一个事例明白就可以了。好，那么为了处理正式的业务逻辑，我需要再单独写一个类，那么这个类我取名叫叫service log aspect。

好，那么根据刚才我们所学的事例，我知道我需要在这加上可能的注解，需要加上 aspect注解，然后因为你要记日志，所以说你要实例化 Log。好了，然后我们首先要声明的是缺点，那么缺点我们可以和刚才 Copy一下，因为一样还是所有的业务组件，所有的业务方法我都要去处理好。

然后我要用前置通知在一开头置入程序，所以比放然后朋友你看，那么这个方法我写上怕被不好意思，比方好刚才我说了，我要声明的，我要记了日志这个格式我再来写一下，是这样的，是用户，然后比如说一个方框某某是一个IP地址，比如说1.2.3.4，假设是这样的，好，然后用户某某某然后在什么时间叉叉叉时间，然后访问了什么功能，比如说com点，然后q点点， community点 service什么方法，就是这样一个格式好。

那么你要想记录这样一个格式的日志，首先用户的IP怎么获取呢？其实用户的IP我们可以通过request获取，但是我们在这个方向里怎么去获取request对象，你可能能不能简单的说，我在这里说明一个request，对象不能这样做，我们可以利用一个工具类叫做request。Context。Holder。Request。Content它有一个静态方法叫get。Request h表示。那么这个方法我们可以把它转型成一个它的子类型得到的值可以返回转换一个子类型，这个子类型叫so累的request，h表示。

好，这需要强转，因为它返回的默认的类型叫request，我是把它转成子类型这样功能多一点。好，然后通过 h表示我们就可以得到request，对象点get request。那么它的类型就是HTTP12类，对case。好了，那么有了request以后，这个IP地址就能得到了，很容易得到IP等于request点。Get remote。Host好，这就可以了，但是除了IP以外，咱们还得拼这个时间，时间好办，我们就6个date，然后格式化一下就好了。我说明一个变量叫now，我需要把格式化的后的日期字符串复制给他，你有simple的format，然后指定格式，然后点format new，对。

好了，最后还有你要访问的是某个类，某个方法哪个类，哪个方法我怎么知道呢？

这就需要加一个参数了，其实除了环绕通知以外的通知也可以加连接点的参数，那么他们这个方法上加连接点的参数，这个名字就叫John point，那么连接点指代的是你程序植入的目标，组件你要调用的方法，它指代那个方法我们通过它就能得到我们要调的将要调的是哪个类哪个方法，怎么获取是这样的。

Join point点get signature，然后再点get Q带q然后 txt得到的是类名，我们还要拼上方法名，你可以这样加上一个点，再加上因为你中间不是拼了个点，对吧？再加上这个方法名，而方法名的获取方式也是类似的。是John point，点get是个nature，然后点get name这就是方法内容。这样的话我就得到了这个目标的类型名和方法名，我就要 target。

好了，那么准备好了这些条件以后就很好拼了，就log点，这个级别我叫infer，因为没有报错log点Info，然后的话这样我为了拼这个字符串，我用使用点放卖的方法去拼。首先我先写上一个字符串的格式，是用户某某用占位符代替，然后在占位符某时间访问了占位符某方法。

好，那么这三个占位符我需要用不同的变量去替代，第一个是IP，第二个是第三个是target，好，那么这就完成了，就这么简单，完成以后咱们再做一个测试，我把这个项目重新编译一下，然后它已经重启了，我清空一下，然后再打开浏览器，刷新一下首页，看控制台，看他有没有记日志，应该有用户某某某。

当然这个IP因为我那个页面上写的是logo house，所以说logo house它转成IP就是这个样子。如果你不喜欢这样看，你也可以这样，你可以把 Logo house改成127.0.0.1，这也可以飞车127.0.0.1它和logo house的是等价的。

再看你看用户 IP地址在某一个时间然后访问了，因为我们在查询帖子列表的时候也顺带查询了用户，访问了user service点，find idea对吧？

没有问题，这是针对首页其他的功能可不可以咱们也试一下，比如说我登录一下好，那么登录以后我访问这个消息，好，然后再看你看用户某某某，然后在用户某某在某时间访问了消息组建的 find later，everyday count方法，这是find use by ID这是find later count，这是find conversations。

看到了就是说我们在访问任何一个业务组件的方法的时候，那么通知这个方法都被触发了，我们就统一处理了问题，而这种方式又很简单。

好了，总之 AP怎么使用是非常容易掌握的，但是他的这个理念，它的实现一些机制，它的一些术语，一些概念不容易掌握。课后的话大家多花点时间把这个概念再好好再理一理，再好好再琢磨，然后代码你很容易就能学会。好。这节课我们就演示到这里，咱们下次课再见。