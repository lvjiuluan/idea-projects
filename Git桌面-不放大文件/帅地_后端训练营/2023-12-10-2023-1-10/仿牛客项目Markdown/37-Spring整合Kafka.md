37-Spring整合Kafka.mp4

这次课。

我们来学习如何使用spring整个卡夫卡，那么spring整个卡夫卡这个是比较方便的，尤其是在 spring布的框架的帮助之下，非常的容易，我们整合的时候第一步你得先引入依赖，我们需要去搜到包 spring卡夫卡。然后第二步我们需要对卡夫卡做一些必要的配置，这里主要是配卡夫卡的 server，因为你要让 spring知道我要访问哪个服务器，另外还需要对消费者做出配置两方面。

最后就是写代码了，写代码的时候，因为消息队列它是满足生产者与消费者模式，所以说我们写代码也是抓住这两点。

那么对于生产者他发布消息，我们主要是利用 spring给我们提供了一个整合好的类叫卡夫卡template，那么这个类它带了一个方法叫散的，然后的话有俩参数，一个是传入主题，第二个是传入你要发布的具体的数据消息就非常简单，对于消费者来说写代码的方式是这样，是通过一个注解来实现的，当然我们得把注解加到一个方法之上，这个注解是卡夫卡listener，就是一个卡夫卡的监听器，然后的话这里边你要写topics就主题，而且是复数多个主题，等于大括号里边写上一个或多个主题，表示说下面这个方法是要监听这些主题，什么意思？

就是说当我这个服务启动以后，那么 spring就会利用这个方法，它就会监听你配的主题，一旦它发现这个主题上有消息，那么它就会调这个方法去处理这个消息。

然后它会自动的把这个消息包装成一个 can summer record然后传进来，你就通过 record得到消息做你自己想做的处理，总之非常简单。

好，下面我就给大家演示一下整个整合的过程，然后我们写一个小的例子来看一下，整合以后它的效果。首先我们先来引入依赖包，我已经提前的把每本日抛c的到com打开了，我们搜一下spring，然后的话是卡不卡？

好，这个就是 Spring卡，sport你看这个包名叫sprig卡就他了，然后点一下，然后我选一个比较新的版本把拷过来，打开这个idea，把它粘贴到泡沫点xml里，我把它粘贴到最后的位置，但是其实我还是把这个版本去掉，因为负泡沫里已经声明了，它默认的版本，而且这个版本是它经过测试是没有问题的，万一我们选一个比它新的版本，万一产生兼容性问题对吧？

不太好，所以说我们就会把它删掉，然后就利用负泡沫中所声明的版本，它是什么就是什么就好了，就这样就可以了。

那么引入了依赖以后，第二步就是要对卡夫卡做配置，主要是在 application practice里去配，这儿其实我们是针对这个类进行配置，它那个类叫卡夫卡practice。好，这个类我就不看了，然后我就直接的写我应该配什么。

当然它的配置项很多，但是我们比较有必要的是要配如下几项内容，第一个是spring卡夫卡bootstrap service，首先是要配 server，我们的 server只有一个local house，929092它好，这是第一项配置，除了 Siri以外，我们还要配的是消费者 concern，你这样写我 copy一下 spring点卡夫卡，点肯萨姆，然后我们要配的是消费者的组分组的ID。

好，这个值其实是在肯萨姆的一个配置文件里有，咱们可以去看一下，然后打开d盘，然后 work卡不卡？

看所有的配置文件都在这里，那么很显然这就是消费者的配置文件。打开看一下，咱们上次都没有看，你看这里面它也配了，这个服务器是它默认的，然后的话这就是组ID，group点ID其实我们刚才 Group ID就配它，然后它的默认值是叫test consumer group。

这里我改了一下，我改成了community，当然你改不改都行，这里我改了，如果你要改的话，你要注意改完以后你要重启服务才有效，我就把粘贴过来它了。

然后再来对于肯萨姆还有其他的一些配置，那么肯萨姆然后点有一项配置叫尼泊凹凸，k米特是否自动提交？

那么这个参数的意思是是否自动提交消费者的偏移量，我们从斯布林布特的官方手册最后的附录里能够看到它的一个解释。

那么咱们上次不是讲了消费者在读取消息的时候，它是按偏移量来读取的，那么就是说偏移量它读完以后，你要不要把它记录下来，要不要做提交，是这个意思，好，我们是要自动提交的，然后通常我们还会再来一个参数，就是沙漠点。奥to commit英特尔。好，那么它的意思是自动提交的一个频率，你多久自动提交一次？这里我写3000，就3000毫秒三秒。

好了，那么配置这几项就可以了。配置完以后下面我们就一个写一段测试代码，然后我们来看一下怎么去用这个卡夫卡，那么我在这个测试包下新建一个测试类，这个类名我叫卡夫卡太子。

好，那么在类的前面我需要引入那么几个注解，我随便打开一个测试类，然后 Copy一下，然后我在测试的方法写一个测试方法，放大一点，方法名我就叫txt卡不卡？

我们测试无非就是我要测试用生产者发一个消息，然后看一下消费者能不能自动的收到这个消息，把它消费掉。

当然我们消费主要是把这个消息打印出来，看一下能不能收到就可以了，这里我们不涉及业务层面的问题，通常我们在写的时候会把生产者与消费者的代码进行一个各自的封装，我还是为了省事，我就不新建这个类了，不新建文件了，我就在当前的文件里写两个类，分别封装生产者与消费者的代码，那先写一个生产者克拉斯。

卡夫卡。

 producer。

好，那么这里我希望这个病由 spring容器来管理，我在这个病之前加上一个control。好，然后生产者刚才我们PPT上也说了，生产者发一个消息主要是依靠工具叫卡夫卡，他们累的那个工具是被spring整合了，它在容器里，所以我把它注入进来。

好，然后我再增加一个方法供外界调用，你调这个方法就是发消息，我送他一个方法，这个方法无需返回值方法名，我叫send message发消息。

那么发送消息的时候，首先你要传入消息的主题，另外你要指定那消息的内容。

好，那么你调这个方法的时候，我发消息就是我去调用他们类的去发就可以了，他不累的点散的，然后的话 topic，然后 content就完了，这是生产者这个病，那么接下来我再封装一个消费者病class，然后卡夫卡跟萨姆，好。那么消费者他不需要依赖这个template，因为它是被动的，它是自动的去处理这个消息，我们需要用到注解，卡夫卡为什么？

然后注解里主要是要写一个参数 topics，等于你要关注你要监听的那些个就是主题，比如说我一会要发的一个主题叫test，我要坚定的就是test主题，那么注解写完以后，一旦服务启动了，那么spring就会自动的去监听 test主题，或者说一他就是一个消费者的身份，他就是有一个县城阻塞在那，一直试图去读取 test主题下的消息，但是是阻塞的状态。

如果你没有消息就阻塞着，如果你有消息他立刻就读，就是这样的一个方式好。

然后如果说一旦有消息读到以后，他会交给他所生修饰的方法去处理，所以这里我需要加一个方法，这个方法是处理掉一个消息，这个方法名我叫憨豆，处理一个消息message，然后他调这个方法的时候会把消息加以封装，封装成 consumer record我们从 record里就能读到原始的消息。

好，我尝试读一下。很简单 Recode点get错了recode点，买点这就可以了。

好，现在我就把生产者与消费者这两个病封装好了，下面我们就在测试方法里去调一下，我希望这样，当我运行这个测试方法的时候，我就发一个消息，但是发完消息以后，我不希望这个程序就立刻结束，因为你立刻结束，我们就看不到消费者消费这个消息的过程了，对吧？不能立刻结束怎么办？

我可以把当前的主线程实例问一下，阻塞在这，等一会儿不用太长，等个几秒就够，在等的过程中消费者它就会自动的收到这个消息，就会调这个方法，触发这个方法去处理这个消息，我们就能看到这个输出，这样就可以。

总之生产者发消息是我们主动去调去发的，我希望什么时候发就什么时候调。

消费者他处理这个消息是被动的，一旦你的队列中有消息，它就自动处理，但是可能会略有一点点延迟，因为你队列里边有好独整息对吧？他排队处理到你可能会有一点点延迟，但延迟不会很多。

好，我这里就写了，首先我多发几个消息，但是我发消息我需要依赖这个病对吧？我把它注入到当前的 Test这个病当中，卡夫卡 producer，然后的话卡夫卡producer好我要发消息，那就 cup producer点send message。这个主题我就叫test，这个主题其实我们之前已经创建好了，然后随便写为一号，好像再来一个还是一个主题再来一个消息说在吗？

完了这就发完了，发完以后我说了这个程序我不希望它结束，我希望它阻塞一会儿等一会儿消费者他消费的过程，我就写一下spread点，sleep sleep1000×10，1000毫秒×10就10秒钟对吧？当然这句话你需要take action这样就行了。好，那么写完以后我来执行一下 Right？好。你看已经输出了，你好，在吗？说明消费者已经成功的消费了，这个消息已经得到了，但是程序还没结束，稍微等一会等到10秒才结束。因为我主色了10秒，好就比方说成功了，所以说你一定要体会得到消息队列它的这种感觉，生产者发消息是我们主动去调的，而消费者处理消息是被动自动去调的，一定要把这个搞清楚。

好了，那么这次课我们是不用整合，卡夫卡就演示到这里，咱们下次课再见。