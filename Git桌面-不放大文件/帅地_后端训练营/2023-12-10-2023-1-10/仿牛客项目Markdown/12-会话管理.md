12-会话管理.mp4

这次课我们来学习绘画管理，因为我们下一个功能要开发的是登录功能，那么在开发这个功能的时候，我们就必须要用到绘画管理的方面的内容，那么首先我们先了解一下什么叫绘画管理，这个得从HTTP说起，咱们之前看过 HTTP的手册，然后它有一个概述，概述中有一个小节讲的是HTTP的基本性质，我不知道你课后有没有自己看一下。

然后它里面就强调了说 HTTP是简单的可扩展的，并且它是无状态的，有绘画的，那么这段话其实讲的就是绘画管理方面的内容。当然了为了看得更详细一点，咱们可以打开这个手册再去看一下，我已经提前把这个手册打开了。

然后我们就看 HTTP概述的部分，看 HTTP的基本性质，那么它是简单的可扩展的很容易懂，我就不详细的介绍了，大家自己看，我们主要看的是这一段，它是无状态的，有绘画的，首先你要理解什么叫无状态，他解释了说在同一个连接当中，其实指的就是同一个浏览器，访问同一个服务器，他们产生了连接，他们连接上以后可以发送多次请求，那么多次请求之间没有任何的关系，就是说从服务器的角度来说，即便是你同一个浏览器向我发多个请求，那么我也把你当做一个陌生人陌生人来对待，我也不认为这些请求之间有什么联系，说白了我通过这个请求我不认识你，即便是你是来源于同一个地方，所以说这就带来了一个问题，因为我们平时上网很多网站它需要有持续性的交互，你比如说他这里给他举了一个例子，说我们访问电商网站，那么我可能是打开一个网页看鼠标把它加入到购物车，我又打开一个网页加了个键盘，加入购物车，我们知道我们最终去结算的时候应该是看到键盘和鼠标对吧？

但是默认情况下还实现不了默认的请求，服务器认为这两次请求没有什么关系，其实它不会把键盘和鼠标组合在一起成为一个订单。

同理浏览器因为服务器记不住，浏览器也做不到这一点，好，这就是问题。所以说这种状况就叫HTTP是无状态的，就是说同一个浏览器访问，同一个服务器多次请求之间彼此是独立的，没有关联的，或者说服务器它无法记住浏览器的状态，它不能识别你是谁，这种情况说它是无状态的，但是我们要想解决业务连续性的问题怎么办？有办法用的就是用cookies可以解决这个问题。

好了，所以最终有一个结论就是HTTP它本质上是无状态的，多次请求之间是彼此割裂的，没有什么联系的。如果你想让多个请求之间有一个联系，让这个业务成为一个整体，能够整合到一起，能够得以连续怎么办？我们用的是cookies可以解决问题，我们用库克斯解决这种业务连续性的问题，这就叫会话，就是说我们两两者之间浏览器服务器之间进行对话，那么是连贯的，不是割裂的这个意思。

好了，那么关于 Cookies，其实这个手册里也有相关的介绍，咱们后退一步，再后退一步，你看这就HTTP cookie它很快就介绍了这个内容，我们也可以顺便看一下什么是HTTP cooking？

其实刚才说的本质的问题是服务器它不能识别浏览器它记不住，你想办法让它记住，其实这个业务就可以连续了。

所以库克就是这样一项技术，就是想办法让服务器能够识别浏览器能够记住浏览器，就大概是这么个意思。

所以详细解释是 cookie它是服务器发送到浏览器，并且保存在浏览器本地的一小块数据，就酷k数据是由服务器创建发起的，它会发给浏览器，然后浏览器会存到本地。

然后还有一个特点就是浏览器下次再访问服务器时，它会自动的携带这个数据给服务器，然后给服务器看一下，就好像这是一个令牌一样，就是我浏览器第一次访问服务器，服务器给你发了一个令牌，发了一个卡片，你拿走了，然后你下次再来出示卡片，ok我就能识别你是我的会员，你是我的这个客户，没有问题可以继续，大概就是这么个意思。

好了，然后关于cookie，我们读这段文字可能还是有点这个不够直观，所以我给大家画一个简单的图，然后通过这个图你可能会更直观的能够体会到 cookie到底是怎么回事。

好画个图，首先我画个方块，假设这个方块就代表了我们所使用的浏览器，我再画个方块，假设它就是服务器，那么如果想让浏览器想让服务器记住浏览器，那么是这样去做的，就是浏览器在访问服务器的时候，那么服务器它可以创建一个对象，这个对象就是cookie对象，然后并且将 cookie对象在响应时发送给浏览器。

当然库配对象中可以携带一些数据，一会我们通过例子你可以看出来，然后酷配对象是比较特别的，它在传输的过程中表面上我们看不到，因为它是默认是在请求的头里有一个参数，浏览器得到以后，他知道这是一个特殊的数据，我需要存下来，所以说浏览器就会保存这个数据在它本地，并且当浏览器再次访问这个服务器的时候，他会很自觉的在刚才说错了，这个是响应的头，当他再次访问服务器的时候，他会来请求透底把 cookie再带回给服务器，然后服务器又收到 cookie了，就得到了用户的信息，通过这种方式他就记住一个用户了，这就是库克的一个工作原理。

所以的关键是库克是一个特殊的数据，浏览器在得到它以后会自动保存，下次请求是自动传送这么一个流程。

好了，那么大家了解完以后，接下来咱们就写这个小例子来看一下，来体会一下它的语法，然后我们通过浏览器的插件也能够看到这个过程，看完以后可能你就会这个体会会更深刻一点点。

好。下面我就打开了我的开发工具，然后咱们这是一个简单的小例子，不去处理什么任何的业务，所以我这个代码还是写到阿尔法CTRL里，这里专门演示一些小demo，然后我在后面追加一些内容，流行注释。

下面我要演示的是qk相关的事例，首先我想做模拟这个请求，就是浏览器访问服务器，第一次请求的时候，那么服务器要创建一个库，可以把它发送给浏览器，把这一步实现了，然后再写一个方法把搞定了，浏览器在访问服务器它怎么去带？

 Quick，咱们先来把请求的逻辑搞定，我们写的是服务端代码，所以我需要在 Ctrl加一个方法能够接收浏览器的请求，我就先声明请求的路径， pass等于 cookie，然后 set，因为我这个方法是要产生一个cookie，好，然后请求方式get请求就可以，这样比较简单，然后这个方法最终的响应咱们就简单处理，我就返回一个那个Jason字符串就完了，我就不去返回页面了。

所以我写上瑞斯邦斯包点。

当然你返回的是字符串，不是返回页面，这个和cookie没有关系，因为你不管是给浏览器返回什么，你最终都是要向浏览器作出响应，都是要通过response去做响应，而酷k在响应的时候，它是存到了response的头部，对吧？

所以说跟你返回的具体的内容其实没有什么关系。好，我就写上他的x卷，然后这个方法名叫site cookie，好，然后我们这里可以创建cookie，创建完cookie以后，你要把 Cookie存到risk boss里，那么在响应的时候才能够自动的携带给浏览器，所以这里面我们需要用到 response对象，这里我就声明一下，HTTP super late response。

首先我要一个创建图片，这个很容易，尤其声明一个酷配对象给它取个名字，然后去遛，这个对象在使用的时候它必须传入参数，它没有无参构造器，而且这个参数必须都是字符串，并且每一个qk对象只能存一个字符串，一一组字符串一个q一对q白流是这样的，我这里随便存了，比如说我要给浏览器发送一个编码扣的，假设这个编号我是自动生成的，随机的，我可以调 community YouTube对吧？

点January的uid好了， cookie对象就创建好了，创建好以后，我们通常还要对它做一些设置，我们可能经常会要设置它的生效的范围，什么叫生效的范围？

看那个图，那么浏览器保存库克以后再访问服务器的时候，它不是会把酷片发自动的发给服务器， cookie你需要指定我访问哪些路径我才会发，如果你不指定的话，他可能所有的路径都发，可能就会有问题，这个范围就太大了，对吧？

因为你每次都发 cookie，那么如果说服务器有些请求他不需要，其实一些浪费了一些网络的资源，所以我们要明确声明 cookie在哪些路径下有效，那不需要它的路径就让它无效，好回来怎么设置有效的范围也很容易 cooking，然后点set pass，声明它在哪些路径下有效，我可以这样写。

肯定的，那就意思说是在我整个项目下都有效，当然你也可以写这些下划线，比如阿尔法项有效，也可以这样我写个二，所以库克亚只有在这个路径和它的子路径下才有效，那么你仿别的路径就无效，这样明确它的范围。

还有那么浏览器得到酷k以后它是会存的，它默认是存到了它的内存里，那么当我把浏览器关掉以后， cookie就没了，当我再打开浏览器它就没有了，所以他在访问服务器就不会带 cookie。

那么如果说你想让它存的时间久一点，哪怕我浏览器关了，我第二天打开再访问服务器，这个顾客还在这还能够传给这个服务器也可以，这个时候你就要设置cookie的生效时间生存时间。

好，我再总结一下就是cookie默认发给浏览器，它存到内存里关掉就消失，但是你一旦给酷k设置了生存时间以后，它会存在硬盘里，然后长期有效，直到超过这个时间以后才会无效。好，这写故事就设置cookie的生存时间，也就是site cook，点site， max edge最大的有效的时间单位是秒，这里比如说我写的是60×10，对吧？1分钟60秒，那显然就是10分钟。

好了，那么其实我们平时对扣费的设置主要就是两项，基本上这两项是必须要设置的，然后就要发送cookie了，我就把 cookie放到risk boss的头里就行了。怎么放 Site？ Response点不是site，是艾特 cooking。好，把cookie对象添加到response里，那么最终像浏览器响应的时候就会带过去。好了，我就处理完以后我就 Return一个结果让它响应给浏览器，这里随便写我就写sat，cooking这个结果不是我们的重点。

好这就写完了，写完以后咱们可以进行测试，这就可以测了，我就启动一下这个服务器，好，启动完以后我告诉你怎么测，需要依赖于浏览器的插件，咱们得看那个插件，然后能看这个cook在没在，那我就打开浏览器，新打开一个页签，我去访问刚才的功能 community，Alpha cookie said好，我先不用着急回车确认一下，对是这个路径，然后提前点检查，右键检查把 net work打开，然后我一发请求的时候，下面不能够看到请求的过程，我们在请求的过程里就能够看到 cookie它有没有？

好我就回去了，回去以后看 site请求点进去。

好，刚才我们话都说了，说这个请求是我们服务器创建的库被发给了浏览器，响应时它在响应的头里对吧？所以我们得看response，而不是request，你看 response，response harders它有一个属性叫sat cookie，这里边有一个code等于一个随机的字符串，我们产生的那个东西。然后 max600秒，然后最终他通过这个时间计算出了超时的准确的日期，时分秒就是有效路径。是对吧？就是我们设的这些东西好，说明我们 cook就ok了可以了。

可以以后我们接下来还得做一个测试，就是说浏览器在访问服务器的时候，它会自动的把这个数据发回来，我们把测一下，我再写一个方法，我写之前成这样，我直接访问另外的一个方法，不是阿尔法之下的，再写个页签，比如就访问 index，然后我们看一下 net work好回车，看第一个index这个请求，然后我们看一看 request，heads里有没有cookie，为什么没有？

因为我们刚才响应的 QQ的有效路径是阿尔法，我们访问首页跟这个路径不匹配，所以对首页的路径就无效。

下面我写一个能有效的，这个也很简单，我就在这个地方再加一个方法，让浏览器访问，那么这个方法我还是这样复制一下我上面这个方法的访问路径是get吧，它位于阿尔法之下，夏季路径就有效，然后也是盖的请求，那么这个方法他那个时间我管他叫get cooking好，然后这个方法我就直接return，随便说听个啥听get。

Ok，完了好，那么我重新编译 CTRL f9一下，好它自动重启了服务器，然后我打开这个浏览器，我去访问 get这个结果没有问题，我们主要是看请求中携带的数据有没有看 request，你看酷片不就有了吗？对吧？当然有了库克我怎么用呢？这个库克怎么用？可能我们会在服务器里用，我这次请求你不是把库克传给我了吗？

我收到以后我可能在服务端区里面只是用一下，或者是服务器不用我我在那个模板上要用，我可以，反正在服务器得到以后把它给模板也可以，我们在这怎么去获取 Cookie非常简单，因为cookie是返回来的时候是在request里，所以这里如果你声明request对象，然后点get cookie就能得到所有的cookie，然后但是那样比较麻烦，因为你得到的是一个qk宿主，还得遍历从中去找，有点麻烦，如果说我就想要众多酷k中的某一个k所对应的酷k怎么办？

我们用一个注解可以实现在这注解了叫 cookie y6，然后你把 k写上去，咱们刚才存的时候 k不是扣的，对吧？K写上去，然后写上一个参数，意思是说就这个参数，你要从酷k中取 t为code的值付给他就行了。

然后这里面我就把参数的打印一下，看看能不能得到这个值，所以你得到了以后在这里就可以用，如果说你不想在这用，你想给模板用，那你就把扣的加到model里带给模板也是可以的，对吧？

好，那么我们在 CTRL f九编译一下，这样我就让他不要再提示这个提示了，自动的去处理就好，处理完以后我就在打开浏览器再刷新一下，回到服务器我们看一下，你看控制台我们扣的值就有了，就是这样。

好了，那么 cook就是这么用，非常简单，当然我们这次课主要是演示它的使用的语法，那么我们后面接下来要开发的功能登录，那么处理具体的业务逻辑的时候，到底在业务中怎么用，那就后面的功能在演示，那么了解了这个事例以后，我们通过插件也看到了它玩法以后，你回过头来再去体会它的意思，说cookie它是服务器发送到浏览器，并保存在浏览器端的一小块数据，因为一个QQ就能存一个q56，它就存很少的数据，那么浏览器下次访问服务器时会自动携带这块数据，将它发送给服务器。

好，这就是cookie的作用，最终的结论就是服务器通过这样的手段，它能够识别浏览器，或者说它能够得到浏览器相关的一些数据特征，数据好了，那么 cookie有它的好处是显而易见的，就是它能弥补 HTTP无状态的这种情况，能够让业务得以延续，而且在使用的时候它很简单，对吧？很方便能解决问题。

但是其实它的缺点也比较明显，什么缺点呢？就是cookie这个数据是存到浏览器上的，存到客户端的，那么存到客户端的数据可不是很安全的，因为客户端是谁你不知道客户端它的系统的安全程度也远远不如服务器，它也容易被盗，对吧？

因此鉴于它的不安全性，你这个库可以不能存很敏感的隐私的东西，比如说密码，你就不应该存到这里来，否则就很容易被盗，这是第一个它不太安全。

第二个 cookie会在很多请求当中，他都会主动的把数据发给服务器，他每次都发这个数据，每次就会访问服务器，就会增加数据量，所以说也会对流量对性能产生一定的影响，这是酷k的一个缺点。

那么其实还有一种办法也能解决问题，思路是类似的。

那么另外的一个解决问题的办法就是session，这个session是服务端对象，但它不是HTTP的协议的标准，所以你在 HTTP里面找不到具体的声明，它是Java ee的标准，那么你去奥瑞克的官网去查 Java ee的手册，它里面是有关于相关的 API的介绍，我们课上就不去细看了，然后它是用于在服务端记录客户端的信息，那和酷k刚好相反，酷k是在客户端记录，然后因为你数据是存到了服务端，所以说它就更安全，但是它也有缺点，就是你把数据都存到服务端，都存到内存里，服务端的内存压力就很大，因为你想一个网站的用户访问量是很大的，对吧？

你谁来访问都产生一个cookie对吧？

所以说内存压力比较大。

总体来说就是说如果说你这个数据特别隐私，你不能用cookie来存，你就可以考虑用session对吧？如果说不是那么隐私，其实一般的数据你用QQ可以服务器压力不就小了，所以说得看情况来使用它们要注意。

那么接下来我给大家演示一下，筛选它是怎么来玩的，对，在演示之前我还是再画个图，把这个筛选它的工作流程先说一下，说明白以后我们再演示。再一个。

其实30年使用的时候，它跟cookie还有一些联系，它其实本质上它是依赖于cookie的，所以这一点你要整明白，我们一会在演示案例的时候你才能看，看得出来这怎么有产生一个新的东西和QQ有关。先讲明白，然后再演示好。

我再画一个图，我首先再画一个方块，还是代表浏览器，然后再画一个方块代表服务器，还是解决的是它们之间发请求通信的时候，服务器能够记住他的问题，那么比如说第一次请求浏览器访问服务器，那服务器就会创建的不是 cook对象，而是一个session，对象服务器可以创建一个session对象。

好，然后筛选对象就存在服务器端，它不会把整个筛选对象发给浏览器，但是你注意，那么浏览器和服务器可是多对一的关系，很多浏览器都能访问同一个服务器，每个浏览器访问服务器都会产生一个筛选对吧？

当你下载浏览器，浏览器访问完以后产生了一个筛选，但他下次再访问的时候，那服务器怎么知道你浏览器和筛选对应，它和另外一个赛程对应，就浏览器和赛程之间对应关系怎么找，那这个就得依赖于cookie了。

总之服务器创建的session，用session存了当前浏览器或者说当前用户的相关的数据，包括什么ID密码姓名都存了，怎么让这个赛事和这个问题有个对应，他是这么做的，在响应的时候，那么服务器自动的像浏览器发送了一份数据，这份数据是通过cookie携带的，或者说服务器的底层自动建立一个cookie，然后在cookie中出了一个 session的ID，就是对象的ID， Session的ID是对象的唯一标识，那么每个浏览器来了创建一个新的session，这个session有唯一的标识，然后他把 v的标识从cookie发送给浏览器，那么cookie的特征刚才我们讲过了，浏览器它就会存这个对象在它本地那本地里就有了30ID，那么当它下次访问服务器的时候，库位的特点就是它会自动发送给服务器自动发回来，所以下次请求的时候发回来的就是他之前存的 cookie里边就是这个赛事ID，那服务器会得到这个赛事ID得到以后他利用这个赛事ID在他的内存里一找不就找到了，与浏览器对应的筛选，就能够找到与浏览器对应的数据了，就是这么一个原理，也是很简单很好理解的。

总之 session它就依赖于cookie，但是它的数据存到了服务器端，对服务器会产生一定的压力，但是更安全。

好了，那么了解了三审的就是工作的状况，或者说流程以后，下面我们再写一个小例子来演示一下 session的使用，这个session其实它的使用是比较简单的，我在这个cookie示例的后面接着写筛选的示例，还是我说明一个方法来模拟这次请求，那么我们创建筛选往里存点数据，好，这个请求我copy一下 pass，我叫session，site这次请求我们是要往里存数据，然后响应也是一个简单的字符串，加上了response包点，然后我写上他的死病 sat筛选，好，那么在这个服务器端创建session，其实他不用我们手动创建他和酷k不一样，服务器或者说是不是mvc可以自动的帮我们创建筛选并且注入进来。所以筛选的使用和request，response和model这样的对象的用法是一样，你只要声明，那么spleen mvc就会给你注入进来，所以我声明就好了， cookie对象的类型是HTTP session。

然后筛选因为是一直存在于服务端的，所以它里面存什么数据都行，它一直在服务端保存着。 Cookie为什么就只能存字符串，而且只能存少量的数据呢？因为库克的特点是它来回传，你要存大量数据的话不太影响性能了。

再一个你要把这个数据传给客户端，那客户端你其他的Java类型它也不能识别字符串它是可以识别的，所以鉴于它这种特点，它只能存字符串只能存少量数据，而session可以存任何类型的数据，然后的话也可以存很多的数据，好了，我就随便往里存点啥， session点site attribute也是key value，比如说我要出现一个ID，假设是一筛选点，sat比如我再存一个name，假设叫test，好我就往筛选里存了两条数据，最终我向量感器响应一个字符串，3筛选。

好，写完以后咱们就测一下我CTRL f9，那么打开浏览器我来访问一下，这个请求也是要看这个插件， session set响应的没问题对吧？很简单，我们看这个请求，然后我之前说了赛程的特点是在响应的时候，它会通过cookie去传一个session的ID给浏览器存，好，你看有没有响应的时候，side cooking，然后 jssid jssid就是sisid然后它的pass默认就是整个项目下都有效，就这样一个状态。

然后没有 max age的声明，没有最大生存时间的声明表示出什么呢？这个数据存到了内存里，但我浏览器关了它就没有了，这样的。

好了，那么我们再来看我浏览器下次再访问的时候，会自动的传回筛选ID，从而能够自动找到筛选得到这里面的数据，那么把这个请求也进行一个演示，我就在刚才的事例的后面再写一个事例，我就copy一下，那么这个路径我就get然后叫get section。

好，这个方法里我主要的目的是要从筛选中取值，这个再生也是通过思博mvc注入，你也不用自己去声明，你就从中取值，我直接把渠道的值输出了，筛选点儿，存值是site取值就是 get attitude，然后我们存的是ID和name，所以我先把 ID打印出来，然后再把 name叔叔看一下，最后再随便的返回一个字符串。

Get session。

好，写完以后在CTRL f九重新编译，然后我再打开浏览器访问一下， get看一下这个部件这回看什么，看的是请求当中有没有 sisid请求当中，你看有一个cookie对吧？接sisid有的我们看控制台，我们从赛程中尝试打印的数据有没有？应该也有e test。

好，所以塞申也能够解决同样的问题，只不过它是用另外的一个角度来解决的。然后的话优点就是数据存在服务端安全，缺点就是服务器都会有一些内存上面的压力。好了，那么再总结一下，说我们要想让这个业务连续要想记录浏览器的状态，我们到底是有使用cookie还是筛选，这得看具体情况而定。那么总体来说咱们能用cookie就尽量用cookie减小服务端的压力。再一个如果是没有必要存就是这样去存的，你就不要用有必要的再去存。

然后 Session的话其实如果是一个单体的应用，就只有一个服务器，我们将来只部署一台服务器的应用，你随便用，筛选没有问题，但是现在因为每个网站都比较大，用户数都比较多，其实筛选逐渐越来越越少了，那么这个是和部署有关的，和分布式部署有关的。

我给大家再解释一下，为什么在分布式部署下赛程用的少了，出现的问题是什么？我们在实际的应用中我们怎么去解决这个的话，你一定要多了解，可能是面试的时候很容易会容易问你，因为你把你的开发的功能一解释，说你是用这样的方式去处理这样状态数据的，面试官肯定会问你这方面的话题你为什么不用三审对吧？所以这块你一定要注意。

这里我也画个图给你解释一下，就是说首先我们分布式部署的时候，为什么使用三神会有问题，会有什么问题？好，那么首先还是画一个框，它代表的是浏览器，然后我再画一个小的框，代表的是服务器，然后咱们这个服务器往往是分布式部署，所谓分布式部署就是我部署多台服务器同时跑这个应用，同时向浏览器提供支持，因为浏览器的请求实在是太多了，用户太多了，如果你一台服务器撑不了这些流量就多台服务器，分布式部署分别是123我们一共有三台服务器，三台服务器浏览器访问谁？

其实对于浏览器来说这个服务器分布式集群它是透明的，因为我们会在这个服务器之前再加一个代理，或者加一个负载均衡的服务器，通常我们会用NDS后面的课我们也会介绍，然后你浏览器访问的不是这些服务器，而是访问这个统一的代理Ajax，当然这个Ajax它也未必就是一台，它也可以是做组成备份，我们就不说它的群的情况了。

好，那么当浏览器发出请求访问这个服务器访问 Nds的时候，那么它会做负载均衡，它会去分发请求分发给哪个服务器，这得看策略，比如说我们是按照比较均衡的策略，就哪个比较闲我就分发给哪个。

假设这次请求是服务器一比较闲，那么恩杰斯就把请求发给服务器一去处理，这个时候服务器一要处理这个请求，它就可以，比如请求需要后面需要业务连续，它可能会创建一个筛选，服务器一就会创建一个筛选，然后当然了会返回筛选ID给浏览器，它会存了。

那么当浏览器第二次再去访问这个服务器的时候，它又发一个请求给ndx携带了一个section ID但这回 n这个是因为它是负载均衡，可能这个时候服务器一处理的业务比较多，而服务器三比较空闲，他可能就会发给这个服务器三去处理这个请求，你就问题就出现了，那服务器三当然也可以创建session，当然也可以识别三神，他一看你给我传了一个三神ID，但是我本地没有，因为这是这个服务器，三里没有存筛选，对吧？

他没有他只能发现一个新的筛选。因此你看我第二次请求，我想得到三分钟数据就得不到了，分布式部署就是这样的问题。

好这个问题怎么解决？其实有多种解决方案，一种方案就是我们去设置负载均衡它的分配的策略，一种方式叫粘性三审，就是说比如浏览器的IP是假设是101，我把101这个IP分给服务器一去处理，当你下次这个IP来了，我还得分给服务器一处理，就是说你只要是一个固定的IP，我就永远分给同一个服务器处理，这样的话 Session没他就能得就能够得到上次的 session，因为每次都是同一个夫妻处理请求，这种方案叫粘性筛选，但这种方式显然有问题，就是你同一个IP分给同一个固定的服务器，那就很难保证这些服务器之间是负载是均衡的，对吧？

因为你不是平均分的。

好，所以说这种方式有它的问题，就负载并不均衡，性能并没有那么好，所以说这是第一个粘性筛选不完美。

第二个解决方案是同步筛选，当某一个服务器它创建筛选并且存在数据以后，那么它会把筛选同步给其他的服务器，其他的服务器，那么这样的话所有的服务器这个session就统一了，浏览器无论访问是哪个服务器，这个服务器串联出来的session以后都会同步给别人，每个服务器里都存了你浏览器的一份三星数据，这样也可以，但这样的话也有问题，首先你得做同步，你一台服务器处理完以后得同步给很多台，这个会对服务器的性能产生影响。

第二个这样做的话，这个服务器和服务器之间就会产生的关联，它们之间就会产生一些耦合，而不是那么的独立了，对部署的部署的话比较有影响，所以这种方式也不太理想。这是第二种方式，叫同步筛选也不是很好。

然后第三种方案叫共享筛选，什么叫共享？开始就是说我可以单独搞一台服务器，这台服务器不是处理你普通的业务的，它是专门用来存筛选的，就是说如果说浏览器访问服务器，那么需要创建赛程，需要获得赛程的时候，我们就把这个筛选统一交给放到这个服务器里处理，然后别的服务器都像这台服务器去获取筛选，他们都像这台服务器去申请筛选，是这么一个关系。

他专门处理筛选好，这种方式似乎能很好地解决问题，但是它也有一些隐患，是什么？这台服务器因为它是单体的一台服务器，万一说这台服务器挂了就糟了，这些服务器都依赖于它挂了，这些服务器都没法工作了。

所以我们当初之所以要分布式部署，是为了解决性能的瓶颈，你现在的话又搞出一个单体的服务器解决一项问题，万一他挂了他也是瓶颈，对吧？也会有很大的影响。

所以说这种方案也不太好，但如果说你要是搞个集群的话，那和我们直接这三台服务器各存一个筛选也没什么区别，它俩之间又得共享，还是有问题，好，所以这种方案也不好，共享财产。

那么其实目前比较主流的办法是这样的，我把塞我把客户端的身份的数据我就不存到筛选里去了，我能存到库克里就存库克里，有些敏感数据不方便存到库克里怎么办？我就存到数据库里。

好，那么数据库你可以做一个集群组成备份都没关系，他们之间的这个集群它是性能是ok的，他们之间同步数据没有问题，数据集群这个方案是很成熟的，那么所有的服务器都可以访问数据库的集群来得到就是关于客户端的会话的数据，这样就可以了。

当然这种方式也有它的缺点就是说因为传统的关系型数据库它是把数据存到硬盘里，我们像数据库的硬盘去访问数据，显然是从内存中和和从内存中读数据比它是性能更慢的，对吧？这个可能是在并发量大的时候也可能会出现一些瓶颈。

所以这是它的问题，尽管说它能够很好的共享数据，很好的同步数据，但是它性能可能没有存到内存里好，但是你要知道现在数据库可不只是关系型数据库，现在的话 no circle数据库的技术也是非常的发达了，非常的成熟了，也很好用，那么我们可以把绘画的数据不存到观音数据库里，我们可以存到no circle数据库里，比如说readiness，所以说最终我们把这样的数据存到reds里，这是一个比较推荐的解决方案，也是一个比较方便比较好用的解决方案。

所以我们的项目当中最终会是用这样的方式，但是由于我们一开始现在还没有去学 radius，所以现在我们还不能把会话数据存到这里来，怎么办？对于有些数据它适合存到my circle里，就存在my circle里边，有些数据不太适合存到my circle里，我就先存到section里，因为我们现在是单体应用存到section里，反正也能玩转。

等我们学完了 rids以后，我会对代码做一个重构，把这个存到my circle里的这样的数据，或者是存到 session中的数据再迁移到rides里就ok了，这是我们后面的话关于 section方面我们使用的一个小的安排。好了，那么这次课我们把绘画的管理介绍到这儿，咱们下次论坛再见。