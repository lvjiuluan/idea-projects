21-事务管理.mp4

这节课我们来学习事务管理，因为我们下一个要开发的功能是添加评论，那么在这个功能里面我们要用到事务管理的这方面的内容，所以我们提前先介绍一下，那么关于事务管理这个话题，我想大家应该并不陌生，因为你在学数据库的时候肯定会学到这方面的内容，但是为了避免有些同学就对这个内容有点生疏了遗忘了，所以我们先对这个内容进行一个回顾，首先说什么是事物，事物就是指由一步或多步把数据库操作序列组成的逻辑执行单元，这一系列操作要么全执行，要么？

全部放弃，全都不执行。什么意思？就是说我们在执行数据库的操作的时候，其实是以某一个业务为单元的，那么一项业务可能是要访问数据库多次，那么我们要保证这项业务的完整性，如果说你这项业务所涉及的数据库操作全都成功了，你就提交都成功。如果中途有一个失败的报错了，你要全都回滚全都放弃，我们是以业务为单元去让数据库执行是是否有效做这样一个判定。

那么从学术的角度来说，事物它包含几个特性，就4个特性，原子性、一致性、隔离性和持久性。其中其实原子性和一致性他们阐述的内容差不多就是说事物是一个整体，是一个不可再分的最小的整体执行体，而且事物执行的结果需要让数据从一个一致性状态变为另外的一个一致性状态。

那么所谓的一致性状态就是说，你这个数据需要满足数据库相关的约束，是唯一性约束还是非空约束等等满足，你在没有改变之前满足改变之后依然满足，这叫一致性。另外还有持久性指的是数据事物一旦提交了，那么你对数据所做的任何改变要永久的记录下来，你要存到像硬盘这样的永久的存储器当中，而不是存到内存里。

然后隔离性指的是针对并发的操作在并发的时候，那么独者程每个线程都执行一个事物，那么他们之间其实应该不互相干扰，应该彼此隔离，否则就会出问题。

指的是对并发的一些处理的方案。总而言之事物的这4个特性，原子性、一致性、持久性是比较容易理解的，那么我们就对他们就不多说了，但这个合理性是很值得我们去探讨的。

那么你面试的时候，面试官其实也比较关注这个话题，他很值得去聊，所以我们对隔离性就多做一些介绍，下面我们就看一下隔离性，刚才也说了，事物的隔离性是针对病房而言的，那么我们换一个角度，就是说如果在多线程的环境下，我没有去做事物的隔离会怎么样？

当然我再强调一下，就是我们所开发的服务器程序，它是一个多线程的环境，每一个浏览器在访问服务器的时候，服务器就会创建一个线程去处理它的请求，然后如果说在这次请求当中你要访问数据库，那么就可能会产生一个事物的操作。

所以说其实我们开发的服务器程序，它是独者程环境，是多事物并发的一个场景，那就很有可能说我多个用户同时访问你网站的同一个功能，可能会同时去访问同一条数据，也就是说多个事物同时访问同一份数据的情况就会出现。那么如果你不去做隔离性的处理，就可能会出现一些问题，因为你同时改对吧？以谁为准这个就会出问题。

那么常见的并发的这种问题主要是两大类，一类更新的问题，一类是读的问题。那么第一类问题就是更新，关于更新有两种，一种叫第一类丢失更新，一种叫第二类丢失更新。关于读的错误，一种叫脏读，一种叫不可重复读，一种叫换读。那么这5种常见的异常错误我一会会详细的讲解，反正我们先有个印象，那么我们所谓的事物的隔离性其实就是为了解决这些问题，然后在解决问题的时候，它是分层级去解决的，什么叫分层级去解决？

就是说它分为几个级别解决的程度不同，你比如说read on committee，它是一个最低的级别，然后希尔莱斯堡是一个最高的级别，由低到高，其实这个级别它能解决所有的问题，你可能就会要产生疑问了，既然它能解决所有的问题，还要其他的三个级别干啥是这样的，它能够解决所有的问题不假，但是它解决的问题是有代价的，它需要对数据枷锁，而枷锁会降低数据库处理的性能，会降低数据库的性能，使得性能下降得很快，但我们网站又希望提高性那就矛盾了，所以它又提供了其他的三个级别，那么我们实际上在开发的时候，我们应该选一个一般都不会选这个级别，因为它性能太低了，我们会选中间的一些级别。

那么以什么为准？就第一个它既能满足我业务的需要，保证我业务的安全性，当然不是百%的保证，比如说百分之九十几的保证，但是很多时候就能被接受，在这个前提下我们追求一个更高的性能，大概是这么一个路子。

当然了，你说我到底怎么选呢？如果你想知道我到底应该怎么选，你肯定要先知道这些个异常代表什么意思，然后每一种级别能够解决什么问题是吧？然后你再遇到一个需求的时候，他去分析哪个是我能接受的，它性能就是在我们接受的范围内是最高的，是吧？大概是这么个意思。

所以接下来我给大家介绍一下这些常见的并发的异常分别代表什么含义，这4个级别都能解决哪些问题。好，下面我们就来看这个常见的并发异常这个话题，首先我们看第一类丢失更新的问题，我对它做了一个概括，什么叫第一类丢失更新？它指的是某一个事物的回滚，将导致另外一个事物已更新的数据丢失了，这个叫第一类丢失更新。

然后右侧我给一个表格，对整个的过程做了一个推演，我以两个事物为例，一个简单的数据为例，对这件事做一个推演，后面的其他的问题也是类似于这样的方式去推。

然后第一列是时刻 T一时刻t二时刻，这个时间向前推移，但是你要有这样一个意识，t1:到t6:，总的时间间隔也会非常的短，因为计算机的执行的速度非常的快，可能整个t一到t6:也不过一毫秒甚至更短的一个时间就完成了。

但是我把它区分的仔细一点， t一到t6:，比如说在第一个时刻事物一抢到了 CPU的时钟，它先读取了一个数据，假设读的字段是n读到的是10，在t2:事物二抢到了这个时钟，它去读也读这个数据，读到的数据也是10，也就是说几乎他们同时去读这个数据，几乎同时得到的都是10，因为t1和t2间隔是非常小的，然后在t三时刻十五二首优先对这个数据做了改变，把它改成了9，比如说它减了一个值，减了1改成了9，然后在下一个时刻他提交了对于 t二这个流程没有问题，这就是把数量减一，最终提交了他也是成功的ok的。

然后紧接着在t5:，十五一抢到了十中，然后他也去改这个数据改成了11，它是一个加的操作，但是改完以后，后面某些程序发生了异常，于是 t6:他回滚了，那回滚以后他原来读到的值不是10吗？所以他一回滚就回滚成了10，那么你看我们单独看事物一这个流程没问题对吧？一开始读到10改成11，然后回滚成10没问题，看事物二也没有问题，一开始10减成减1×9，commit为9也没问题。

但是你要知道，那么这t1到t60个时间间隔极短，他们几乎同时做了这样的操作，然后得到的结果响应给浏览器而响应的时间，因为有网络的延迟，需要一秒钟，所以说网络延迟大远远大于事物执行的时机，所以就在两用户看来，这两个行为几乎同时发生的。

那么这就出现了问题，对于第一个用户来说他觉得没问题，因为我原来读的这个数是10，然后我尝试把它加一失败了还是10没有问题对吧？而对于用户二他就不能接受了，因为他得到的数据是10，他尝试去修改也没有报错改成功了，但是最终的结果是什么？

最终结果还是10他的9没有体现，所以你在去看一下我总结的这句话，就是某一个事物的回滚，它的回滚导致另外一个事物已经更新的数据没了，你回滚是你回滚，但是你把人家的数据给整没了，这就是第一类丢失更新的问题。如果你不去做事物的隔离，就会有这样的问题。

好了，那么这一类问题了解完以后，那么后面的问题就都好理解了，因为都是这种形式去给你讲解。

我们再看第二类丢失更新，这个其实刚才类似只不过他是这样解释的，是某一个事物的提交，导致另外一个事务一更新的数据丢失了，刚才是回滚，这个是提交而已，还是像刚才的场景事务一先读读到10，然后是万，这三三步操作读成10-1为9，提交以后，然后在t5: 15 1+1成功了。

T60个他没报错，他提交了11没问题，但是响应到浏览器的时候，那么用户一用户二用户一能接受，反正我原来10加了11没问题，用户二不能接受，因为什么呢？我是10减了1变成9也没报错，但是最终结果变成了11对吧？这就是问题。

所以第一个事物的提交导致第二个事物它已更新的数据没了，这是第二类丢失更新。

好，再看还有一个问题叫脏读指的是某一个事物它读取了另外一个事物没有提交的数据，还是看这个表格这样几个时刻在t一时刻是v读到的数据n等于10，t2时刻他把这个n加一改为11，然后 t三时刻失误二去读 n读到的是它加完以后的值11，而t40克它回滚了。

因为可能在此之前有人有这个问题发生，它回滚变成10，但是对于用户二，他读到的结果反馈的结果是11，但实际已经变成了10，他得到一个错误的数据，一个脏数据这叫脏读。好，再看这个叫不可重复读，指的是某一个事物，它对同一个数据前后读取结果不一致，我一个事物读取同一个数据，前后间隔很短的时间范围内，读到的结果却不一致。

那么这样推演t一时刻事物一读到的值10，t2时刻事物二读到的也是10，然后第三十个15亿把它改成11，第四把它提交了，对于15亿没有问题，反正数据提交了成功了11，但在t5时刻，那么事物二又读了一下这个数据，得到结果是新的结果，11你看在t二时刻t5:，那么事物二先后两次得到结果不一样，那么这两个结果分别参与运算，那么不就矛盾了。如果说这个时间间隔t2和t5间隔很长的话，还说得通，那么它们之间的间隔是很短的，小于一毫秒的这个就不能被人接受，在这么短时间范围内你就矛盾了，这就是问题。

那么这叫不可重复读，在很短的时间间隔内，我读同一份数据不同了。

好，再看最后一个是换读，换读其实和刚才的不可重复读，从这个定义上看有点相似，但其实它角度不同，换读指的是某一个事物，对同一个表前后查询到的行数不一致，不可重复读是对同一条数据查到的结果不一致，换读是行数不一致，换句话讲，换读指的是我查询多行，数据导致不一致，而不可重复读是查一条数据不一致，他们的角度不一样。

好，我们再推演一下，比如说t一时t一时刻，事务二做了一个查询，条件的是ID小于10，比如说他查到了三条数据，ID的分别是123，就这样假设我们目前的数据库里ID小于10的就这三条数据，123，然后在t二时刻失误，一增加了一条新的数据，比如说数据ID等于4t3:他把它提交了，提交以后此时的表里就有了4条数据对吧？Id小于10就1234，那么在t4的时刻，事物二又做了同样的一个查询，ID小于10就发现了有4条数据的，那么在t一到t4:，这两个间隔很短的时间范围内，他先后查两次，得到行数却不一样，这也出现了矛盾。

好了，那么以上是我对常见的并发的异常做了一个介绍，那么当然了可能是你一时异常的情况比较多，你一时记不住，你课后的话对 Ppt对照着这段视频你反复的咀嚼一下，反复的琢磨一下，把它吃透了，因为需要你面试的时候能够把这几种异常能够给面试官讲清楚，表示说你对这个事物理解事物的隔离性理解得非常的到位，所以说这个一定要记住。

好了，那么针对这些问题，如果你不处理这些问题都会发生，而我们利用4种隔离级别去处理，那么不同的级别就会呈现不同的问题。

好，所以这里我又列了一个表格，第一列是隔离级别由低到高排列，后面的是每一列是一种问题，然后这里面标的y和n表示说这个级别它会不会出现这个问题，会出现我就标红了。那么你会发现就第一者第一个级别read on committee的叫读取未提交的数据，这种隔离级别是最低的。在这种隔离级别下所有的问题都会出现，换句话说他就什么都没处理，他根本就没处理。

那么所以如果你选择这种隔离级别，基本上在并发的环境下，数据的安全性是没法保障的，所以基本上我们很少极少情况下会用他的，当然也不排除有些极端情况会用，比如说某些业务当中我对数据的安全性完整性要求不高，非常不高，你也可以选它，因为它的效率最高对吧？它越不安全效率就越高，但总之用的很少。

再看到最后这个级别序列化，希尔莱斯堡这个级别，那么所有的问题都不会出现，那么相应的代价是它要加锁，那么它的性能是最低的，所以我们平时用它也用的比较少，因为性能差，当然也不排除比如说你是一些银行的金融类的业务，那么对数据的安全性要求是极高的，那么你选择哪怕性能低，我也要选这个也是有可能的。

那么对于我们普通的互联网的需求来说，通常中间两个是比较适合我们的，那么中间两个它都解决了一部分问题，你比如说repeatable read，重复读，允许你重复读，那么它解决了4个问题，只有1个换读，没有解决，其实在绝大部分的应用当中，换读是能够被接受的，为什么？

因为换读不是查询多行数据，往往是我们在统计一些内容的时候会出现幻图，比如说我统计一下我当前有多少个帖子，过一会我再统计，或者我统计当天有多少个用户一会再统计，那么可能会前后不一致出现这种情况，这个我们可以一个是通过我们的业务去规避，比如说我把统计都放在后半夜，凌晨三四点钟，这个时候几乎没有在线用户了，很难会出现有很小的概率会出现换流的问题，对吧？

再一个即便出现了，反正我是后台统计，那么影响的是我自己，那不行我再统计一遍，对吧？

反正一般情况下是容易被能被接受的，然后 read committed，它解决了两个问题，这叫读取已提交的数据，那么后三个问题会出现，那么很多互联网的应用，它可能对数据的完整性要求没有那么高，那么对性的要求就很高的时候，这个时候你可以用所以我们在日后的开发中基本上集中焦点是放在这两者当中的，那么如果安全性要求高一点，通常用不那么高，一般用当然了，到底应该选择哪一个，那么你在工作当中最好和你的同事和你的leader去探讨一下，然后根据你的业务去探讨一下，不同的业务应该做出不同的选择，是这样的。

好了，那么了解了隔离级别以后，我们需要再去对它做一个更深层次的理解，就是说数据库保障事物的机制它是怎么实现的？其实有两种实现方式，一种叫悲观锁，一种叫乐观锁。那么数据库它自带的实现机制就都是悲观锁，而乐观锁其实默认没有，我们需要自己去实现。那么所谓的悲观锁指的是他看待问题非常的悲观，他认为如果并发就一定会有问题，既然它一定会有问题，我就提前要对数据加锁，否则就不行了。

而它加锁有两种锁，一种叫共享锁，s锁也就是说式微对某个数据加了共享锁以后，其他事物只能对这个数据也加共享锁，但不能加排他锁，那么他加了共享，所以后他能读到这个数据，但它不能改这样的而排他所叫x所，就是说是a对某个数据加了排他，所以后那么其他事物对这个数据就不能加任何的锁，那就是说其他事物就不能读也不能改，是这样的。

好，所以悲观所分为这两种类型，而乐观所我们需要自己去实现，那么乐观所的意思是我们总是很乐观地看待问题，我们总认为即使病发了，通常也不会有问题。

我先不管我该读读，该做什么操作做什么操作该计算，然后当我真的计算完了，我需要更改数据的时候，这个时候我就看一下数据变没变，如果数据变了，那就证明我处理的过程中有人改了，这个时候我应该放弃我的这次操作，否则没人改我就提交我这个数据，是这样的话，既能保证效率比较高一点，但出现问题的时候，我又可以做一个规避，那么我们怎么去识别这个数据变没变，通常是给这个表加上一个字段，或者是版本号，或者是时间戳，反正能够识别这个数据变没变就可以了。

然后在任何人更新数据的时候，你更新数据之前都要看一下版本号或时间变没变，因为你要更新数据，之前我们往往是要把数据先读到然后去改它里面的某些字段改完以后我要更新的时候，我就看一下，这个时候版本号变没变，如果版本号变了我就不更新了，我给用户一个提示，这次操作失败你再来一次，如果没变那我就可以更新，我就更新，更新完以后更新的同时，版本号要加一，或者是时间说要更新为当前的时间，就是这么一个逻辑。

好了，大家对实行机制有一个大概的了解，能够和面试官就是聊到一块去就好了。当然如果说你想对实行机制有一个更深的理解，你可以再找一些文章自己去研究一下，可以做一个更深层次的研究。

好，那么这是以上事务管理的相关的内容，我们在开发的时候又怎么办？我们开发的时候其实 spring对事务管理提供了支持，提供了非常好的支持。就是spring它有一个模块叫spring data access。那么你从 Spring官方手册上有一张是讲这个内容你可以去看到，然后这个内容当中的第一个小节就是叫transaction management，就是事务管理，可见他对事务管理多重视这个东西多重要。

而且 spring事务管理也恰恰是spring一个引以为豪的这么一个技术点，就是说无论你底层你选的是什么数据库，你是my circle，你是oracle，你是DB2，你是space circle server等等，甚至你底层选的是ready，是包括DB no circle数据库也没问题。

那么spring在对任何数据库做事务管理的时候，那么它的API都是统一的，对我们来说都是透明的，我们就一套API能够管理所有的数据库的事务，非常的牛。

那么具体来说它管理事务有两种办法，一种是叫声明式事务，就是我们不需要写逻辑，不需要写一套逻辑一套代码，我们只需要在配置文件里做一些配置，或者是在xml里做配置，或者是通过注解，在方法上做配置就搞定，就加点配置就可以了，这个非常简单，我们这个课程中基本上就用这种方式。

还有一种是编程式事物，就是说我们需要写一段代码，写一段逻辑去解决问题也不难，那么需要用到的是transaction，template的类去解决问题。那么有同学会说既然它这么简单，还有学的必要吗？我也会给你演示，为什么呢？因为可能是你工作的时候你有一个业务逻辑，它非常的复杂，它可能涉及到了比如说10步数据库的操作，而我们需要控制事物，只是其中的中间的5步，其他的不需要控制，这是一个方法，十步操作。

如果你用这种方式的话，你把注解加到方法前，整个方法都被控制了，不是我们想要的对吧？我只想控制局部，这个时候编程式事务就会起作用，所以这两者我们都需要掌握好了，关于事务管理，我就给大家大概的过了一遍介绍了一下。下面就是演示了，我就给大家演示一下 Spring这两种事务管理的方案到底是怎么去做的。

好，我打开了开发工具，然后这里只是一个演示，我们还没有正式的在项目中运用，所以我们写一个demo，而这个demo我们是模拟说某一个业务，所以说我们这个代码需要写在 service业务层，我就写着阿尔法service这里边，然后这个业务比如说我就杜撰一个业务可能不是真实存在的，比如说我要为这样一个需求，我首先要注册一个用户，我就要增加一个user对吧？

第二步我要自动的系统自动的给用户发一个帖，就是新人报道，这也是增一个增加的行为，增加一个帖子，所以你看这一个业务包含了两个增加的操作，我认为这是一个完整的业务，要保证它的事务性，我就以杜撰的业务为原型给他演示这两种方式。

我既然要在 service里访问 user和帖子对吧？所以我希望把 user和帖子的map注进来，首先是user map，然后是帖子 discus post map好注入以后我就编写两个方法去演示这两种业务的这两种事物的管理的方式。第一个方法，public最终返回一个值，比如返回一个object，然后方法名我叫CF一 Cf一，这个返回值我就直接写上了，return ok就完了。

好，然后我先把这个方法内部的逻辑先写出来，然后我们再说怎么去管理事物，逻辑就是先增加用户，再增加帖子对吧？我写个注释，新增帖子就是以用户的身份发一个帖子，我就直接杜撰一个数据优点6悠着，然后悠着点site you在name随便写一个阿尔法，然后有点点sad。加密用的盐。我要生成我就看没有 Youtube，二结束了。

第二generate uuid然后截取一下sup stream，然后从0~5，然后有点点set，password密码是加密以后的密码，community、YouTube、点、MD5，假设用户输入的密码很简单，123，那么我需要给它加上盐，然后再加密存入数据库，然后悠着点set EMAIL邮箱，比如说是阿尔法艾特QQ.com，还有 user点site，either you are给他写一个路径，这个路径就写一个优客网，自带的image点，然后q点点，com head，然后比如说99t点PNG好还有一个创建时间 site，create time我就当前时间new，完了那么其他的占有字段默认就可以了。

然后我就调用user map，然后点insert，把用户插入到库里，第一步就完成了，再写第二步，第二步增加一个帖子也是类似杜撰一个数据 discourse post等于new discuss post，然后 post点sat，优质ID，应该是用户的ID，当然这个用户我们没有给他赛特ID，不过没关系。

那么正常情况下他插入完数据以后，那么这个买卖点会向数据库要 ID，然后得到ID以后它会塞到这个对象里，所以映射了以后user就有ID了，那么我就user点get ID，当然我们还得检查一下， user map里边，我们在insert的时候是不是写的句话写了这句话，那么当他插入完数据以后，生成的ID就会付给属性，这就没问题了。

然后再来然后是post点set，开头标题我叫hello，再来 pose点sat content这里就写新人报道。好了，最后 post site create time。当前时间好，然后就调用map把这个数据插入到库里，好，这个也就完成了。完成以后，假设我后面还有一些逻辑，在执行这些逻辑当的过程当中报错了，这种人为造个错，因为如果不报错的话，正常情况下反正你不管理事物，这些数据都能插进去，我们怎么看这个事物有没有效呢？

就是说我这报个错，我看他能不能回滚回去，这样能看出来这个事物有没有有效。好，我就随便找个错， Inter点儿y6off ABC意思是我要把 ABC这个字符串儿转为整数，肯定转不了，肯定会报错。

好，那么如果说我们就这样写，去执行会怎么样？数据依然会插入进去，因为你现在没有对他管理事务，那么他每次执行dml语句，执行完以后马上就屏蔽他，马上就生效，不会回滚的。所以我们需要在这个方法之前，通过注解的方式管理事物，让它成为一个整体，如果任何地方报错，我们都要回滚回去。

那么我们在使用当中通过注解的方式去做事务管理非常简单，就在号码上加一个注解叫 transaction就可以了，这样的话他会选择一个默认的隔离的方式，如果我们想手动指定你需要加参数，隔离性我们现在叫参数叫 Isolation等于我们调用那个类as lesson点常量。

比如说我选择效率较高的read，committed就是我们刚才讲的第二个隔离级别，读取已提交的数据，然后我们在配置事物的时候，其实很多时候还会连带再配一个内容，这个内容叫什么？叫事物的传播机制。我先写上，然后的话再解释顺便解释一下。那么 preparation传播机制，那么传播机制要引用的也是一个常量，这常量定义在preparation这个类当中，然后我把它指定为这个值 Require的。

好，那么你可以看一下常量这里有好几个值，什么require的？ Suppose？ Request new， never nasty等等，一共有7个值，那么这7个值我就不挨个解释了，不要啰嗦，我挑几个常见的解释一下，大家对它有一个必要的了解就可以这个解释，我在前面写个注释进行一个解释。

我们最常用的是三有三个，一个就是瑞卡的，好，第二个是 request new，第三个是 nest。

那么首先说一下什么叫传播机制是这样的，你想我在写这个业务方法的时候，是不是有可能我会调用另外的一个组件的业务方法对吧？就是业务方法a可能会调用业务方法b而这两个业务方法a和b它都可能加上这注解，都可能去管理事务，你a调b的时候，我掉了b b的事物应该以谁为准？以b我自身的机制为准，还是以a的机制为准，还是一个什么新的方式为准，对不对？因为这需要这涉及到一个两个事物交叉在一起的问题。

那么所以说事物传播机制指的是解决这种交叉的问题。

好，那么先说瑞克尔，你说这个事儿的时候 A调b你想想 b的情况，瑞克指的是它支持当前事物，那么你去看手册也好，还是看类的注释也好，类如果你下载源码也有注释的，它有注释的，就是一块的。

好，你可以自己翻译一下，然后的话这里我就直接跟你解释了，它指的是支持当前事物，那什么叫当前事物 a到b对于b来说a就是当前事物说当前事物不直观，你可以把它理解为外部事物a调b b b被a调用了，对于b来说a就是外部事物，我们就这样说就是外部事物就调用我调用者，调用我的外部事务，支持外部事务。

那么如果这个不存在，外部事物不存在，那就创建新事物，你看这个单词叫瑞克尔需要他一定需要事物，如果说a调我a有a本来有事物，我就按a的事物来对吧？如果a没有事物，我就创建一个新的事物，按照我的来就大概是这个意思。

好，然后瑞克26它指的是创建一个新的事物，并且暂停当前事务，或者说暂停外部事务，a到b无视a的事物，你有没有我不管有我也给你暂停掉，我永远都传承一个新事物，按照我的自己的方式去执行，这是比如plus6，它需要一个新事物，然后 nest解释一下，它指的是如果当前存在事物，也就是外部事物，如果存在外部事物，则嵌套在该事物中执行，什么叫嵌套在外部事务中执行呢？

A调BA有事物我就嵌到这a的事物里执行，这里指的是就b在执行的时候，这个事物在执行的时候，它是有独立的提交和维稳的，它有独立的提交和维稳，就是我侵占你 a的受理执行，但是我却有独立的提交和回滚，这个意思。好，那么如果外部事物不存在，否则它就和这个一样了，如果不存在它就和 request一样的。

好了，这是我们对这个事物传播机制的一个解释。通常的话我们可能用 Repair的或者是replace new多一点。具体来说用哪一个你了解了这个事物的大概的传播机制的意思以后，也是你得根据你的业务去判定你在实际的工作当中遇到了这种情况，你要和同事探讨一下，我这种情况下，我选择哪个是比较合理的。

好了，这个方法我就完成了，完成以后咱们测一下看它有没有效，我就写一个测试代码，这样我新建一个测试类，这个类我叫transaction test，然后它前面需要加上那几个注解，我把它拷过来，然后因为我要执行的是阿尔法service里的代码，所以我要把阿尔法service注入进来，那么注入进来以后，下面我就可以写一个测试方法测一下 test cfe方法非常简单，就调一下就完了，因为方法内部这个数据我都造好了。

点CF1，它会返回一个object，我们看一下我们能不能得到这个结果，把它打印出来看一下，OB记好，然后我就执行这个方法，执行但是在执行的过程中一定会报错，因为我不是造了个错对吧？本来是要转成这个数字，但是我给他传的是一个字符串转不了，它有个明确的提示。

好，我更关心的是什么呢？这个数据到底存没存进去？我们从库里查一下，我先查user，然后倒叙，因为我们新的数据会在最后我按照it道具来查，你看没有阿尔法说明没插入成功说明回滚了对吧？再看这个帖子也是倒叙查，也没有新人报道的帖子对吧？没有。

好，那就意味着什么？我们写的入园是有效的，当这个程序执行的过程中发生异常的时候，它完整的回归了，它保证了业务的完整性，成功了。好，这只是一种方式，刚才不是说了吗？还有另外一种方式，编程是事物，下面我再给大家演示一下，另外一种方式，还是基于这个业务来演示，还是这两步操作。那么我就再声明一个新的方法，也是返回update，方法名叫CF二，然后我们在这个方法里我们要用编程式事物，我们需要注入一个bean Bean就叫纯Jackson template。

 B是 spring自动去创建，并且自动装备到容器里头，我们直接注入就可以用。然后利用 B我们可以利用它执行circle，它执行的circle就能保证事务性，就能保证这4个特性，我就注入它 transaction template好注入进来。

那么我们接着写 CF二这个方法，首先我们用并去管理事务的时候，我怎么去像刚才一样去声明隔离级别，怎么去声明传播机制，很简单，我们就直接调 template，然后点sat是类似来我然后这个时候我需要调一个类，它里面的常量对它进行一个设置，这个类是纯Jackson，纯Jackson definition点儿，比如说我还要用隔离级别 read committed，这里应该 read committed，你可以把它放大一点。

看完整一点，他没错。就这样去设置。那么设置传播机制也是类似的行为，类似的方式， Site，application，然后 be heaven。那么这里边我们也是需要通过这个类调用它的一个常量去进行设置点，然后是propagation，我还是用 you can't provocation you can't跟刚才一样。

好了，然后我们怎么去利用它执行SQL，保证这个事物很简单，我就这样直接调用它的一个方法，这个方法叫做sq的，然后这个方法需要我们传一个接口进去，这个接口叫纯Jackson call back，是一个回调接口，我可以用匿名的方式来实现，就直接new transaction call back， new transaction call back。

好，这里面我们可以声明它里边返回的这个地方用范型指定我期望最终返回的数据是什么类型，因为我们整个方法是object，所以这里就object就完了。当然了你这里遛完以后，我们需要实现接口所带的方法，我 out加insert实现方法。

好，那么这个接口它有一个方法需要我们实现，角度in transaction，这个方法返回的类型和范型是一致的。

然后这个方法的参数，这个方法首先说它是一个回调方法，它是由他不累的底层自动调，但这个方法的逻辑是由我们提供的，我们需要在这里面实现我们想要的逻辑，然后由他们那边去调，他在调的时候会对这个方法进行一个事物的管理，而且这个参数也是由它来传进来的，但现在我们用不上它，我就把刚才的这两这几步这两步再把它代码拷过来，省点事直接粘到这里来，然后最终也是一样，我业主也退了。

Ok整个方法执行完以后，这个返回的值将被这个template返回，所以就返回回去了。

好，这个数据我改一下，别和刚才一样，我就不叫阿尔法不叫贝塔，然后密码还是123，这个没问题，QQ邮箱贝塔，然后头像999当天时间没问题，帖子又在ID是这样的，然后这个标题比如改成叫你好，然后正文叫我是新人，其他的不变，错误还在就这样就可以了，不管怎么说固定的格式你就固定这么写就可以。

好下面我们对它进行一个测试，再打开测试类，这个逻辑和刚才一样，你也可以粘贴复制粘贴 test，CF二调用 CF二。

好，然后执行一下这个方法还是报错，我们还是关心的是数据的情况，我们先看优质表查询没有增加成功对吧？看帖子查询也没成功，那么就意味着我们刚才的程序它也是成功的回滚了。比方说确实这段代码的事物被成功的管理了，也就证明了这样的代码管理事务是没有问题的。

好了，总之这两种方式平时一般情况下我们优先选第一种简单，那么如果说你的业务逻辑比较复杂，而我们恰恰只是想管理中间某一小部分的事物，你可以用第二种方式。好，那么事务管理我们就介绍完了，那么下次课我们就会对它进行一个运用。这次课我们先讲到这里，咱们下次课再见。