48-任务执行和调度.mp4

这次课我们来学习任务执行和调度，就是说有些功能它并不是我们通过浏览器，然后主动的访问服务器去处理的，有些功能它是服务器定时启动定时运行的，它自己才能运行。比如说每隔一个小时我要算一下帖子的分数，比如说每隔半个小时我要清理一下，我们这个服务器上临时存了一些文件等等，那么像这样的需求，我们都需要任务调度的逐渐的去解决，很显然任务调度的组件它应该是基于独者程的对吧？

它俩的自动运行肯定是要启动一个线程，这个线程它独立的运行。

那么我们在程序中但凡是要用到独者程，那么一定是通过线程池去使用的，因为我们创建一个线程是有开销的，并且开销比较大，那么使用线程池去管理线程，能够让线程复用，能够提高处理能力，或者说能够节约一些资源。

所以关于多线程这个话题面试的时候也愿意问，那么问的时候一定会聊到线程池这个层面，所以说这是一个面试的时候比较愿意聊的话题，大家要多关注多去思考这方面的问题。

当然我们这次课要解决定时任务，其实我们最终用 class工具就能搞得定，但是我想借着这个机会把线程池有关的内容咱们尽可能的全面的介绍给你，让你对现场职能有一个整体的了解。

首先就是jdk它就自带了行程尺，然后常用的有两个，一个叫SQL的service，这是一个普通的线程池，它能创建普通的线程解决一些问题。然后第二个常用的是这叫schedule is cute service。那么线程值所创建的线程能够每隔一段时间执行一个任务，它可以执行这种间隔的任务。好，这是jdk自带的两个线程池，我们一会会给大家演示。然后我们使用的是spring框架这个框架，它也帮我们内置了线程池。

那么第一个叫做常用的叫做thread pull task sqt其实它的作用和一样是一个普通的线程池，创建普通的县城。第二个是spread pull task。Schedule它的作用和这个一样，就是说它所创建的线程能够执行定时任务好，这是spring。

但是你要注意就是说我们普通的线程池我们可以拿来用，但是我们定时任务，那么在分布式的环境下，我们分布式部署的时候，这个用的时候可能就会有问题，因此我们其实在分布式环境下，通常用 Class工具的时候更多一点，那么它适合用来解决分布式的定时任务，当然我们不是单独的使用这个工具，我们是用spring去整合它，然后这个是 cas的官网的网址大家可以去看一下，打开以后大概是这么一个界面比较简洁，然后中间有个按钮叫document， documentation你点进去以后是他的手册，那课上我就不带着大家去看了，因为比较长，但是我一会可以给你演示好了。

那么我们在写代码之前，我想再说一下为什么说在分布式环境下，我用这个东西或者用这个东西做定时任务会有问题，有什么问题，为什么class它能解决这个问题？我们先把了解一下，了解完以后我再依次给大家演示这些工具怎么去用。

好，那么要说这件事我需要画一个图，分布式部署，就是说你这个服务器得有多个节点，做成一个集群，我就少花点，我就花两个，比如说我部署的时候有服务器一然后当然服务器里有什么样的程序，它其实有两类程序，一类就是普通的程序，比如说 CTRL这样的程序，这样的组件它能解决普通的请求，然后它里边还有另外一类程序，就是我们的定时任务，这个定时任务我取名给它叫schedule，好。

好了，总之笼统的概括来说，我们服务器有两这两类这样的程序，当然了我这不只是一个服务器，还得再有一个或者是有更多个，这里我就只画两个。

好，那么我们在集群环境下，我们通常浏览器不是直接访问某一个服务器，这个服务器它的前面需要有一个负载均衡的工具，通常我们会用 nx，那么浏览器发出请求是发给恩杰斯，他发请求发给恩杰斯，然后杰克斯会根据一定的策略，然后把请求分发分发给某一个服务器，假如说这次请求它分发给了服务器，一如果这是一个普通的请求注册登录查看首页，那么他肯定是把请求分给了一个controller去处理，处理就完了，这个没什么问题。

虽然说这两台服务器里头的代码一样，但是它同一时刻只能有一个，或者说对于一个请求只有一个服务器去处理，这个是不处理，所以说他一样也没有什么影响，没关系是这样的，但是对于 schedule对于定时任务就有问题。

对CTRL这没问题，定时任务有问题，因为两个服务器都有同样的代码，都有同样的定时任务。

这俩服务器一启动以后，这个定时任务你不用主动去访问它，就自动的在那跑，它每隔10分钟就做一件事，假设你想一想这俩代码一样，每隔10分钟他俩都做同样的事情，这不就重复了吗？比如说每隔10分钟我要清理一个临时文件，删掉临时文件，他俩做同样的事情，重复了，甚至会产生一定的冲突，对吧？

所以在分布式环境下，这个sky就不太合适。这就是为什么我们直接使用jdk的 Sky的或者是spring的就不太合适，因为他们没有解决分布式部署的问题，他们是各自为战的。那么如果我把它换成我们最后所说的 cart，工具就能解决问题。好，我把它改成 cart。

好 chaos怎么解决问题？我们要说一下GD k和spring的定时任务组件，它是基于内存的，你配置它说我多长时间运行一次，它配置参数是在内存里，这个服务器一服务器二它内存不共享，所以说它们之间没有办法进行一个数据共享，没有办法知道说你在干嘛我在干嘛，所以说他解决不了问题。

但是快它的就是定时任务的这些驱动的这些参数，它不是存到内存里，它是存到数据库里，而我们的数据库就只有一个，这样的话我先画一下，比如说这是数据库 Db，那么快as它程序运行所依赖的那些个参数存到了数据库里，所以说不管是你有多少个应用，你部署了多少个快儿子这样的程序，那么它都会访问同一个DB。

比如说10分钟访问一次，虽然说10分钟到了这两个程序几乎同时访问这个数据库，但毕竟有先后，即便同时访问，那么他们也也可以通过枷锁的方式去抢到，优先抢到资源，假设 class程序优先抢到了 DB资源，然后他是后到达的，他先到达他后到达。

那么对于 class程序他先防了这个表里的数据，他会看一下我这个任务当前的状态，你是在等待运行还是已经运行的？他一看是等待运行，因为是他先访问的，他就立刻把这个数据改成运行状态，然后的话它就运行去了。当 cart程序仿这个表的时候，他一看这数据变成了运行状态，就证明已经有别的服务器已经有别的程序在处理这个任务，他就不去处理了。

所以说通过这样的话，多个科尔的程序，他们能够共享数据，或者说他通过同一份数据实现了一个也可以说排队，或者说也可以说枷锁这样的一种机制就解决这个问题好了。

因此我们最终的目标是要学会使用快去解决定时任务，这是我们最终的要应用了这个方向。

但是我们在学习它之前需要先了解 jdk的线程池和spring线程池，那么首这两种各自的这两种线程池分别怎么用？你对它有一个比较全面的了解，这是我们这节课的完整的目标。好，下面我们就来写一些程序来体会一下这些工具的使用方式。这个程序都是小事例，都是 Test，所以我创建 test给大家演示也比较简单，好，那么我在这个包下新建一个测试类叫做 spread破线程池test，那么我需要写上那三三行注解，我拷一下。

好，那么接下来我就在测试类当中依次给大家演示，刚才我所说的那些个工具演示之前，首先我先室内画一个logo，我们在使用线程做一些事情的时候，最好通过logo去输出一些内容，因为 logo在输出内容的时候，他自然而然会带上现成的ID，并且会有这个时间，所以我们看起来的话这个信息比较完整，适合在多线程环境下去，用它来输出一些内容。

好，那么有了log以后，接下来首先我给大家演示一下 jdk的线程值，那两个先演示第一个jdk普通的线程池，但JD其实好像有五六个县城池挺多的，我说演示这两个是比较常用的，其他的不常用的，我就不演示了，但是你也可以去查阅一些资料做一个补充。

好，第一个比较常用的是 sqt service，好，我直接的把它实例化一下，然后后面的程序你就可以直接用了。那么jdk的线程尺，它都是通过一个工厂来实例化的工厂，就叫sqts然后的话 New fixed spread pull。

然后写一个数我写5，就是说线程池初始化以后它里边包含几个线程，包含5个，它是反复的复用这5个已经创建好的线程，这个我们一会儿通过代码能够看出来。

好，然后再来我再把另外一个也初始化一下，就是jdk他所带的可执行可定时执行任务的线程池，这样可执行定时任务的线程池。

好我也把它实力化一下，这个叫做scatt的sq的service，它取名就叫x Guide you的sq的service，然后也是通过 sqt去转化 executors，然后点new skill，然后 straight pull好，我也写个数，也是它里面包含了线程的数量。

那么初始化完这两个线程池以后，接下来我就写两个测试方法来分别演示一下，那么这两个线程池怎么去用？然后呢你要注意我们现在用的是解忧类的测试，在这里面我们写的是解忧类的测试方法，那么解决问题的测试方法它和 Main方法不一样，如果我在一个main方法里我启动了一个线程，那么这个线程如果说不挂掉的话， main会等着它执行，它不会立刻就结束。

但是 test的方法几个类的方法不一样，它启动了一个线程，因为它启动的子线程和当前的线程是并发的 test的方法，如果后面没有逻辑的，它就立刻就结束了，他也不管你提供的线程完没完成，有这样的一个问题，怎么解决也好办，那么我在test的方法启动完一个线程以后，我想等一下等他执行完我再结束怎么办？

我可以让主线程或者是当前的线程实力的一会儿阻塞一会儿，而斯蒂芬他又老是抛异常，为了吊起来他方便一点，我把斯蒂芬稍微封装一下这样。

好，写一个简单的方法， sleep、参数、浪m毫秒， m是毫秒，好，每次调这个方法就是让当前线程阻塞一下是right，点sleep m当然这个需要处理异常，我就开始一下就完了简单处理。

好，接下来我就演示这两个线程池的使用，然后这是第一个，我演示的是 jdk的线程池，jdk普通协同式写一个测试方法，这个方法我叫test，is cute。

Service就演示它的使用，那么现场使用它就是说你需要给他一个任务让他去执行，然后他会分配一个线程来执行这个任务，而这个任务其实就是一个线程体，我们通常都是实现让它包接口来提供线程体来提供这个任务。

所以在一开始我实现一个random接口，软的 task，这是一个任务，等于没有软的，我对它直接做一个匿名的实现，然后 run方法里就是写上你要执行的具体的任务的逻辑，这里我简单一点，就log，然后 debug。随便写一句话， hello execute service。

好了，好，写完以后我就用这个线程池来执行它，线程池里不是有多个线程吗？我执行多次，每次他都会分一个线程的来执行这个任务，我执行多次，我从0到10，反正我一共执行10次，每一次我就是Diao Sq的servis，点儿 submit，把任务传进去就可以了。好了，反正你调这个方法，subway的方法线程池就会分配一个县城，然后来执行线程体就这样。当然了别忘了死力配一下，要不然这个方法一执行，这个线程还没执行完，他就结束了，我死力了一下，等一会死。

力配1万毫秒，也就是10秒钟就够了，好我就执行一下。好，那么执行完了，其实执行的就是10次，执行的应该是很快的，我们看一下控制台的输出，看这个底就底，然后方块号里边它什么spread？

1spread5其实就是线程池的应该是名字，线程10的名字，你看这就是第一个线程，第二次分配到第五个线程，然后15351342，反正哪个工程就分哪个，你会发现反正就是123 4 5这5个县城来回折腾，就说明确实这个县城是两反复的使用这5个县城。

好，然后输出的内容倒没什么好说的，就是这一个字上这一句话我们主要是看所以说确实看出来这是一个独者程的执行的环境和结果。好，下面我再来给大家演示一下可执行定时任务的线程式。再写一个测试方法，就是jdk定时任务线程式，这个方法我叫test，schedule is killed service， Call一下太长了，那么这个线程尺它的功能就是它可以设置时间间隔，然后不断的去执行。

当然了他执行的时候也是你要给他提供一个线程体，线程体的提供方式和这个是一样的，所以我可以copy，我又定义了一个任务，这个任务还是输出一个日志日志，我说出这么一句话，hello scheduled sko to a service好了，那么我怎么去执行定制任务，我就调用schedule sq的service，然后点一般我们教这个方法 schedule at fixed rate以固定的频率去执行，每隔一段时间执行一遍能执行多次，你也可以调另外一个 schedule with fixed delete，以固定的一个延迟去执行，这个是执行一次，但是执行一次它就结束了，但是你可以指定一个时间，推迟多长时间执行一次这样。

好我用可以执行多次，然后这里边需要传几个参，第一个传入任务，第二个你要传入就是这个任务是你要延迟多少毫秒才执行，它并不是说你一调它立马就执行，它可以做一个延迟，比如说我延迟1万毫秒，你看这个参数的含义是initial给力延迟的时间就10秒。

然后第三个参是时间间隔，它可以反复执行的，时间间隔是多少？1000毫秒，周期是1000。第四个是你要声明你这几个数字，它的单位是秒还是毫秒，你可以用 Time。Unit，然后点儿美丽塞克斯毫秒就这样。

好，这句话一执行这个任务就连接线程池，就会按照我们所规定的参数周期不断的去执行这个任务，这个就不用启动多次了，因为这一个线程池我们调这一次他就能反复执行，所以说你没有必要调多次，就这一句话他就能反复执行，当然我也需要阻塞一下，然后等一会儿等时间久一点，我等3万毫秒就30秒，这也就够了，我再执行一下这个方法。

你看他没有立刻输出内容，他得等一会儿等10秒，这说明得力参数就有效，10秒以后它开始执行时间间隔是每一秒输出一个内容是吧？然后它一直在这输出的，直到这个方法停止为止。

然后当然输出的内容其实没什么好看的，就是hello那句话，我们主要还是看现成的名字，你看11完了就30秒到了就结束了，你看11213对吧？每次执行的时候，每次调度的时候，它会分一个新的线程来执行 task，所以这也是一个独者程的环境，也能看得出来。

好了，这是GD Kay的现实比较简单， Sabrina也给我们提供了线程池，然后也比较好用。

我们再来演示一下 spring的形成池，那么spring只要我们引入 spring的核心，它就自动就启用了行程池就可以用，但是我们需要在 application里头对 spring行程尺做一些配置，你要配一下有它启动以后它带几个线程这样的一些数据，所以我打开配置文件， application practice我再加一项配置，那么 spring给我们提供的普通的线程池，它的我们配置的对应的类叫做task，然后 SQL execution， task，sqc process。

好，这里面我们首先要配的是spring点，task点儿，sqc点儿破size等于几？就是你线程池里有几个线程？好，再来。第二个我们往往要配 spring点task，点excuse，然后我刚才这个写错了，不是破-3是这样的，是破点。Com site就是核心线程数量，线程池里边的核心线程数量是5，然后再来这个是破点，max site我设置为15，什么意思？就是说当我线程池创建好以后，它默认的在5个线程，但是如果你调用的比较频繁，你使用的比较频繁，线程不够用的时候，它会去扩自动去扩容，最多扩到15，这个意思。

好再来第三个我们还要配 sq spoor，然后点 q capacity，然后比如说我设置为100，这是什么意思呢？

Q capacity就是队列的容量，那么比如说就是说我这个线程一共已经到了15个最大线程数量了，但是可能还是不够用，你还有更多的任务提交给我，我15个现在不够用怎么办？他会把任务先放到一个队列里，然后当它有空间线程的时候，从队列里取上再去运行队列起到一个缓冲的作用，更大程度的提高线程时的性能，你这个队列一共能缓冲多少个？

任务，这里配的是100个。好，这是普通的线程池配置，那么能启动定时任务的线程池怎么配？它的类是这样的，是task，然后 Scheduling，practice，task，schedule and practice是这个类，然后我们一般只要配一项内容就可以了。 Spring的 task， Scheduling gap。Tool点。Site等于5，就是说你线程的数量，线程池里装的线程的数量是多少？是5，有人说你怎么没有说 max什么的，其实没有必要不需要，因为你这个是普通的县城，那么你要执行多少个任务，你需要我执行多少个任务，这个不一定。

这种现成的这种任务它是可以通过浏览器访问，然后主动触发的，所以有多少个不一定，但这种是定时启动的。

服务器通常是服务器一启动它就动了，我们是可以提前预判的，比如说我需要一个任务去清理文件，我需要一个任务去算分，我需要一个任务去做缓存，可能我就需要三个，你这个等于三就足够了，就这个意思，所以我们可以提前预判，看有几个比较合适好了，那么这个参数我就配好了，配好以后我们再回到测试类，然后继续写测试的程序好。

我回到测试类，然后还是我在开头的位置，先把 spring的两个线程尺给它初始化好。

其实这个初始化不用我们初始化spring，它框架已经帮我们初始化好了，而且它会把初始化好的线程池放到这个容器里，由容器来管理，所以我们要用的话就注入进来就可以，我把它注入进来。

首先我要注入的是死不用普通的系统池，然后再注入可执行定制任务的行程式。好，先注入第一个 out where这个线程池的名字叫 thread。Poor。Task is cute。然后变量名我取的简短一点 task，sq的再注入第二个，这个类的名字叫spread，pull task是该得了 task。Schedule。

好，下面我就写两个测试方法来演示一下，那么这两个线程池的使用方式，我做的事情和刚才一二做类似的事情，然后我们做一个对比，看看能不能达到同样的效果。好，这是第三个就是spring的线程池，那是普通的 test，类名我拷一下test的好了，首先我们也需要声明一个线程体可以copy类似的，然后也是打印一句话，打印 hello，spread pull passed sq等。

然后对于普通的线程池，我要调10次，每一次执行一下同样的一个任务，我们看一下它的效果好执行10次，每次我调 task，sq的，然后叫submit task。当然了也得阻塞一下 sleep10秒，好，写完以后我来执行一下，报错以后我们看一下这个提示，它提示说找不到 schedule，不存在我想起来了，我忘了一件事，你要想让 sky能够这个生效，我们还需要做一项配置，我们需要写一个配置类忘记了，所以说sky没有被正确的注入进来，这样我在肯费格目录下新建一个线程池有关的配置类，这个类我叫spread，然后加上一个注解看微信，然后我少加的东西是这个东西叫 enable schedule。

如果你不加注解，就说明定时任务它没有启动，这个东西比较敏感，默认它不启不启用，这样我就启用了才能用，然后通常我们再加上另外一个注解，盈利宝，那么就是说一会我们可以用，这个是一个注解，注解可以启用的，有什么用我们一会再看。

好写完配置了以后，我们再回来再来执行这个方法。

好，当然其实已经输出完了，但是它程序没有结束，因为它主次在这儿的，然后你看这个输出也是输出了10句话，debug对吧？然后每次输出的内容就是hello，然后你看现成的名字，14、325，反正一共是5个线程，他来回换来回分配也是一个独者程的环境。

总之它的执行的效果其实和刚才这个是一样，但是它的好处是我们线程池配的时候可以配核心的线程数量，最大的线程数量，如果超出这个，它还有一个队列的缓冲，所以说它比 jdk自带的线程值它更灵活，所以我们要用的话优先用这个比较好了，那么接下来我再写一个方法来测试一下 spring的第二个线程池能执行定制任务的线程池，这是第四项内容，spring定时任务现场使用。

因为这些方法其实每每个方法它所做的事情很类似，如果不写清楚的话，我怕你课后忘了，所以把它注释写的清楚一点，这个类我也拷一下。Test，thread，pool，task，schedule的同样的我也需要一个线程体把它拷过来，然后 hello这句话。好，然后我就调用task。Scheduler。 Schedule as at fixed rate，以固定的频率来执行这个任务。那么它的第一个参数写上task，第二个参数你要写上，它不是说延迟多少毫秒去执行，它是要写一个具体的时间，一个data，所以我提前先把 data初始化一下， data然后 start看我就开始时间，开始执行的时间你又对这里我写上system。

第二 carry on the time maybe就是当前的时间毫秒数我要加上1万毫秒，说白了就是当前时间再延迟1万毫秒，其实也是跟延迟一样的效果。这里写上 Start碳，然后第三个参数写上它的时间间隔1000毫秒也就是一秒，然后这个方法它默认就是以毫秒为单位，所以你不用指定单位就可以了，这样就行了，当然也需要阻塞一下实例3万，阻塞30秒。

好，写完以后我再执行一下这个方法。你看一开始他没有执行，他在等，现在也没有执行得等10秒以后才能开始输出，输出挺大的，开始输出了，然后时间间隔是一秒，每次输出这是现成的名字，它是不断的在换，反正每次都换。

当然也有的时候很多时候是一样的，但是你能看到他确实在换，然后直到30秒到了整个程序结束为止，所以这个方法的执行和刚才二一样，好就这样，这是spring的两个线程池，其实这两个线程池我们在使用的时候还有一个简便的调用方式，我再给大家演示一下简便的调用方式，那么简便的调用方式就是说我只要在任意的一个变里说明一个方法，你该写什么逻辑写什么逻辑，然后只要在这个方法之上加上一个注解，那么他就可以在死不认线程池这种环境下去运行，或者说我们在bn中写的方法，我们就可以把它作为一个线程体，而不是说像这样就是一个普通的方法就可以作为线程题，这样就更灵活了，更简洁了。

好，给你演示一下。我随便找一个组件，比如说阿尔法service，以前我们也是在这里写一些测试程序，对吧？我在这里再补充一点东西，随便写个方法，public want这个方法我叫sq一，然后这里边我就还没有初始化这个Lague，我初始化一个Lague。好，那么有了logo以后回到刚才的sq的一方法，我还是就在这里简单打个日志 Logo点大，然后的话写sq的一简单点儿完了。

好，这个方法你这样写，它当然不会以多线程的方式去调，无论怎么写，我们需要前在前面加一个注解。

那么注意刚才我们在配置文件里为什么写这句话，其实就是让注解生效。那么这个方法加了注解以后，能怎么样？可以让该方法在独者程的环境下被异步调用，能够让他在多线程环境下被e部的调用，也就是说我一个线程，我启动一个线程来调这个方法和主线程是并发执行的，是一步执行的这个意思。

好了，当然你这还得有地方调，现在还没调。好，我们在这个测试方法里再去调了一下，我再回到 Test，这是我要演示的第五个内容，就是spring普通线程池的一个就是简化的使用方式，他的word test。 Test什么还叫这个名字 test，他然后先把简化的方式，当然了我要调的是阿尔法servis，你得把阿尔法servis注入进来，对吧？不然我怎么去调 Biehn的方法，好，我在前面把它注入进来。

好，回到刚才的位置，我在这里我希望调那个方法调10次，那个方法其实就相当于是一个任务，就相当于是一个线程体，现在我要调10次，我就直接循环十遍，每次循环里我就阿尔法service，然后点sq的一就可以了。

那么在程序的底层， spring它会以多线程的方式去调这个方法，它会让这个方法就是作为线程体，他会用线程池去调的。好，我们执行一下看看，那没有输出结果，就是我忘了一件事儿，我还是要在这阻塞一下，不然的话这个线程还没执行，这个方法就已经结束了。

实力培训就是实力10秒，好再来你看很快就输出了这个结果，然后他也是输出了10句话，然后我们看这个线程的名字1245对吧？也是用到了县城治理这个县城也是复用了县城治理的县城，也是独者程的环境，这样的定位方式就更简单了，更方便。

好，那么定时任务的线程值也可以用这种简化的方式来调，我们再来看一下。

我再回到阿尔法，Siri上再写一个方法，这个方法叫 sq二，然后简单一句话，logger dady Bugg excute，完了，那么我要想让这个方法定时的去执行，那么我只需要加一个注解就好了。

下一个schedule的，然后我在注解里可以写一些参数，你搜得类比方说这个方法，我调完以后它延迟多长时间去执行，我希望延迟10秒执行。

然后再来个参数 Fixed，wait，固定的频率就是多长时间执行一回？

1000毫秒也就是一秒这样，然后注解其实还有其他的就是配置的方式，其他的参数，那么我们就不挨个演示了，这种这两个参数是比较常用的方式，你做一个了解就ok了，其他的如果你想更多的了解的话，去翻一下官方的手册。

好这就可以了，如果说我一启动这个程序有了注解，他立刻就按照这个逻辑去执行了，这样我再写个测试方法，通过这个测试方法去驱动，然后让他去执行。

六就是思路定时任务线程尺，当然这也是一个简化的方式。

这个方法名我就还叫后面加一个sample，那么这个方法其实我不需要做什么，因为刚才我们所写的方法它是自动被调的，你不用主动去调它，但是我想让这个程序启动起来，我这样我就直接 sleep30秒，然后那个方法就自动会被调，只要我有任务启动，只要我有程序在跑，它就会自动被调。

好，我们试一下执行，一开始都没有执行，因为它延迟10秒对吧？得等一会儿好，然后10秒以后开始执行。

你看输出的内容sq的二没有问题，然后每次打印的现成的名字123这样的，说明这确实是一个多线程的环境，这种方式就更简单了。好了，那么现在我们就把 jdk的线程池以及使用的线程给你做了一个演示，你这两种线程池就都会用了。当然了还是那句话，如果说我想用一个普通的县城，你用就可以了。如果你想用定时任务的这种线程，这个在分布式环境下有问题不太好用，那么我们需要学 class，所以接下来我们来学习 care。

那么刚才我也画了图说了一下，就是说科尔它是依赖于数据库的，那么它有一套表需要我们要用的时候需要提前的去创建，那么这个表我第一章讲买卖s的时候，我给大家提供了一些社科的脚本，大家也进行了初始化，其中有一个文件叫tables刚买circle杠，in，DB的circle，这个文件里的Biao就是cared所需的Biao，你需要打开命令行工具，然后用source命令把它导到我们的 community库里头去，这件事我提前已经做好了。

我们来看一下一共有好像有11张表，这个表都以qrtz ks的缩写来开头，这些表，然后这些表你不需要说把每一张表的结构搞得清清楚楚，我们大概了解它里边存了什么东西就可以大概做一个了解。那么哪几个表值得我们去看呢？一个是一个是。还有我们通常看这5张表就能看出点意思来。

当然我们在没有看之前，有你一开始你不了解快儿子，你看这个表你也看不懂，我需要先对快儿子给你做一个大概的介绍，你对他有了一些了解以后，再来看这个表可能就有点这感觉了，主要是给大家说一下 Class它有它在这个工作的时候，它有几个核心的组件，这些核心组件是什么关系？首先我直接对着这个源码跟你说，首先它有一个核心组件叫schedule就调度器，中央调度器它是整个卡尔斯的一个核心，当然现在我还没法去打开那个类，因为我还没有导入卡尔斯的包这样我表现好了，然后的话我先把 quest的包先导进来，然后我好对着源码给你看那几个类，然后我们再解释这个表。

要倒包的话我们需要打开 maven repost的com，然后我们需要去搜搜什么 spring boot cat好搜一下。很显然这个 Spring boot travels start我点进去选一个 kopje，我把它拷到我们的配置文件里面，泡一点xml。当然了，因为这是死不用不的提供的包，那么它的父类一定是对版本是有声明的，所以说这个版本可以去掉，就附那种上面的就可以了。

好，那么导入了包以后，我们来说一下快儿子它有几个核心的内容，核心的组件，一个是schedule，孵化器的class，那么这个类是class的核心的调度工具，那么所有的由ks来调度的任务都是通过接口去调，它是核心。

后面我会演示我怎么去直接使用这个接口，先对它有个印象，然后你要知道其实我们定时任务主要是干什么，主要是定时每隔一段时间去执行一个 task，去执行一个任务。

么class是对整个流程做了一个设计，首先我们要用class来解决问题，首先我们需要定义一个任务，那么定义任务通过 job接口进行定义，它有一个job接口，那么这个接口只有一个方法，sq的方法这个方法里头你要写上你要做的事，你要执行的任务。

好，这是我们使用class其实第一步，而刚才的 schedule其实不用我们去写，其实它底层已经实例化好了，我们可以直接用 job需要我们去写。好，然后 job只是声明了我要做什么，那么具体怎么做，我们还需要进行配置，还需要另外的两个接口的配合。

另外还有一个接口叫job detail， job detail它是 job详情，其实它是用它来配置 job的，他要用它来配置照你的名字是什么，你的组是哪个组，然后对这个照片有一些必要的描述，以及相关的一些参数的配置，是对这个照片进行配置的。

然后还有一个接口叫崔哥，崔哥是触发器的意思，那么它用来配什么？这个兆什么时候运行，以什么样的频率反复的运行，所以其实就是我们使用cart，我们编程的主要是三个方面，一个是通过drop接口定义一个任务，第二个是通过dropped kill以及trigger接口来配置这个状，主要是做这三个方面的事情就可以了。

然后我们配置好以后，怎么样配置好以后，当我们程序启动的时候，那么 Cart就会读取配置信息，并且把它读到的配置信息立刻存到数据库里，自动的存到那些个表里，然后以后他就去读取那个表，来执行这个任务，只要数据初始化到数据库里以后，这个配置其实就不再使用了，就这个配置只是在第一次启动服务时用一下，以后就不用了，是这样的一个逻辑。

好，你大概了解这三个组件以后，我们再来看一下这个表。

我说打开的 job detail，就是对 job的一个详情的描述的一个表，我们通过job detail去配置的那些信息就存到这个表里，这里存在什么 schedule，name就是整个任务的名字， job name、这个job的名字，job的分组， job的描述， job对应哪个类等等，就是这样的一些信息，总之这个表存的是job与drop有关的直接的配置。

然后这个表 class simple triggers是还有 class triggers里边存的都是和触发器有关的配置，只不过 simple崔哥这里面存的是崔哥简单的内容，这个是存的比较完整的内容，他也存了任务的名字，然后处罚界哪个组，他反复执行了多少次这样的，然后完整的信息里还存在什么，还说了这个触发器对应的是哪个兆，这个照片是哪个股肉，他也存了相关的照片的信息，然后还存了我下一次应该什么时候执行，我上一次什么时候执行完了这样的一些信息。

然后 class schedule的state存的是定时器的一些状态，纯粹是定时器的实例，定时器的名字，然后检查的一个时间。第二期检查的一个时间，就是说它定时器在那自动运行着，它有没有好好的运行，它有没有问题，那么这个快要在底层的会定期的检查，看你到底是不是ok的，这里边会做一些记录。

最后这个是class，这里面存的是这个组，就是定时器的名字以及锁的名字。那么当多个cart在访问这个表的时候，那么它会以这个名字来对数据进行加速，是这样的。

好了，大概了解一下它底层表的大概的原则它里边存在大概的信息，然后一会我们执行的时候这里数据就会生成，到时候我们再看一下好了。

那么大概了解以后，下面我们就来写一个例子，我们来体会一下用 Class到底是怎么样去解决问题，那么是这样，首先我们第一步要做什么？

按照刚才我所说的第一步我们要定义一个任务，用 job接口来进行定义，我在这里面新建一个包叫我把 cart有关的任务都放到这个包下，现在我要创建一个job，这个job其实就是一个事例，没有具体的业务，我叫阿尔法兆，然后它要实现接口 implement，实现它的对应的方法，这个方法做什么？我就是简单的打印点东西，简单点 This out。然后 spread点 current。Spread get name就是我要打印当前线程的名字加上冒号。

然后 it's cute a crass job。就等于一句话说当前线程它执行了一个任务，这job就完成了，就非常简单，反正就是一个方实现一个方法，实现完以后，我们需要对 job进行配置，这样的话科尔的底层才能够读取配置信息，生成表里的数据，才能够让这个任务运行起来。

下面我就来写配置，那么我就在config包下新建一个配置类叫cat，那么当然了配置类也需要加一个注解，consideration，然后写注释就是配置的作用是干嘛的，他不是每次都有用的，配置的作用仅仅是在第一次的时候被读取到，然后初始化到数据库里，它的信息它封装的信息被初始化到数据库里，然后以后 class是访问数据库去调度这个任务，而不再访问配置文件这样。

好，那么我们要配的是两个内容，一个是drop detail，一个是崔哥，所以我需要先写一个b然后 public先配 job detail， job detail。Fact就是be有人会感觉很奇怪，你不是配job detail，这怎么又出来个 factory b一会我再说我先给它取个名字，给这个病取个名字叫阿尔法drop detail。

然后这里我先先给他们闹，要不然他报错难受，接下来还要配吹梗。

我再写一个b然后 simple简单的崔哥，然后 factory be也带上了factory be，为什么一会再解释他的病的名字，我取名叫阿尔法学者，那么我们在初始化崔哥的时候，崔哥是依赖于 job detail的，刚才我们看表也看到了，崔哥他是和job有关系的，但是 job detail有一个直接的关系，我们需要把这个病注入给他，所以这里边我上面的参数叫job detail，它需要读取job detail，我把它传进来，而这个job detail变了，名字我这样写。

好了，到这儿你肯定有点晕了。一会儿一会是job detail factor been，这到底是怎么回事，我需要解释一下。其实 spring底层它有很多地方都有这样的病，都有这样的名字，叫什么fact？就是病 factory并和之前我们一开始是LC的时候，并factory有本质的区别。你还记得那个being factory吗？它是我们整个LC容器的顶层的接口，但是我们所见到的 factory并和就两码事。

这个还经常的是一个面试的题，可能是笔试会有这样一个题，所以说并发个人你已经知道了，它就是顶容器的顶层接口，这个factor been你在这了解以后你就能回答这个问题，这里我解释一下，我把它写到注释里，这样的话你好，课后的话我复习 fact been它的作用是可简化变的实例化过程就是说 fact并的主要的目的是为了简化并的实例化过程，因为有些病它的实例化过程比较麻烦，那么有了发推病以后，它的实例化就容易了，或者说你可以这么认为类的，底层封装了job detail详细的实例化的过程，它对它做了一个简化，具体来说它有几个层面我们需要理解，第一个层面是通过三个病封装了思路，要通过三个病封装了，病的实例化过程，是某一些病实例化的过程。

好，第二个你要知道的是我们可以把 fact been装到容器里，我们可以将 factor b装配到spring容器里，那么装配到容器里以后，当然其实我们要的不是这个fact，并我们要的是job detail，但是你注意它底层封装的job detail的一个过程，那么会怎么样？接下来我们可以将 Factory b装在容器里以后，我们将它注入给其他的病，我们先把它装备到容器里，我们再把它注入给其他的病，那么该病就其他的病得到的是什么呢？

是三个病所管理的对象实例，你看我在这儿我初始化的是job detail factor been就相当于我把它装配到了容器里对吧？

然后在这儿我这个参数上我需要做个得听怎么办？那么我就把把它这个是变的名字，我把变注入进来的时候，那么默认情况下，我得到的不是factor b我得到的是它里边管理的对象，job to kill，所以类型是job点q它是这样一个关系。好了，总之他通过这么一个非常感觉有点别扭的方式来实现对病人的简化的过程就总之我们去初始化，这个东西要比初始化装备的q要容易多，就这个意思。

所以这里我这样写好了，我如何初始化照不得跳，发对并的写不出事情，我是主要的目的是要配置 job detail，而这个我要配置的是崔哥把这两项配置解释清楚，再一个那么我们要配 job的q我们要用这个job并简化的方式，我们只能用这个类，然后我们可以崔哥也要用fact并的方式的话，其实我们有两种选择，一个是simple崔哥 factory并，还有一个是crown。Trigger factory。这两个都可以，但是它的模式不一样。这个是简单的崔哥，就是说比如说我每10分钟要执行一次，他能搞定，这个是复杂的。崔哥。它能解决什么问题？比如说我每个月月底的那一天，半夜2点我要做一件事，用这个可以搞得定，比如说每一周五的晚上10点我要做这个事儿，我要出发，他能搞得定，它里边有一个特殊的表达式，它只要用一个表达式就能搞定这么复杂的一个逻辑。

那么你通过官方的手册可以去了解它表达式，或者你去搜 Crown表达式其实有很多解释，然后其实看起来很神奇，但是很简单，好了我们就来初始化这两个病，首先我在这要先使的话，这个照片就反馈好，先实例化对象，然后给它设置一些参数点散照。

Class你要声明你管理的是哪个病，它的类型是什么，我就阿尔法job加class。好，然后再来 factory，bean。

第二site name你要声明的 job的名字叫什么？你给这个任务取个名字，我叫阿尔法，job这个名字不要和别人别的任务重复，否则会有问题，然后发觉并点sat group，你给这个任务取一个组，多个任务可以同属于一组，这个组我就叫阿尔法兆 group，这样取个组名。

好，另外 factor been点set，deal ability。一般我们设置为true，这句话的意思是声明一下这个任务它是长久的保存吗？是持久的保存吗？是的。那么就是说哪怕是这个任务将来不再运行了，可能他连触发器都没有了，那么他也一直存着，我们不用删留着。

好，还有 Factor in点sad requests，recovery，那么它的意思是那么你这个任务是不是可恢复的？如果说你应用程序有了一些问题，然后的话应用恢复以后，这个任务它是不是可以被恢复可以恢复。好，那么这就完了，最后返回fxb总之还并不难，主要是设置这么几个项就ok了。

好，然后我再来同样的方式设置这个水准，当然我首先需要实例化的，然后 Fact to be点儿sad，着得挺，你要设置一下崔哥儿他是对哪个照片做的处罚器，但是你传的要是传这个照片，其实就是这个参数，传进来其实就是它，你要知道就是我们的死人容器，将来我们如果任务多了， job得就发特病，它有很多个实例，或者说 job detail它有多个实例，怎么区分呢？

可以通过名字来区分这个病的名字叫阿尔法jopp dio，我这个参数名叫阿尔法jopp，ditto GB同名，那么是不是会优先把同名的给我注入进来？所以这两个字保持一致，以避免说你实例多的时候它有冲突，名字要对应。好，先传入这个照片，又然后再拿三个病叫赛内，你要给你的崔哥取个名字，这个我叫阿尔法sugar，好，再来发出了病点sat group，我要给崔哥取一个组名，我叫阿尔法崔哥。

就是说这一组好再来 Fact就是been点sat，repeat。Intel就是频率，你多长时间要执行一遍这个任务，我写3000毫秒，就是每三秒我要执行一遍，再来虽然并点赛，知道吧？ Data map。New job data map。好，这是什么？就是说崔克它的底层需要存储照顾的一些状态，你用哪个对象来存，你要指定这个对象，然后我就初始化了一个默认的类型，但是你可以自己去写一个新的类型，这里我是默认的就可以了，你就往这里存状的状态。

好最终委托人f2b完了现在我就把 Dropped ill和崔哥也配好了。那么我们使用class的要写的这三个方面就写完了，一个是任务，一个是任务的详情，一个是处罚器就配好了。

配好以后，那么只要我一启动服务服务启动以后，那么因为配置文件默认就会被加载，一旦被加载到以后，那么科尔就会根据这两项配置往数据库里插入数据，数据库里一旦有了数据，那么科尔的底层的调度器是盖德伦，他就会根据这里面的数据去进行调度，三秒三秒就调一次，下面我们就执行一下看看，我就不去执行一个测试方法了，我就执行我们正式的项目，看一下控台，你看是不是？

他已经在执行了，在启动过程中他已经在执行了。你看sq的 Class job这个job就被执行了，每三秒一次，然后每次都是有一个线程在执行，那么这个是线程的名字，34、567这样的。

好，当然了就是筷子它的底层也是依赖于线程池的，然后它线程池有一个默认的配置，那么如果说你想去做干预，你想去主动的把它底层的线程值再进行一个重新的配置也是可以的。

我们需要在 application process里进行一个配置，那么这项配置会比较长，会比较长，那么这样我就不去手写了，我直接从以前的项目把它拷过来，咱们看一下，都已经准备好了。

这一段这么长我就不挨个写了，拷过来以后我们大概再看一遍，拷到配置文件里。

在这它的类对应的类是 quite practice，大概看一下，那么这个是什么？是这个任务它存储的方式它是用jdbc来存的，它底层用的是jdbc然后这个是sky的name，那就是你这个调度任务的调度任务，调度器的名字，佛教community是该做的，再一个它是该得了点instant idea，就是你调度调度器它 Id自动生成，然后 drop style。

这个我们任务在存到数据库里的时候，你是用哪个类来做这件事儿，是这个类。

然后你在存的时候用不用gdpc驱动是什么？驱动，然后的话你是不是采用集群的方式？是的，然后的话你用哪个线程池线程池，这是快RS底层带的一个线程池，然后它的线程数量我写成刚才你看它 Id都已经到10了，线程太多了，我们用不了那么多，写成5就可以了。

当然如果我们刚才没配的话，它也起作用说明什么？死不认不得，对它做了默认的配置，你这样的话能够覆盖到配置，按照你的想法去配，这样也是比较好的。

好，改完以后我们先不着急再运行，我们去看一下这个表里的数据看有没有变化。

我先看这个detail，那么这个detail你看没有数据，你看崔哥估计也没有数据，为什么刚才其实我说的有点漏洞，如果说我们没有做 Process这项配置，那么我们启动服务以后，那么care的是读取内存中的配置来执行这个任务的。

那么一旦我们做了这样的配置，我要求要把任务持久化到数据库里，这个时候它才会把数据存到数据库里，默认的话它是读取内存的，刚才说错了。

好，那么我们做了配比以后，那么再去执行的话，它会把配置信息存到数据库里，我们要的是这样的一个效果，否则的话我们分布式部署就会有问题了，像这样一种方式，其实分布式部署就会有问题。好我就再执行一遍，你看它又在运行是吧？然后每三秒运行一次，然后你这回去观察它线程的名3451。反正你多观察一会会发现它是不会超过5的，因为我们一共就要求他初始化5个线程，这就够了，就这样了。

然后我们再去看一下表里，看看这个数据有没有变化是吧？我们看一下这个点q你看这回就有了数据，因为我已经要求他把数据初始化到这个表里，然后你看调度器的名字是我们配的是吧？Job的名字是我们配的，主名我们配的，类名只我们写的对吧？然后这一代表true0代表false。我们这两个配了true就这样。

然后 simple triggers再查一下，有了数据就是调度器的名字崔哥的组以及后面的一些它执行时所产生的数据，这个是崔哥比较完整的信息，前面是类似的，后面的话它对应的状是什么？

然后的话这是上一次执行的时间，下一次执行的时间有一个记录，还有这个是状态，就是调度器的名字，调度器的一个实例的名字，然后的话他检查的时间，他上次什么时候检查的周期是什么，因为他要看一下你这个调度器是不是在正常的运行着，它要有一个检查，它是记录的是调度器的状态，然后 Locks锁，那么一个是状态的，一个是崔哥的锁，就是说他在检查的时候，他在枷锁的时候，他是对这个状态表加锁，对崔格表加锁，那么锁的名字是这样的，在这里进行了声明。

好我这里我就不想让它再继续运行下去了，我先关了。并且我希望以后我在启动服务的时候，他也别去输出这句话了，因为这句话没有什么逻辑对吧？每次就这么频繁的输出也挺烦的，但是现在你注意这个数据已经进这个表了，只要你一启动服务，它一读这个表有数据它就会运行怎么办？

两种办法，一个是你手动把这个表里数据删掉，还有一个你写一个测试的程序，然后的话调他的schedule，然后把这个任务删掉。我们还是写程序方便，因为写程序的话一句话他能把好几个表的数据都给删掉。

另外我们也知道一下我们删除任务的API是啥，所以我在这个测试类当中我再新建一个测试类，新建一个测试类，结果叫class tests，但是我也需要写上那么几个注解。

好，然后我要删除一个照的，我是要通过他的调度器去做这样的事情，我需要把这个调度器呢注入到当前的便利调度器，就叫schedule了，刚才我们说了。好，然后我写一个测试方法，在这个测试方法里我要删掉刚才的我们用来测试的job，delete job其实很简单，就是schedule，delete job。

然后得力的时候，它需要传一个就是job的key， Job的唯一索引，它需要传一个对象进来，比如说你有一个 job key，这个job key有两个数据构成，一个是job名字，一个是组名， job的名字我们叫阿尔法job。好，然后组名我叫阿尔法show up。Grow。那么由这两个名字能够唯一的确定一个job，它是job的key。当然了我们这句话我们需要传开始，然后这句话它会返回一个布尔值，告诉你是成功还是失败，我接受一下结果，然后我把伪造上的打印看一下。

好，这就写完了，写完以后我执行一下看看。出成功了成功以后，我们去看一下这个表，你看这个缺口没了。没了。是对的。还在，因为这里边存的不是做，这里面存的是sky的人，调度器还是有的 Log。这个还在，因为它也是存在是调度器有关的数据，但是 job以及trigger没有了。

好，当然如果你现在你再启动服务，其实还会有，为什么呢？因为肯费岗他又会执行一遍，又会生成数据，我希望不要再执行了，演示过就算了，我把 b给它去掉，你这样你再启动的时候，这两个病就不会被初始化，不会生成数据就不会被调度，然后配置类保留，因为以后我们解决项目中实际的问题的时候，这个类还还可以再加其他的内容。

那么我们在学习的时候就是执行过一遍测试程序就可以了。好了，那么这节课我们关于任务执行和调度就介绍完了，那么大家课后一定要对线程池多做一些了解，然后对 class你也要掌握它的使用方式。好，这次课我们就演示到这里，咱们下次课再见。