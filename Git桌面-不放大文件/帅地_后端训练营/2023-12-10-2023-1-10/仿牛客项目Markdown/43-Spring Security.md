43-Spring Security.mp4

到目前为止。

我们已经把牛客社区的主要的功能都开发完了。那么这一章我们主要是对牛客社区的项目进行一些补充，进行一些完善。那么我们完善的内容主要是集中在两个方面，一个是我们要提高系统的安全性，再一个是我们要进一步的提高我们系统的性能，主要是集中在这两个方面，这两个方面也是你去面试找工作的时候面试官非常关注的。

好，那么我们第一节就是要解决安全性的问题，那么我要学的是spring surprising，那么security就是安全的意思， spring security就是spring为安全提供的这么一个模块。

好，我们先来了解一下 space quality，那么它是一个专注于 Java应用程序，提供身份认证和授权的框架。然后它的强大之处在于它可以轻松地扩展，以满足自定义的需求，就是说怎么说这个框架本身功能很强大，其次它又很方便与扩展又很灵活，所以说。

它。

能够满足我们应用的方方面面的安全性的需要。

甚至来说如果说你用spring cloud去做微服务开发的话，那么surprise在微服务当中也能够发挥很强大的作用，总之它能够提供一个非常全面和完善的这么一个解决方案。那么它的特点有这么几点，第一个它能够对用户身份的进行认证和授权，提供全面的可扩展的支持。

你注意我们对整个系统提供安全性的保障，其实主要的一方面就是管理系统的用户的权限，而管理用户权限其实主要就是集中在两方面，不管是什么框架，都是从这两方面入手，一个就是认证，一个就是授权。

那么所谓的认证就是判断用户你有没有登录，如果你没有登录，你根本就不可能让你去访问，像私信发帖这样的功能，这是第一个层面。

第二个层面是授权，那是认证以后要进一步判断你有没有访问功能的权限。你比如说我们将来要做一个功能，给帖子置顶加精，甚至是删除，那不是说你每个用户登录以后都能做这样的事情，你需要有管理员或者是版主这样的高级别的权限，你才能做这样的事情。

第二个环节授权是判断用户有没有访问当前功能的权限。好，那么 Spring security从这两方面它都能够提供很好的支持，除此以外它还能够防止各种攻击，比如说固定攻击，点击劫持，什么csrf等等，所以说能够保证我们系统避免被攻击。

第三个它能够和外部开发相关的技术很方便的集成，比如说server类的API其实就是Java ee或者是是 spring mvc当然其他的外部开发技术其实也可以集成，当然了我们的课程用的是 spring mvc，那么因为它都是 spring全家桶范围内的技术，所以说它们之间可以无缝的进行衔接。

然后 spring security它的手册你可以从官网上能够查阅的到，然后这里我就不在课上给大家去查阅了。关于 spring security，那么我们在学习之初需要大致的了解一下它的底层是靠什么样的一个思路去管理系统的权限，你要大致做一个了解，然后我们才好展开了后面的学习。当然了你在这个基础上你说我大致也了解了，然后后面的案例我也搞明白了，我会用了。那么你在这个基础上你再去阅读一些技术资料，然后把它搞得更细，甚至你看一些源码，跟踪一些源码，把它搞得更细，那就更好了。

好，那么我在课上给大家演示一下，讲解一下 spring security它底层的一个大概的一个机制。这我需要画一个图给你做一个首先我先不说色块的，我们先说 surprise mvc，大家都知道spring mvc它的核心是什么，是不是叫做dispatcher，salade，这个是spring mvc的核心组件，那么所有的请求都是要提交给他进行统一的处理，然后他会把请求分发给一个的控制器，然后具体用某一个控制器处理这个请求。

我们一个应用当中只有一个SUV类的，但是却可以有多个控制器。我们先理一下我们当前CMV当中的这些个核心组件他们之间的一个关系，那么很显然 dispatch和 Ctrl之间是一个一对多的关系，这里我花三个表示多个就这样一个意思，把请求可以分发给他。

那么在请求分发给CTRL的过程当中，那么还有一个组件能够起到作用，就是拦截器intercept，那么拦截器可以拦截访问CTRL的请求 intercept，好，然后拦截器也可以有多个也可以自定义，所以 despite和 intercept和control它们之间的关系就比较清楚了。

那么 dispatch分发请求在分发的过程中可以被拦截器拦截到最终是把请求分发给CTRL处理。

好，那么整个这些组件构成了spring mvc的一个底层的核心，我把它框起来，这些内容是spring mvc的内容，我来标注一下。好，这是spring mvc有关的内容，然后你要注意 Controller和 intercept这完全是使用mvc这个框架，它所封装的它所提出的一种理念，这是super mvc的特有的组件，但是 dispatch servlet你注意它是组件是满足 Java ee的规范， Jarvi的规范中有关于serve的要求。

那么dispatcher serval eyot是一个具体的 servlet接口的实现类，就是说Java ee它提供了提出了规范是一个serverlet接口，那么dispatch solve的满足规范，它实现了接口，所以它其实一个它是死人mvc的核心，再一个它是满足Java ee的规范的。

我。

把它变成蓝色，就表示它具有一个一定的特殊性，然后 Jarvi的规范不只是 caelate，还有一个组件也是Jarvi的标准，或者说也是一个比较核心的组件叫filter过滤器。

那么过滤器它和dispatch之间的关系，就好比是拦截器和CTRL之间的关系拦截器，可以拦截对comptroller的访问，那么philter可以拦截对servlet的方法，但是他 philter和spring mvc其实没有直接关系，她是Jarvi的标准，那么同就跟这个一样 filter也可以有多个每一个filter可以解决一个问题，一方面的问题。

所以实际上我们在开发的时候，无论你是用surprise还是用查IE，那么你其实都可以利用 filter对dispatch进行对 service进行拦截。

好了。

那么。

注意蓝色的部分是Java意义的规范，我们先强调一下把它标注一下。这个我把它标成蓝色，通过颜色你要知道不同的组件它归属于哪一个规范，然后 spring security它在底层要统一的利利用统一的机制去处理系统的权限，它是怎么做的？

其实它是利用了 filter，它是利用了 Java e的规范 filter组件，而且它的底层有很多个filter，具体来说其实应该。

大概是11个filter，比如说有1个filter专门用来验证账号密码对不对？是做这个认证的操作的。

然后有一个菲斯特只专门做退出操作的，有一个filter是专门把你认证的，结果你的权限加以存储的，然后还有的filter是做一些其他的事情，总之每一个filter做一件事，它的底层都是通过 Filter对整个请求加以拦截，然后实现权限管理。

好了，所以说 surprise它对。权限的控制，它这个是比较靠前的，如果说你没有权限或者你没有登录，你压根都访问不了despatcher serverlet，更别说CTRL了。

所以说它。

判断的时机特别靠前，比拦截器比肯德基都靠前，大家要了解这一点。

然后后面当然有同学说我没有具体去接触过 filter，我不知道怎么写，后面我们会有这个代码给你演示说我们怎么写一个filter，我们怎么自定义一个filter，我们解决我们自己特定的问题，这也是可以的。我们会有演示。再一个如果你想深入的去研究 security，那么你就得多去研究它的这些个标准，有人说我有必要去研究吗？其实我觉得还是蛮有必要的，因为什么？ Spring security可以这么说，它是spring所有模块当中最复杂的一个模块。

当然这个复杂不是体现在应用上，我们在使用的时候其实很简单的并不复杂，但是我们在学习的时候，它的底层的机制，这11个filter你是很难一下子把它都吸收的，概念一下子太多了，你记不住，而且它们之间的调用关系对吧？

也是错综复杂，你一下可能不是那么容易能够把它吃得透，所以如果说你有精力把SQL研究透了，其实但你把整个spring其实也就很容易就能搞透，为什么？

因为square的是管理整个系统的，它和其他的组件之间是有一些关系的，他是管理其他的组件的，相当于你把它搞明白了，其他的组件也能够加深你对他们的理解。所以说怎么说你课后自己再多去研究一下色块的，我觉得是一件很好的事情，对你就业的话应该是有帮助的。好，这是它大概的原理。

有同学说如果说我想深入研究怎么办？你就是买书的话，还没有说专门一本书专门去写SQL的，有的话也是一些英文的中文的几乎没有，然后的话你去看 Spring的官网，当然它有解释，但是官网的解释一个是它是英文的，如果你英文水平不好的话，看着也费劲。

第二个官网上只是就着这个技术进行一个必要的解释，他没有一个系统的案例去穿插的讲解，说这个东西到底应该是怎么用，然后有些源码是怎么回事，他它是点到为止的，所以说如果我想研究的更透一点，对源码有一个更必要的了解，对它应用有一个加深的了解，我从哪去看这个内容我给大家推荐一个网站，这个网站叫spring for all其他的话其实倒无所谓，主要是 spring secrete，因为它比较难，所以说你去找相关的技术文章，这个质量是参差不齐的，我去找过很多这样的文章，最后我发现就这个网站 spring色块的模块，它提供了一些文章，质量是非常高的，所以你可以去阅读这些文章，有入门级的，然后的话还有源码级的，你把这些好好读一读，然后自己。去一跟源码，不用每一个都跟那几个核心的feel你好好看一看，那么整个死人死快的，你对它的理解就到位了。

这么一个难的模块你能把它吃透了，那么其他的就好办了，面试的时候你也就有了一定的心理的优势好了。

那么 spring security它的大致的原理以及你参考的一些文章，我就介绍到这儿。下面主要是给大家演示示例，给你看一下这个技术我们怎么去应用。然后这个事例我这样，我并不是直接在我们之前的牛客社区项目上直接去引入 Security，为啥你直接一引入，他立马就会产生效果，他立刻就会对整个系统进行权限的控制，他立刻就会接管你这个登录和退出，然后的话你搞不好搞乱了。

这个连我们。

正常的功能都访问不了了，因为被他拦截了。

所以说这个比较怎么说。

他管理的范围比较大，涉及的面比较广，咱们还是要慎重。再一个你看我们现在的这个项目，它的代码越来越多了，代码实际上已经很多了，然后我们这个代码本来就多，我们再引入一个比较难的东西，难于学习的东西引入进来以后，哪些是我们新学的内容，新的代码，哪些是重点，它淹没在了这些代码当中去，你你抓不住重点了，就更乱套了。

所以为了你更容易学习技术怎么办？那么我给你准备了一个demo级别的项目，当然这个项目也是对我们游客社区的一个简化到不能再简的程度，只保留了几个必要的功能，而且是简单的一个模拟实现，我让这个代码尽可量的少，然后这个代码现在还没有加入 Secret，然后我给你看一下这个小demo是怎么回事，有什么功能，然后我在简单的代码基础上给你演示secret，你一目了然就知道哪一块是我们新学的内容，哪块是重点，这样的话便于你去理解 secret。

然后我们学完这个色块的基本的应用以后，把它消化了以后，我们再将它引入到我们项目中去，解决我们项目中的问题，而解决的时候，我们可能会有一些变通，有些地方我们可能就省略了，有些地方甚至我们就把它忽略掉了，也有这样的可能。

好了，首先给大家看一下我这个简化以后的demo，当然你现在还没有这个demo，你别着急，这次课课后的资料里就会传 demo，那么你在课后练习的时候，你就引入我 demo，在这个基础上去开发色块的案例就可以了。

这个demo非常简单，你看首先这个数据访问层我只保留了一个user map，里边就一个方法select by name，然后有对应的 use map，xml文件，这就是我们之前项目的一个简化，对吧？没什么好说的，一看就懂就是dao层数据访问层，然后业务层我只保留了一个user service，里边就一个方法放在user白内容。

当然我为什么要保留这样一个方法，因为它跟这个登录有关系，你登录的时候不是要调这样的方法对吧？

而我们权限管理要管理的一个方面就是认证判断你登没登陆要用到这个东西，这是you do service，另外表现层我就保留了一个controller，我是把所有请求都放到这一个controller里，你看有什么访问首页，index访问，帖子 discus访问，私信lighter，还有一个访问管理员的专属的功能to me。

当然还有一个我们打开登录页面的功能 log in配置，就这么几个方法。

然后我们看一下这些方法对应的页面，你看这个是首页，这首页我也精简了，就保留了一个标题，然后几个链接能链到其他的网页上去就完了。然后除了首页以外还有帖子页面，我就一个标题，你知道它是帖子页面就可以了，都不需要显示内容。

然后私信也是一句话，然后登录当然登录有个表单了，但是这个登录我们这个表单提交到哪去，这个还没实现，我们是用security来接管，请求用security来实现这个认证，所以我还没有写。

然后还有一个ADMIN，管理员专属页面也是啥都没有，反正就是一个标志完了。好，这就是我整个项目的全部非常的精简，一看就能看得懂。然后当然还有错误页面，404 500我们后面也会有用，好就这样了。

接下来我这样我给大家跑一下，目前的配好了能够直接运行起来，好我启动一下服务，启动以后，那么我来访问一下首页也是community index，首页就这么几个链接，能够练到帖子详情页面，回去能够练到信息列表，回去能够练到登录页面填数据，然后能够一退出就退到了登录页面。

除此以外还有一个隐含的路径，这里面没有列出来，叫阿德妹能够访问管理员专属页面，就这样。

然后现在这个系统是有残缺的，你看我没有登录，我居然能访问帖子详情页面，我居然能够这个访帖的详情页当然可以没登录也可以访问，但是我居然能访问信息列表，这也是不应该的，对吧？你得登录以后才能访问。

再一个我还可以访问，好的命这个是不应该的，即便是我用普通用户登录了，我也不应该访问我的命，我必须得用管理员身份登录才能访问到它对吧？应该是这样的一个逻辑，目前我们整个权限都没有做管理，登录的认证也没有去处理。

那么下面我就用security来解决这方面的问题，给你演示一下，那么我们使用SQL的第一步，肯定是要倒包的对吧？我去搜一下这个包，我打已经打开了，这个没问题，抛弃的人，我搜包spring。Boot。 Secret就是然后点进去选一个版本，然后 Copy。好，那么我把它粘贴到后面的xm二当中去，然后这样我把这个版本去掉，因为负泡沫中已经声明了版本，它声明的是哪一个我就用哪一个。这个得稍等，他需要下载一下，稍等。

好看底下滚动条走完了，说明下载完了好。

那么下载完以后，就是说我们只要做这一步，我们只要导入 surprise包，它立刻就会产生一个效果，它立刻就会对我们整个系统做一个安全的保障，做一个权限的控制好。

我们可以试一下，我把这个项目重启一下，启动完以后我再打开首页，然后刷新一下。

你看一刷新 secret，一看你没登录，他立刻就给你一个登录页面，这登录页面是它自带的，当然我们也可以用我们自己的登录页面去替换它，但它默认我们还没有写代码，所以他就是用他自己的有人说用账号密码是什么，他默认在内存里给你生成了一个账号密码，你看这个日志里就有这么一句话说生成了一个安全的密码，这么长的一个字符串，账号就叫user，我们可以利用这个账号密码登录一下，看看 user密码套进来登录，然后你就可以访问这些功能了，他这个账号权限很高，什么都能访问，就这样。

那就是说我们只要一引入secret包，立刻权限控制就生效。

当然了，这只是说明他管理的面比较宽，但是我们不能这样用，我们不可能说用他给我们生成了一个随机的账号密码，随机的密码，这也太复杂了，这样一个也不可能所有人都用这么同一个密码，这个只是说只是说它的一个入门级别的一个事例，我们怎么去把它的登录页面换成我们自己的，我们怎么去利用我们自己数据库里的账号密码去做登录，然后去做认证的，接下来就给你做一个更详尽的演示，我先把这个服务关了。

好，那么我们开发的时候，首先我们是开发业务层，我们想做认证，我们想做授权，那么我们需要在业务层做一些处理，或者说业务层或者以及数据访问层，首先我要处理的是 user实体类，为什么要处理它就是说我们在做授权的时候，当前的user具备哪些权限，你怎么体现？

其实。

每每个应用它是一个权限的体现不一样，稍微复杂一点的可能是会有一个单独的这么一个角色表以及权限表。

 User关联了角色，再关联到权限，他们之间是一个多对多的关系，一个用户有多个角色，一个角色有多个权限，经过一系列的关联用户就有多个权限可以这样去设计。

当然你学数据库的时候可能也学过这方面的知识，然后我们应用权限设计比简单一点，一般互联网应用的权限可能就没有那么复杂，我们的权限非常简单，主要体现在 user的type字段上。 Tab字段是啥意思？

咱们再回顾一下，我们看一下优则表，建表的脚本，tab你看零代表普通用户就具备普通用户权限，这就是权限的意思，一代表的是超级管理员，二代表的是版主。我们 tap这个字段就表示说当前用户具备哪些权限了，当然我们这个比较简单，就一个用户只能有一类权限，比较简单。好，但是我们将来在用security做授权的时候，那么我们要的不是这个态度，我们要的是一个字符串，这个字符串能够明确表达你的权限的含义，所以我们需要这个定义出来这样的字符串。

好，那怎么去做？我们通常是这样做的，当然这个做法不是说唯一的，我们通常是这样的，我通常是让 User实体类实现一个接口叫做user details，这是secret一个标准的方式，实现 user对tos接口，那么这个接口中规定了一些方法，我们需要去进行实现，我在后面去写。

好，那么第一个是这个方法，account，net x zero Excel的这个方法的意思是什么？就是说如果你返回处，返回处的意思是表示说账号没有过期，你返回false就账号过期了，这个意思这里我们要返回数，账号不过期就是我们认证的账号默认不做过期的处理好。

然后第二个还要处理 Is the count not。那么这个我们通常也返回输入的意思指的是账号为锁定。好，然后还有一个方法叫做is credit sales。 Excel。那么这个方法我们通常也返回处的，它的意思是凭证未过期，凭证就是我们认证的一个结果，你登录成功的一个结果。

好，然后还有一个是is enable，通常也是返回出，反馈数它的意思是账号可用，如果你返回force你就不可用。总之我们在实现接口的时候，基本上这4个方法都把它设置为数就可以了。好，当然了可能有一些极端的情况，你需要再把它设置为force，我们这里都没有提供赛的方法，不需要我们就都是处然后还有一个更为关键的方法需要去实现叫get authorities Authority就是权限的意思。

那就是说这个用户他所具备的权限你要返回回去，然后因为一个用户可能有多个权限，所以返回的是一个集合，然后 grant的office是一个一个父类，那么我们集合中装可以装父类的，这是一个接口去装它一个实现类就行了。当然我们我们这个权限比较简单，我们是一个用户只有一个权限，所以说即便是一个集合，我们这里也是只存一个数据。

我就这样我就先声明一个集合 granted Australia release最终我就返回集合，集合里我只装一个权限，每个用户只有一个权限，我们这里 ID然后我要实现接口， new做一个默认的实现 grant authority实现它，要求它里面带的一个方法叫get authority。

那么每一个grant authority里边，通过这个方法来封装一个权限，多个grand or city就是代表多个权限，我们这里只加一个唯一的权限，这个权限刚才我们也看表了，我们是通过tap去判断的，你不同的tap应该返回不同的权限的，就权限的名字，所以我们需要对态的进行判断，我这样判断，因为它是一个整数，我switch态度好，然后 case如果是一一代表的是超级管理员，当然了我们一共有其实有三个，一个是零普通，一个是一管理员，一个是2版主。

我们现在先不考虑那么多，我们现在只管两个，假设我们这个系统里只有两个，一个是0普通的，一个是一管理员 TC一，管理员我就委托一个字符串，咱们。表示管理员的意思，好，然后 default，否则我就return普通用户，user好就完了，这个return now不需要，因为我这里已经返回了这个数据，现在这个接口就实现了，那么如果说我现在得到了user对象，我调用这个方法就能知道 user对象它是奥特曼还是普通的用户，我就知道他有什么权限，我就可以给他去做授权相关的操作了，所以这是一个基本的准备的工作。

准备好了，准备好以后，然后下一步我们是还要做一件事，也是一个准备，我们需要在这个user service里让 user service实现一个接口，通常是这么做，如果你不让它实现，让别的组件实现也未尝不可。

但通常都是这样的优点，实现优点对TS service，那么这个接口只有一个方法，需要我们实现添加，它需要我们实现的方法，这个方法叫漏的user by user name，它的方它的含义其实和这个一样，就这个接口要求我们提供一个方法是根据用户名查用户这个方法的实现，其实我们完全可以调find use by name对吧？

所以说我这里就直接return历史点，find user by name，然后当然它这个参数 s应该就是user name，我稍微改一下，直观一点就可以了。

好，那么这个接口是 Siri的底层的一个接口，那么Siri在做认证的时候，在检查你是否登录，检查你的登录的情况的时候，它需要用到这个接口，因为你想我们自己去实现登录的时候，你不也是要用这样的方法吗？Find my name对吧？我根据你传入的you的name去查一下，如果查到了数据，这说明内部对了，我再去判断是吧，就是这个逻辑，因此色块的底层它能够自动帮我们判断账号密码对不对？

它需要依赖于接口，所以说它需要我们提供这样一个接口的实现，我们就这样就实现了。

之所以在youth service上实现这个接口，是因为因为这service里有这么一个方法，只不过名字不一样对吧？我们稍微调一下就ok了，这样方便最方便好了。那么这两个就是 User和 user service这两个接口都实现完以后，那么我们基本的准备工作就已经准备好了，准备好以后，下面我们就需要利用色块条对我们整个系统进行认证以及授权。

怎么做色块的，它并不需要我们去什么帖子私信那些个组件上去挨个处理，其实它底层也是基于它底下是基于filter的去拦截，能拦截很多个大量的请求。

所以说。

我们只需要写在一个类当中，就能够解决所有的需求。

这个也就是 surprise快的配置类，在这里去做相关的一个配置相关的处理。

下面我就写来写色块的配置类，那么我在肯包下新建一个类，我取名叫secret，当然因为它是一个配置类，所以我需要加上注解，configuration。

另外 SQL的配置类有一个要求，继承于web security can figure adapt，我们继承于父类，然后重写他的一些方法，就能够解决一些问题，这样就可以了。那么在这个类当中，首先我要注入的是user service组件，为啥？因为组件实现了user detail service接口，而这个是这块底层要依赖的，所以我把组件注入进来。

好，然后父类我们在配的时候通常要重写它的三个方法，这三个方法都叫肯德基参数不一样，然后我先重写，它的参数是web security， Web security重写的时候，我们这里这个方法比较简单，一般都写一句话，on the web ignoring，然后第二 and matches，然后里边写上什么，我们通常这样写。

那么这个ignore是忽略的意思，然后这里是路径，风格的路径，你看我忽略的是什么？路径下的资源是属于SARS下，星星表示所有的资源，我们知道resource下我们放的是什么，它不是Java，它是一些静态资源，其实主要的是 static，还有主要是 static，主要是图片、 GS、文件 css那么这些资源我们在我们其实也可以再直接写一个HTTP的请求去访问他，对于这样的请求我们需要这块的对它进行拦截吗？

需要用filter。对。那些请求做拦截，当然不需要，因为静态资源对吧，没有什么可保密的，随便访问随时访问，所以把它忽略掉。这个意思是为了提高性能，这里写的注释就是忽略静态资源的访问，那么这个方法主要是干这个事，其他的基本上就不用动了。好，这是第一个我们需要重写的地方。好。第二个还是要重写另外的一个肯飞的方法，然后这个方法是带这个参数叫奥森tkc manager，builder比较长，我们重写这个方法。

好，我直接就重写这个方法的逻辑了，这个方法其实是做什么？这个方法内部。

主要是做认证，咱们权限管理主两两个方面，一个是认证，一个是授权，这个方法主要是对认证进行一个处理。

那么我在写这个方法之前，介绍一下这个方法所涉及的一些核心的组件，首先有一个组件叫做奥森t cation Manager，有这么一个组件叫奥森tk是manager，这个组件它是一个接口，它是认证的核心接口，是认证的核心接口，我们这个参数叫奥森tk是manager，builder，这个builder是一个工具类用来构造接口的实例的。

好，那么这里写一条， builder它是用于构建 manager接口，构建LCD跟manager对象的工具。好，这里为什么要写？因为一会你就知道了，它的底层用到的组件比较多，很容易就混淆了，所以写清楚注释便于你课后的理解。

好，另外因为它是一个结果，它肯定有实现类，那么它比较常见的或者说默认的时间内是谁，你得知道叫做 provider。Manager这个类它是奥森tk是manager，接口的默认实现类默认会用它的，就是说标点默认构造的是这样一个类型的数据。

好，那么我们在这个方法内部，我们怎么去做这个认证？其实只要进行配置就可以默认不用我们自己去写认证的逻辑，它会帮我们实现，但我们需要提供一些配置。

好，那么我们需要这样写，这叫内置的认证规则，就是我们调查默认的认证规则，这样去做。 Os调接口调标点，然后点 user detail service，然后把user service传输进来，为什么要这样做？因为它底层帮你去做认证，它需要得跳这个接口，他才能够根据账号查出优质这个数据才能判断你登录的对不对，对吧？它底层需要依赖这个接口才能做查询。

另外我们通常还会这样写点pass word，encoder，然后里面实例传一个传一个pass word，include的实例就是对密码进行编码的一个组件。

对密码接口有好多个默认实现类，比如说我用 New叫Pb kd，然后 to pass word，include它里边需要传一个，我随便写12345这个就是一个加密工具，这个是盐，那么它会把你传入的密码带上言之后进行一个加密，你看我们去登录的时候不也是这样做吗？我们需要对密码进行加密吗？对吧？所以说只要我们提供了 detail service，提供了加密工具，那么它底层就能够自动帮我们去做一个登录的认证。

当然了默认的规则跟我们当前的优则表，我们当前的数据的形态不匹配，主要是我们的加密的组件，不是我们之前用的不是对吧？而且我们是每条user数据，每一条user它都有一个自己的sound，往往是不一样的，是吧？不是说一个固定的sound，所以这个逻辑虽然说能够解决问题，但是和我们目前的系统的现状不匹配，所以说我是给你演示一下可以这样做。

如果你是开发一个新的系统，基于这样去设计是可以的，但是我们现在系统已经开发到这种程度了，和它不匹配，我就不用这种方式了。

如果说我们系统这个数据的形态和它不匹配，我们有没有什么别的办法能够处理当然是可以的，我们可以自定义这个认证规则，就不用他默认的规则了，只不过稍微麻烦一点，而且我们自定义认证规则的话，我们还需要了解更多的组件，我先把自定义认证规则的这个代码的基本结构先给你写一下，然后我来解释组件的含义，20点also take action，然后的话 provider这里边我们通常这样写，new authentication provider好了，那么这基本上就是这样一个结构，我们需要给标的对象传入一个什么？

传入一个奥森tkc provider这么一个组件，在组件这是一个接口，在接口里实现一些逻辑，那么才能够自定义我们的认证规则。

好，你看这里又涉及一个新的组件叫奥森德克森特为的这是个什么东西？解释一下，就是我们刚才所说的所谓的manager它不是认证的核心的实现类， Provide manager它和奥森也可以跟provide有关系， provide manager他持有一组 authentication，provide而且每一个奥森txt，负责一种认证好，现在概念多了起来，逐渐多了起来，而且你会发现这些组件它的名字稍微都比较激进，比较相似，很容易就搞混淆，所以说这一课估计你课后还得再反复再看个一两遍，把这个概念把它理顺了，可能就好了。

是这样的， provider其实它里头有一个集合，它在集合里装了多个奥森特克森普瑞德，然后就是说是这样，这个普瑞的manager他不直接自己去做认证，它里边包含了一组组件，然后让组件去做认证，而每一个这样的组件负责一种认证，为什么是这样的呢？

因为你知道我们登录的话，可不是说只有账号密码一种形式，我们通过账号密码可以登录，可能我们通过第三方微信 QQ也可以登录，甚至我们少个指纹也可以登录，我们刷个脸也可以登录，是不是？我们现在这种登录的形态是非常的多样化的，扫个码也可以登录，有多样化的，不只是一种方式。

那么他这样做的目的是为了能够把所有的这种登录的模式都能够兼容了。

因此我们再回顾一下所谓的manager，他并不去自己亲自去做认证，而是它包含了这么多organization provider，每一个organization provider负责一种认证，你负责账号密码认证，他负责微信认证，他负责什么认证，是这样的一个逻辑。好，这在设计模式上叫做委托模式，这是满足了一种委托模式。

好，解释一下，也就是说所谓的manager，它是将认证委托给了organization to read。好，那么我们当前的游客社区的外网应用，我们采用什么认证？我们只有一种认证方式，账号密码认证，所以我们需要传入一个账号密码认证的这么一个 provide。

所以我们这里实例化的一个奥森dkc provider，那么在这里我们实现了一个账号密码认证的模式，这个意思好了，这里我们还需要实现这个接口，目前还没实现，那么实现这个接口之前，我们还需要做一些必要的解释，那么首先你看这个方法它有一个参数叫authentication，你还得理解它authentication是个什么意思，奥森txt它用于封装认证信息的接口，它是用于封装认证信息的接口，什么是认证信息账号？

密码。

这就是认证信息，所以这个对象是用来封装账号密码的，对吧？我们需要从这个对象中得到账号密码，我才能进行认证，它是用来封装认证信息的接口，你注意不同的实现类代表不同类型的认证信息，这是一个接口。

你不同的实现类可以代表不同的认证类型的认证信息，比如说实现类代表的是账号密码认证，实际上代表的是QQ认证，微信认证等等，我们这里用的是账号密码认证，它里面封装的是账号密码的数据这样的。

好，然后还要注意这个地方。

那么你看这个方法，这里边这个叫奥森tk的方法，就是做认证的逻辑的，这里边我们写认证的逻辑，这个是个什么 Support，这个是个啥解释一下。这个方法指的是就是说你要返回我当前的接口，它支持的是哪种认证，它支持的是哪种认证类型，它体现的是我当前能够支持的认证类型。好，我们通常怎么写？我们通常这样写。Return Return。然后的话这样写user name，然后它是word also take action。Token点class，点e cos，然后的话 a class类型。

好，就是说如果说当前我们认证的时候类型认证结果是这样一个类型，那么我们就支持我们或者说我们当前的接口是对这种类型进行认证的，这个是啥东西还得解释一下这个东西。

它是它就是authentication接口的一个常用的时间内，它就是接口的一个时间内，它代表的是账号密码认证，所以我这里写克拉斯一口是他意思是我当前的接口，支持的是账号密码的验证的模式，而不是微信不是二维码，其他的内容是这个意思。

然后整个方法我再解释一下，整个方法所体现的是什么呢？它反映的是当前的奥森txt，当前的接口，支持哪种类型的认证，归根结底它支持的是这种类型的认证，支持的是账号密码的认证，好了，你看这个方法特别麻烦。关于一个小小的认证，他搞出了这么多个概念，这么多个组件，里边体现了很多种这个模式，为什么这么做？因为我们在使用的时候要想扩展性更好，更灵活，那么它底层就要做更多的设计，才能支持这种灵活性，所以它的底层就搞了这么多组这么多概念。

因此我们在初学这个词块的时候，主要是往往容易被这些概念给弄晕了。那么当然你的学习可以有几种境界，第一个你可以说我先不去纠结这些概念的理解，我先把这个程序先写出来，先跑通了，大概了解了是这么做的，这是第一个层面。

第二个层面我再去细抠一抠，这个概念代表什么含义，把它理顺了，大概的理解透了。第三个层面我再去阅读一些手册文章，或者我自己跟一些代码把它搞得更透一点，那就更好了，就这样。

好，我们这个方法还没有实现完，继续怎么去做这个认证，这个就简单了，我们只要从这个对象里得到账号密码判断就可以了。有的service我们也有，说白了我们把之前我们log in中的逻辑搬到这里来就差不多了，好我就写了，首先我要请求的内容那就是错了。Authentication，然后点get name。这就是u的name，好，再来还得获取密码是吧？ Pass word等于 also education点。 Get返回的就是密码。不过它返回的默认不是死菌类型，我们需要转型一下。

好账号密码我就得到了，得到以后就判断，首先我去查一下用户存不存在，我就调 user service，点find user by name传入user name。然后当然了我们也可以我们详细的判断流程得判断一下，这个又在存不存在对吧？判断一下 Uzi有没有激活这里，我简化，因为我们重点不在于这段逻辑，我们重点在于整个secret，它的整个的流程大体的结构，这些细节我写的不那么细了，因为本身这就是一个demo。

好，我就写个判断为user，如果user等于not，那就意味着账号不对是吧？当我们判断登录不成功的时候怎么办？我们抛异常。后面有专门的philter能捕获到这个异常，对异常进行处理，所以整个色块的底层都是feal驱动的，我们只要抛异常就有人处理，我们需要抛的异常也有这个规定，因为是账号不对，所以我们需要抛的是user name，然后 not found exception。账号不存在这个提示。

好，那么接下来如果账号存在，那我就得判断密码，而判断密码之前密码得加密，因为我们库里存的都是加密后的密码，对吧？我就pass word就等于我们调工具类，工具类我也有看没有这些优秀点。

Md5把原始密码传进来，还要加上盐，那就从优点里获取 Get salt，原始密码加严之后做一个加密，MD5加密，得到了加密之后的密码，我们判断一下这个加密之后的密码，数据库里的密码是否一致就可以了。如果说user的get它是word，它 equals用户传入的password不等号，如果不等于的话表示密码不对对吧？那也得抛异常。

此肉牛就叫bad，就要credit so exception就credit soon的它表的是表示的是一种也是一种凭证，也是一种令牌，其实它代表的大概是密码的意思，但是它为什么不叫密码？还是那句话，因为你登录的时候未必是账号密码登录对吧？你可能是刷脸登录可能是指纹登录，所以你登录的时候密钥它未必是密码，所以说它用这样一个单词来代替，笼统的代替。

好，这里写密码无证据。好了，那么如果说密码也正确，最后return我要返回的是认证的结果，而这个认证结果我们需要用我们需要反馈的是什么呢？我们需要返回的是这个接口的实例，而我们当前支持的是这种类型的实例对吧？所以你得返回这么一个类型。Return new，然后优质内部pass word奥森的k神头肯 Talk里第一个参数我们要传入的是我们认证结果的主信息，通常它是奥布加克的类型，但我们通常传user。

第二个是传认证的一个凭证，我们通常是传密码或者是能够代替密码的那个东西，我们这里就是密码。

好，然后第三个我们要传的是当前用户的权限，你user的get authorities就能得到，这个不是我们已经实现了这个方法，对吧？

好，这里我解释一下这三个参数，它的你看这个它的代码，它第一个参数叫这么个名字object，第二层是叫这么个名字，好解释它的含义，刚才我虽然说了，但是怕你忘第一个 principle，他的意思是认证的主要信息，一般我们就存 user就完了。

然后第二个 credit service，通常我们这是证书的意思，证书的意思。那么在账号密码模式下，通常我们就传的是密码好。

然后第三个参数authorities它代表的含义是权限就没有歧义，悠着点get authorities。好，这样就可以了。那么当。

登录的时候，我们一点登录按钮，那么色块就能够捕获到请求，就能够拦截到这个请求，当他发现这是一个登录的请求，那么他就会调用这个接口这个方法去做登录认证，然后登录结认证结果会存到这个对象里，后面某些地方会用到，就是授权时会用到，是这样的。

好，那么关于认证的逻辑我们就处理完了，刚才这个方法是关于认证的逻辑，除了认证以外，别忘了还有授权的逻辑，整个权限管理核心的就是认证以及授权，那么还是要重写一个can figure方法，那么这个方法的参数叫HTTP这个时候我要给你看一下super中的代码的逻辑，它里面是有实际的逻辑的，好你看一下，当然它的逻辑比较长，大概看一下你看hgdp点，also all the right request。

点 any request是任何的请求，任意的请求，然后 all c austerity，Austin kitty。什么意思？大概的意思就是说我任何的请求都要启动认证，所以说你看我们只要以引入了security，那么 Can figure就这个配就默认配置文件它就生效了，然后这个方法就生效了，生效的时候它因为这段逻辑就生效了，就任何请求都要被权限控制，所以为什么我们引入了SQL以后，一访index一访任何一面他都逼着我们去登录，就是因为这个逻辑。

所以说如果你不想这样，你不想上来，就所有的请求都被都被判断怎么办？你把它覆盖掉。所以这里头你看我把这个super一去掉，那么父类的逻辑被我当前的配置文件给覆盖了，那么默认不是所有请求都要被处理掉，那么就不会出现这样的情况。

我们说白了我们就可以避开它默认的登录页面，我们通过这种方式避开它默认登录页面，我们的目的是找我们自己的登录页面对吧？我们怎么去找我们自己登录页面，也需要在这里进行配置，我们需要做登录相关的配置，你得告诉secret，那么我的登录页面是谁，那么我的登录表单是谁，或者我登录表单是我唯一提交的时候是哪个请求，好，能够请求它拦截到你登录的请求以后才能够调接口，他才能够获取账号密码，才能够调接口，然后调认证的逻辑是吧？

所以说这里你得告诉他一些关键的信息，这个怎么配呢？固定的模式是hgdp点form log in登录表单相关的配置，然后的话首先配通常我们会配log in配置，你要告诉他登录页面是谁好，我们登录页面是谁呢？看一下home CTRL是这个请求log in page。

好，那么我告诉他我的登录页面是log in page，然后还得告诉他我提交表单时处理登录的请求的路径是谁？他好去拦截这个路径，帮我们做认证，但是我们现在路径还没有，我这里提前配好 log in PRO session ul就是登录的处理的路径我叫老兵，那么一会儿我们表单上就必须配这个路径，它才能处理掉。

好，那么你配了这个路径以后，当我们一访问一发出这个请求的时候，它就拦截了，它就掉这个逻辑了。调这个逻辑以后，它最终在认证的过程中可能会成功，也可能会失败，而失败的表现是抛异常。我们怎么去处理？成功或失败有两种方式，一种方式是可以success for word URL我成功时跳转到某一个路径，这叫转发到某一个路径。

然后的话然后点 Failure发布的uil失败时候跳转到某个页面某个路径可以这么简单的处理，但是我们往往不是说我们跳过去就可以了，我们可能在成功时或失败时可能还要带一些数据，还要做一些特殊的处理，所以这样的方式比较局限，那么还有一种替代方案更灵活，比如说我可以这样写，success handle成功的处理器，那里边需要传一个接口，我们在接口里面自定义我们成功时处理的逻辑，这个接口是new奥森特kitchen success handler我们需要定义这个结果，类似的失败的时候也是这样 failure handler，然后的话这里边也是你有实例化一个失败者的接口，你有奥森特k选飞了，handler就是这样。

那么这个逻辑怎么定义？当然我们可能在实际的真实的项目里会稍微复杂一点，当前的demo我做的稍微简略一点，如果成功的话，我就跳转到首页，我就跳转到首页，我就可以这样写 Is bus，它参数名都搞得太长了，我就叫request，我就叫response，简短一点，这个也是一样。

好，那么成功的时候认证成功的时候，我就response点 send redirect，重定向到首页，我就request点get contact us。

获取项目名，然后的话加上首页的路径，index这就行了，那么失败的时候怎么办？我们失败的时候要回到登录页面对吧？并且给一个错误提示，回到登录页面给个错误提示。那么回到登录页面能不能用重定向的方式注意是不可以，因为如果我重定向到登录页面，那么重定向那么会让客户端发一个新的请求。既然客户端发了一个新的请求，请求变了，我怎么去向下一个请求传参不方便传？可能你只能用跨请求的组件qk section的去传，有点麻烦。

我们还有一种方式就是我可以把参数绑定到request里，然后把请求转发到登录页面上去，转发和城乡不一样转发是保持在一个请求之内，我们是可以通过request去绑定参数传参的。

当然转发到底是怎么回事，转发和成像到底有什么区别，我一会再详细来解释，我先写着我先往瑞快上绑定一个错误消息， sat开始的消息叫艾瑞，然后这个消息就是exception，是因为你失败的时候他传一个参数就是这个异常，你看失败的时候他把异常传进来了，其实就是我们之前抛的异常，这是异常的负接口。

我就直接把这个异常然后的消息发到那个页面上去，然后我要转发到登录页面，怎么转发呢？用request request点get request，dispatcher。我要转化的页面的路径是log in配置，然后点发word转发，把我当前的request response转过去，这样就可以了。

好了，那么到这儿我想解释一下这个转发到底是怎么回事。之前我们没有具体的解释过，而且转发合同对象其实很像，他们都是将让请求做了一个跳转，但是有一些微妙的差别，所以我们对比着来讲画个图。

好，首先我们先来回顾一下重庆相，因为我们相对熟悉一些，回顾一下重庆相，换个颜色我画的方块假设代表它是浏览器，然后我再画一个方块就代表服务器，那么重定向是这样的，就是浏览器有访问服务器，访问的是它里面的某一个组件，假设这是a组件，好，假设我服务器里有一个a组件，当前我浏览器访问就是a组件，那么有的时候访问a组件以后， A组件其实没有什么结果可以反馈给你，为什么没有结果可以反馈给你？

比如说我访问的是一个删除的功能，对吧？数据都删掉了，给你反馈什么结果呢？这个时候可能需要另外一个组件给浏览器显示一个显示一些内容，但组件和它没有直接关系，比如说这是删除，这是查询，删除以后我想回到查询页面，而删除和查询有直接关系吗？没有，它是两个独立的功能是吧？这种情况下我就适合用重定向两个独立组件，两个独立组件，我还想让它跳转，我就适合重定向，而不适合直接这样去调。

如果直接这样去调，a和b本来没有关系，就产生了关系，它俩就产生了耦合，这种方式是不好的。

而重立项可以降低额度，重定向之前我们也说了，他的意思是这样的，服务器给浏览器一个响应，告诉你说我没什么可以给你的，它的表现是我访问了一个302状态码，当然了除了302状态码以外，还包含了一个路径，说我建议你去访问它，那浏览器一看好吧，我就访问b然后 b会给他一个结果，展现 b的访问是浏览器自己去访问的和a其实没有关系，a只是给了一个建议而已， a和b之间没有直接发生关系，没有耦合度就这种方式是一种低耦合的方式去跳转，然后但这种方式也有一些小的问题说不是说问题，有一些地方不好处理，比如说我a还想给b带个数据，但通常不会的，假如说a想给b带个数据就不好带了，因为这是一个新的请求， request都被重置了，对吧？

你通过request没法去带数据，这是一个request，没法通过开始带数据，两个请求又想共用一份数据，你只能用cookie或session这样的，这是重庆项它的这种感觉。

我们再看这个转发好，还是浏览器和服务器之间的这么一个故事，还是比如说服务器有两个主键a和b好，那么比如说浏览器访问了a然后有一种场景是a它只能处理请求的一半，剩下一半需要由b来处理，需要a和b共同合作才能完成整个请求，这个时候a就可以把请求转发给b让b继续处理，然后由b给浏览器做一个最终的响应。

那么整个过程是一个请求，因为是一个请求之内，所以说a可以把数据存到request里，b能够取出来，他请求没有重置，他俩用的是一个request，a转发给b的时候，要把request response给b你继续处理，就是这个意思。然后还有一个差别是什么？

就重立项的时候，因为浏览器访问b的时候，他知道我要访问b他本来访问a的时候地址栏写的是a当他访问b的时候，他知道他要访问b地址栏就变成b了，而这个他访问a的时候，这里是a访问a然后由b给个结果，但浏览器不知道有b的存在，他还以为是a访问的结果，他不知道有b的存在，所以他的地址还是a的地址，这也是一个表现的情况，现状就总之如果说我服务端有两个组件，我想去跳转的话，你分析一下它俩之间是协作完成一个请求，有耦合，还是说是两个独立的功能？

没有耦合，如果没有耦合你就重新下。如果有耦合，如果是要共同完成一个请求，你就转发是这样的。有人说能不能举个转发的例子，其实我们之前没有用过，没有用过转发，这里我举个例子，比如说假设a的路径是 log in，然后 B的路径是log in page。你看 A是log in，比方说a是什么？ A是提交登录的表单，那么提交登录的表单有可能是我们在服务端一认证失败了，失败的时候我们就需要回到登录页面，那么而登录页面log in配置是另外的一个请求，那么它俩之间就可以产生依赖，因为我需要依赖于他，我自己怎么处理一半，另一半可以由他来处理，这个时候我们就可以不转发，就是我们刚才的场景，当然我们之前没这么做，我们也可以怎么着，我们也可以在里直接return一个登录页面模板，written login的html也可以，你转发给他也可以。

这有什么区别呢？就是说如果我在a里直接return登录页面登录模板相对于转发的话，转发的话是复用了这段程序，如果说log in配置请求方法当中还有别的逻辑，它能被复用，它这种方式其实优于直接return一个模板，总之两种方式都行，这只是一种方案，而我当前不得不用这个转发了，因为我当前是处于这么一个handler方法之内，它又不是CTRL的，我也没有办法return一个模板的路径，它也不能识别对吧？

所以我这里我只能转发了，迫不得已就这样好了，你看我现在把登录相关的配置也配好了，你登录配了，退出也得配，你登录时是我们认证的，你退出时要把认证结果给删了，然后做一些处理好，所以接下来退出相关配置把它处理好。退出的配置是HTTP点log out，然后点log out，URL，你推出的路径是什么？我们就是老高，你看这个controller我这里还没写，我页面上可能写了一个假的路径，跳过去了，我要求退出的路径是报告的，一会再处理，然后退出的时候有可能会有可能会怎么说，就是退出的时候他最终是会成功的，成功以后我们需要做什么处理，需要给一个指示，我们可以log out，you are log out。

然后 Success URL你提供一个成功以后跳转的路径，或者是也可以这样log out success hand给一个处理器，可以更灵活的处理，我们用处理器的方式更灵活一点，那就new log out success。Handler在这里他给我们提供了request，response以及认证结果这些对象都有，你想说怎么样的处理都行，我这里就跳转到首页，也就强制跳转到首页，这个可以重新下，你退出和首页没有什么直接关系。

它俩不是协作的关系，我觉得成像response点散的redirect，或者如果你不太清楚哪些用重新向哪些用转发的话，你就优先用重定向，如果重定向你发现我不好传参了，有些问题解决不了，你得考虑很准的，你可以这样去考虑问题。 Request点get contact pass加上首页。Index可以。

那现在我是对登录退出做了配置，这是与认证有关的，除了认证以外还有授权，我们还要对授权进行配置，主要是配说你哪个权限，你拥有哪个权限能访问，哪个路径，是权限与路径的对应关系，固定的格式这样写。Http点， Authorize request，然后点and matches。

写上路径，比如说 lighter私信的路径，然后点has any of the city。换个行不？换行就这样了，意思是这个路径有哪些权限才可以访问呢？Has any or有任何权限就可以访问它，你要配权限，我这样配user。革命什么意思？只要你拥有user或ADMIN，任何一个权限都可以访问到，这是合理的。你只要登录了，有了一个任何权限都可以访问它，私信好，然后再来and mattress。

我们的系统中还有一个路径是ADMIN管理员专属的页面。我写has authority。这里我就写好的，没有。意思是你有管理员权限才能访问这个页面，你只是有点防不了，它底层会做控制的，会做拦截的。最后再来个暗的，暗了之后还能再拼点别的东西。And exception handling。

那么有可能有这种情况，如果说你压根就没登陆，一看你根本权什么权限都不具备，或者说你登陆了你是优点，但是你要访问它的命，这个时候你权限不匹配了，它会报错，我们怎么处理这种权限不匹配，或者说你没有权限的错误？

我这样写 Access单位的配置我要指定一下，当你没有权限的时候，我访问哪个页面，我就调到这个页面带你的页面这个路径，而这个路径我现在还没写，我需要补充路径，不然的话这就不对了。

这个路径我也是把它写到 control这里，目前没有，我再加一个写个注释，就是说拒绝访问时的提示页面，或者说你没有权限你的提示页面，我copy一下，那么访问路径带你的拒绝，然后这个是get就可以了。 Get就行。

然后方法名我叫get denim配置。返回的页面是谁 era？404。当你没有权限的时候，我给你返回一个404的错误页面，比方说不存在，你没有权限访问，对于你来说这就不存在合情合理是吧？好了，现在我终于把 security就配置完了，那么配置完以后别忘了我们认证的时候，你还需要提交表单，表单我们还没配对吧？

所以说我们现在配置完了，路径也搞好了，但是表单还没配，我需要处理表单 login，点html，首先我要声明表单提交的方式，post没问题，然后表单提交的路径，写一下th action，我们手快的让它配置的时候，要求路径应该是老in，才能够被所谓的拦截到，所以你要按照规则来配。

然后你要提交表单的话，这个数据你要取名字对吧？Name等于user name，然后 password， name等于 password，因为我们在security做认证的时候，这里边它需要获取数据，那么你需要取个名字，他可能被他拦截到，而这个名字需要按照这样的标准来取。

好，这个验证码我们先不管，一会再说。

另外那么如果说我一点登录，他这一认证发现不对不对，以后还回到这个页面，你还要给一些错误提示，我们把这个提示到段落里， th冒号，txt等于艾瑞尔，错误信息就是艾瑞尔对吧？

另外的话如果你错过的时候，我希望回到页面的时候账号密码有一个刚才的那个值不好，基于这个值改，那就th y6等于那就是参数，我们请求参数里边的有的内容，这个就是请求参数里边的 password给他一个默认值，等回来的时候，好，最后登录按钮是300米的一点，就登陆，这个没有问题。

登录处理完以后再处理一下这个退出，因为退出我们看一下首页，首页之前是就写了一下，退出的时候就直接到了登录页面，我们需要重写，为什么要重写？

就是说色块的要求你退出的话，必须采用post请求，他这种请求就是get，所以不符合要求，我们重写一个，因为是POS的请求，所以我需要有个表单，然后 master等于post，这是他的要求，没办法，只能这样，action等于这个路径咱们在配置文件里写的是log out，按照规则写成log out，然后退出我就加个超链接就行，别的数据都不需要然后退出，然后它的href等于因为我退出是要提交表单，所以你不方便直接写一个链接，我要提交表单怎么办？

我可以用GS来实现。

那么如果你这个链接这里写的不是链接，而是GS，你要这样声明Java secret冒号，我这样写 document forms意思是我获取当前页面上所有的form，而我只有一个form，那就是 d0的 form，0得到的数有方明一的forme，然后对 forme Diao，沙漠的方法就提交了，这就是一段简单的GS就可以了。

好，这个退出咱们也配完了，最后为了让好看一点，我想在首页上再加一个欢迎信息，如果你登录成功以后，这里显示欢迎你某某某，注意我不是在每一个页面上都显示，我只在首页上显示，既然你要在首页上显示一个信息，我需要在首页访问首页的时候在这里处理一下，我需要获取到你登录的信息，然后发给首页，我写个注释，我们认证成功以后，我们怎么去获取认证的数据，这里解释一下，就认证成功后，那么这个认证结果会通过 security contest，holder，screen，rule，security context这个对象当中，这是底层有一个filter专门干这个事儿，当你认证成功以后，他拿到了认证，结果他就调 hold把这个结果存到对象里，所以他认证成功以后，他存到这个对象，你要取结果就从这个对象里取，我取一下 security，so clarity、context、holder点get contact。

就得到了这么一个对象，然后这个对象里就存的是认证的结果，你就代表get authentication认证结果，而奥森的kitchen我们之前往里存了什么，你看我们认证的时候，这里边我们不是往里存的user，而我们现在页面上要显示的不就是user相关的内容对不对？这个user是不是我们是按照以 print Principle来存的，对吧？所以你可以在这儿就是点get principle。

我们得到的其实就是 user这里，我这样我先当作object来处理。然后判断一下，判断一下OB机instance of user确认一下，如果它确实是user，那就说明你登录成功了，如果没有登录成功，可能他会给一个匿名的给一个别的结果，或者有别的情况存在，我怕如果说你直接就把它当成优质来处理，可能会有一些问题，所以最好判断一下，如果是优点我们就model点ed这里还没有model是吧？

说明一点model我就model点ed edge build，然后的话log in user登录的user， user把 obj实际上就是user传到页面上去，那么这回登录页面上我就可以显示刚才的登录结果了，对不对？首页上就可以显示这个登录结果了，在这里我补充一段内容，欢迎信息加个段落，我在段落里显示这个信息 Th做个判断，因为只有你登陆了，我才显示你不登陆我就不显示了。

我就log in user，如果它不等于now我才显示这个信息，这个信息我显示成什么？显示成欢迎你，然后的话十八里显示的是某某后面带一个感叹号，然后18我就需要我这里边放用户名了。Th text等于老b有点内容，这样就行了。

好了，那么到这儿我们终于应用了 Sql，目前的话我们应用它认做了认证，主要是体现在这个方法之内，也用它做了授权，主要是体现在这儿。当然这两段代码其实也是和认证有关的，是这样的。

好了，那么处理完以后咱们试一下看看行不行，那么我重启一下服务。好，那么启动以后，咱们来访问一下，打开浏览器，我再访问首页，刷新首页可以访问，然后我访问帖子详情，没登录，可以访问我，访问私信，访问不了。强制我登录。因为我没有权限没登录对吧？没有认证过。

好我访问ADMIN不行，强制我登录，我们刚才的配置就生效了，你没有认证就必须登录好吧？我就登录 AAA登陆，咱们这个表里不是有AA的用户对吧？Aa登录先不用验证码登录，欢迎你AA表示登录成功了，认证结果已经写入到了康泰斯里，好，登录成功以后再访问详情没问题对吧？

再访私信列表没问题，普通用户就可以访问信息列表，访问ADMIN他就到了404页面说你访问的页面不存在，这是404页面给的提示，你看授权权限的管理也就ok了是吧？我再回到首页。

好，你看目前的话，我们 security表现的状况就是ok的，当然你也可以退出以后你再访问私信又不行了，是吧？这就是色块的一个作用。从认证到授权都能够做全方位的管理。好到这还差一点，我们在登录的时候可能还有验证码的，对吧？我们可能甚至还有这个记住我这两部分怎么去处理，这个也给大家演示一下。

那么首先我先说一下验证码，验证码我们不能够直接在这个地方去处理，这个地方对象里只封装了账号密码，没有验证码，没有记住我相关的信息。就是说 Security它的职责分工非常的明确，你这个方法只是对账号密码进行认证的，就只有账号密码存进来，和别的无关。然后如果说我要验证这个验证码怎么办？

那你要知道验证码应该是在账号密码之前验证，如果验证码都不对，账号密码就不用验证了，应该是这样的。我们怎么办？我们是这样做，我们可以增加一个filter，在账号密码认证之账号密码认证的filter之前加一个filter，专门解决这个事儿，这需要制定一个field来解决好。我给你演示一下，那就在这儿加一个配置，增加 filter，然后处理验证码，这样的话hgdp点I的 filter，你看爱的filter，爱的filter比方是在谁之前加，在谁之后加，你可以指定我是要在谁之前加对吧？

比方第一个参数你的filter实力，我们可以在这匿名实现一个future，就是new future实现接口，然后注意还有第二个参数，第二个参数你要指定你要在哪个filter，哪个filter以哪个photo为目标，在它之前加处理账号密码的 Filter，底层的filter叫u的name，然后也就 u the name password also take action。Twitter。

当然你要指定它的类型，剩下的我们就需要在这里写逻辑就可以了。

 Filter匿名的filter就会在它之前被执行，在它之前拦截请求好了我就接着写，首先你看 filter的参数类型， server later request，而我们之前用的是HTTP server request，什么关系是这样的，这个是副接口，这个是子接口，当然这个方法调的时候肯定是传他们的一个实现类，我们通常用类型的方法多一点，我们这里可以转型一下，因为传的实现类，那么虽然说你用的是一个副接口来接收，但是我其实可以把它转型为这个接口，因为它传的是他们的视线内。

好转型成类型，好用 HTTP request等于servility bequest。当然你向下转型的强zhuan response我转一下方便一点。好，那么转完型以后我要做什么？注意我不是每个请求都要处理的，你一定是登录请求，我才要处理验证码的逻辑对吧？你不是登录请求我就不用管，我要判断一下，如果说request点get subvert passed，然后点echoes路径它等于log in。

如果说我们当前的访问路径是log in的话，说明你是登录的业务这个时候就有验证码存进来对吧？我就要得到这个验证码，假设这个验证码的名字叫WiFi扣的，我取一下 Wifi扣的。等于request点get very cold。好，我得到了这个验证码，得到以后我要判断验证码对不对？当然我们按理说应该是再提供一个方法，专门生成验证码，然后验证码存到 rise或筛选里头去。

我们这次课重点不在这，验证码生成我不写了，我就假设验证码固定就是1234，我就判断他等不等1234，然后简单处理，那么如果说外人说扣的，他等于闹，他是空的，或者是 wherever code不等于1234不等于前面加个不等号对吧？

这个时候我都认为验证码不对，验证码不对，怎么办？我需要给一个错误提示 Request叫sat actual，然后说验证码错误，好，然后我需要回到登录页面，我需要转发，转发的话，咱们可以这不是写过吗？拷一下。

好request，get this picture，然后 log in配置forward。转发过去以后return后面的代码不用执行了，因为到此为止。好，否则如果说没有return就说明什么？说明要么是不是登录请求，要么就是您找对了，后面还要写一句话， Feel turn，这有一个参数叫菲尔德欠，你要写一句话，菲尔德欠点future，然后的话 request response，这句话是什么意思？这句话的意思是让请求继续向下走到下一个filter，如果下面没有philter，他就走到Savitt，让请求放行，让请求继续向下执行。

如果说你这里没有写这句话，请求到此终止，不会向下走了，所以通常我们这句话一定是要写的，或至少是有些情况下是要写的，有些情况下不走，如果你验证码不对，请求别往下执行，如果验证码对请求继续执行这句话有特殊的含义，因为你有多个filter对吧？

好了，这是我们对验证码的一个那么如果你想处理一下记住我也可以，我在这里再把这个记住，我也给大家配一下，记住我HTTP直接配 Remember me，组建专门配记住我，然后首先是一般会配token，reporter你要告诉他，那我记住我你用什么来记，你是把用户的信息记到内存里，你还是把它记到数据库里，你要给定一个存储用户数据的方案，然后它默认带了一个类，我就用默认的new in memory什么talking repulse the apple这句话很显然他要把用户记到内存里，它默认一个实现。

如果你想存到reds里存到数据库里，你就自己实现一个接口，那个接口就叫应该就叫talk reporter自己实现一个结果自己去做就可以了，这里我就不去处理了。整个流程你知道就可以了。

然后再来偷看，然后 validate seconds过期的时间，你希望记这个数据什么时候过期给个时间，我3600乘以24这是秒，second是秒，1小时3600，就24即24小时。

然后再来 user detail service，user service，你还得告诉这个记住我组件 user detail service，为什么？

因为你这次登录他记住你了，当你把电脑关了，当你下次再访问这个网站的时候，它从内存里能得到根据你的凭证能得到你的用户信息，能得到你用户的比如说ID，得到ID以后不是得到用户名，得到用户名以后他得给你查出你用户的完整信息对吧？他得帮你查出完整信息好，让你就是帮你自动的过认证的那一关，他怎么查就用这个来查你，得告诉这个东西。

好了，到这儿验证码和记住我咱们就这就配完了，就这么配完以后登录页面你还得做一些处理。

好，我再回到登录页面，首先处理验证码，验证码我说了，我认为它默认就是121234，我觉得写死了1234，就是1234不动了，然后你得给它加一个name，对吧？Name等于 WiFi扣的和刚才我接收的 k是一致的。

除此以外还要记住我再加一个段落，这里面写一个记住我得是说勾选的是吧，那得是tap等于check box，然后 name是固定的，一定要叫 remember me，然后给一个提示记录好，这样的话就可以了。

我们再次做一个测试重启。

好，那么我打开浏览器，首页访问首页，目前是没登录的状态，我登录一下我先不记录我这回我还是用AAA登录，如果写一个错误的验证码登录你看生效了验证码错误，然后我写一个1234，没有记住我登录欢迎你没问题对吧？

好，但是我没退出，我关掉浏览器，再访问 local house index，这是没有登陆的状态，为啥没登陆？因为我没有点记录过，他没有去记对吧？好。再来登陆 Aa，1234，记住我登录欢迎你好。关掉再访问 local house index。欢迎你AA为什么会这样？因为他记住了，当你再次打开网页的时候，你网页里通过库里有一个 Talking有个凭证传给了服务器，服务器根据凭证找到了user name，然后根据user service detail查到了你这个用户，然后这个消息就看到了，他记住你就帮你绕过了认证的过程，或者说他帮你自动登录了，就是这样的。

好了，那么这次课我们花了一个比较长的篇幅，就是把 security它的概念，它的大概的实现的原理以及使用的方式给大家做了演示。

那么课后的话你一定要不要看它是一个demo，你一定要好好自己去试一试，因为确实还是挺麻烦的，你第一次学概念太多了，你不试一下的话不容易记住，自己亲自试一试，试完以后你对他有了感觉，那么下次课我们再利用 secret，我们把它应用到我们的游客社区的项目，去解决我们项目中的问题，提高我们项目的安全性。好，这节课我们就演示到这里，咱们下节课再见。