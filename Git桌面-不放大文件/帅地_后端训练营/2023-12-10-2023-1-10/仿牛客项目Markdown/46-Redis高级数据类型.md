46-Redis高级数据类型.mp4

这节课我们来学习reds的高级数据类型，主要是学两个类型，一个叫help log翻译过来就是超级日志，另外的一个叫beta map，翻译过来是位图。那么这两种类型它高级在哪？它都适合用来对网站的运营的数据进行统计，而且在统计的时候它非常的节约内存，效率比较高，这是它的一个特点。

那么我们这次课主要的目的是为了了解这两种类型，了解他们的优势和一些原则以及适用的范围，那么下次课我们再去运用它，解决我们项目中的问题，来统计我们这个网站当中的一些有用的数据。

好，我们先来看一下 Help log这种数据结构它采用的是一种基数算法，适合用来完成独立总数的统计，什么叫独立总数？

应该有的同学也听过，就是说一个网站在运营的时候经常要统计他的UV就是独立访客，那么一个人一天之内访问这个网站，多次这算一个访客这算一个UV就是说我们对于这一类统计，我们在统计的时候是要对多次请求进行一个去重的，那么害怕 log特别擅长做这样的事情，擅长在哪？

他在统计的时候，数据占用的空间非常小，那么无论统计多少个数据，它只占12k的空间，你要知道我们统计一个网站的数据，比如说统计用户有关的数据，网站的用户可能是非常多的，他可能有几十万上百万甚至上千万甚至更多的用户，那么如果你用其他的类型，比如说你用集合 site它也能去重对吧？

但是你把这些用户都存到集合里，占用的空间都大了去了，但还是log，无论数据数据量有多少，它最终都只占12k的空间，它这么神奇，其实是有它的代价就是说它这种基数算法它是一种不精确的统计算法，它说白了就是一种估算，但是这种估算的准确率非常的高，或者说它的误差非常的小，它的标准误差官方公布的大概是0.81%。

好了，所以说对于那些你不要求百%这个准确的精确的数据，同时数据量非常大，那么你希望占据空间小的这样的数据，我们用 happy love来统计是非常合适的。

好，这是第一个我们要掌握的数据类型。第二个是bit map，贝特曼其实它不是一个独立的数据结构，你从那个risk官网上去看，你选命令不是分类，都没有单独的这一类，它实际上就是字符串，但是它是一种特殊格式的字符串，它这种字符串我们是要按位存取数据，那么每一位我们只能存0或一二进制的数据，你可以把它看成是一个只有01构成的一个字符串，说白了我们也可以把它看成是一个bad数组。

有人说它只能存0和1的话，好像似乎它存的内容很有限制，什么时候适合用它，那么我们适合用它来存储大量的连续的数据的布尔值。

这里我举个例子，比如说我要统计用户的签到，对于每一个用户来说，每天都要统计今天你到还是没到，明天你到还是没到，那一年365天，天天都得统计，然后要统计若干年，那么你看每天只记录到或不到，我们01就够了，0代表没到一代表到对不对？

然后如果说我们用其他的类型去存的话，这个可能你存的是一个布尔的处放式，你还是存一个一个其他的能表达这个含义的单词什么的，那么这个空间都是比较大的，但我们用 beta map来存就会占有很小的空间，而且很方便。

我们这样转存0101，比如说第一个第一位的数字01，代表的是今年的第一天你到没到，第二位代表的是你第二天到没到？

第三百六十五位表示你第三百六十五天到没到，明白吧？

这样的数据是连续的，那么所以我们在存这个字符串的时候，每一位代表的是连续的值的索引，而每一位的0和1代表的是真和假到还是没到，所以如果说一个用户我们存他一年签到的值你都可以算出来一年就365天，那就是365个365位的值365位，那么每8位是一个字节，1÷81年的数据量也就是40多个字节，所以说它存数据空间也是很小的，但是它相对于 help log来说，

它能够统计精确的值，你这一年010 101，我想统计所有你到的有多少个数量，它是能准确统计出来的，是这样的。

好了，总之这两种类型的他们的机制不一样，适用的场景也不一样，我们这次课主要是解决他们的语法的问题，然后的话我们下次课再去应用，接下来我们就写一点程序，然后来体会一下这两个类型我们怎么去用。

好，我打开开发工具，然后因为这是一个 reads有关的问题，现在我们只需要了解语法，所以我们只要写一个测试类来测一下就可以了。而之前我们写过ready的测试类，我就找到那个类，接着在里面写代码， Ready，stats。

好，我找到后面去在后面追加一些内容，首先我们先来演示 help log怎么用，我说一下我想做的事情，我想这样做。

我要统计。

20万个重复数据的独立整数，就是我一共有20万个数据，那么这些数据当中有一些数据是重复的，你统计一下去重以后有多少个数就相当于统一独立访客感觉差不多。好，那么我就写一个测试方法，谢谢。

方法名我叫哈尔泰斯坦，hyper log log。

好。

那么因为我们要往 Rise里存一些数据，统计数据你得先存进去，你把数据先存进去以后我们才能去统计，当然这个数据我们是造的自己造，但首先我们要存这个数据得有一个key，首先定义 key，随便 read this key等于test冒号，hyper log hll缩写，然后01这是有关hil的我们的第一个k好，然后我要造20万个数据，我就循环是吧？

我先放循环就可以这样放I然后一回车它能生成一段代码，就是I我完了从一开始 I小于等于个十百千万10万，就是我从一循环到10万，然后我把每个I存到还存到还不拉的结构里面去，怎么做？

 Red is template点ops for你看有这么一个类型 ops for happy love，然后的话添加数据艾特那么指定key再指定值a那么这行代码执行完以后，那就相当于我会往这个数据里一共存10万个数据是不重复的，但是我说了我一共有20万个数据要重复怎么办？

我们再循环一遍，我还是循环10万次，然后每次我要产生一个随机的值，随机的范围就是1~10万之间，这样的话就有重复数据了对吧？好，我要一个随机值等于。

 mass点render。

然后这是小数乘以8,000万×10万，然后再加个一。当然了你还是小数，你得把它转成整数，这样才行。

好，那么 master random的是0~1之间的半闭半开区间乘以10万0~10万之间的半开区间加一就是一到100,001之间的半闭半开区间再取整，那就是1~10万之间的闭区间，这个范围之内的一个随机的数字数字，好，然后我把这个数字存到这个结构里，存的是 r这样我们一共向 hip log里存了20万行数据，其中有重复的，但哪个重复了不知道随机的，这个数据我们自己知道的，我们很清楚，如果说去重以后应该是多少？

显然应该是10万，因为它数据范围都是做了在1~10万之间，所以说就是10万。

我们看一下我们利用 help log它的API统计的结果是多少和10万之间的误差有多大？好，我直接就是输出统计结果，这样我先写一句话，统计的话就是red is Complete点 Happy love，然后的话统计这里边的去重以后的数据的数量 size，然后把 t传进来，我就得到了一个值，这值应该是浪吧，是塞子，好，我把这个值打印出来看一下。

写代码写完了以后我把它执行一下，这个单词我写错了， ready？

改一下，好执行一下，然后它这个过程有点慢，为什么？因为我们造了20万个数据他得跑，对吧？所以说他得需要一小一一会时间，但这个还行，不是那么慢，还算比较快。然后你看最终的结果99553，精确值应该是10万，而我现在得到的是99,553，那么误差是很小的，这个结果是可以被接受的，是ok的。

好了，那么再来这个还不拉，除了我们这样存数据这样去统计以外，它还有一个很有用的方法就是能够对数据进行合并，比如说我统计了一号的UV我统计了二号的UV以此类推，我统计了这一个月每一天的UV那么我们在去查询的时候，有的时候我们可能有这样的需求，我要的是这一周这一周7天的UV你应该把这一周7天的每一天的数据合在一起进行一个合并。

所谓的合并就是说本来是你这个人在这一天访问的，多次访问算一个UV如果是按7天来统计的话，就是你这个人在这7天之内访问多次算一个UV是这样，它能够自动进行一个合并，它有个API能够很方便进行合并。

下面我给大家演示一下，当然我不造那么多数据，我就造三组数据，那么就是将三组数据合并，然后在合并后的重复数据中统计独立整数。

这句话说的这么别扭，就是在统计在统计合并后的重复数据的独立总数，因为本来每一组数据都有可能有重复，那多组数据合在一起就更重复了，对吧？我们在重复的基础上统计一个独立总数这个意思。好，我再写一个测试方法，这个方法名我叫test hyper log log。

有你。

好，那么首先我得有三组数据，这三组数据我就不搞这么多了，每一组数据我就搞一个1万条。好，但是现在我还是定义一个key新的key。

二第二个t test hll然后02，然后我往这个数据里存1万条数据， I等于1。然后小于等于1万。好，那么我把每一个I放到这个数据里，I read this template ops for hyper log around add write is key，然后的话存的是 I好，第一组数据就有了，同理我们再来第二组，第三组数据一共就三组，我可以copy。

这是第二组数据，我把 k303然后这个数据我就从不从一开始了，我从50015001开始，然后一直循环到15,000。反正一共也是1万条数据，然后存到三里不要搞错 t好，这样你看第一组数据和第二组数据他们是不是有交叉有重复数据是的。从5001~1万，这部分数据是重复的对吧？就我特意照一些重复数据，好，看看他统计的到底精不精准，如果没有重复数据就没意思了是吧？

好了，再来一组叫44，那么 I我。

从。10,001然后。

一直到循环到2万。

然后也是为了让它和第二组数据有一定的交叉，然后存的时候这个是 ready4，然后存的是 I没有问题。

好了，那么这三组数据其实我们口算也能统计出来一共一共有多少条数据，一共是有3万条数据，那么去冲以后有多少条应该是2万条，对吧？因为这个数据的范围是做了在1~2万之间的，它没超出这个范围，不管怎么重复，而且一定是连续的，然后不管怎么去重，一共是2万个。

好，我们给它合并一下，那么ride is happy， log类型它对数据合并是把这三种数据合并以后再存回到 release里，存的类型也是help log。

所以我们一合并会产生一个新的数据，我们需要定义一个新的key，我叫优点k unit，然后等于的是test paper log，然后的话unit然后我要进行合并了，radius template ops for help love，然后点它有一个优林方法的第一个 key写的就是优点的key，就是你合并完以后数据要存放的位置，后面你可以写多个key，你要合并的那些key，我们分别就是reds二，对吧？

3。

还有4。

当然你这里传的是数组也可以都行。好了，那么这句话执行完以后，那么 unt对应的数据里就有相关的指标，我们看一下这个结果还是 kind of sad。

然后 write this template for ps for have a log。然后 size我要看的是u0k这组数据我把 size打印出来看一下，这个写完了非常容易执行一下，这回数据量比刚才小了一些，所以说应该是略快一点，我们看一下这个结果已经出来了。

一共是19833，那么准确的值我们自己算应该是2万，但是它给我们估算的是19833也是非常的接近，误差是非常小的。

好了，那么通过这就是这两个方法，我们基本上了解了还不log，然后它的一个使用情况，它的用法，然后数据量大与小，其实也可以看，但是可能看的就不是那么准确，大概也可以看ready？Cic烂11。然后的话 Release里有这样一个命令，它叫做in for memory。就是看内存的一个使用情况。

然后这里边它有一些内存的使用量，那么你看比如说第一个使用的总内存，比如说你在执行操作之前看一眼内存，执行之后看一眼内存，然后两者一减，然后一换算大概能算出来它十几k但是这是总的内存，因为你创建数据它k也是占空间的，它可能是比实际12k大一点，但是它的值只占12k是这样的。

我们就不在课上看，你可以自己课后自己看一看。好，那么以上是关于 Happy love第一个类型。

下面我们再来演示一下第二个 bit，MAC写不出是说我要做什么，我想做的事情是我要统计一组数据，这里我就先不说我统计的是签到了，因为一会我还要做一个运算，签到的业务和运算好像不太搭边，或者说签到的逻辑用不上这种运算，所以我就不说它是签到反正就是我要统计一组逻辑，一组数据的布尔值，一会我对它做运算，只是停留在一个语法层面。

好，我要统计一组数据或者值。

写个测试方法，test，bit map。

当然了我们统计的值，首先我们得有数据得先存数据进去，然后才能统计，所以说还是要说明一个key。Ready，skip test bit map01，这是我们要统计的第一份数据，首先我要往里存，这个数据我要记录一些值。

好，刚才我也说了 beta map它不是一个独立的数据结构，它其实就是string，只是对一个string的特殊的操作而已，所以我们其实还是ready time late点ops for value还是访问死菌，然后我要往死菌里存的是按位存的数据怎么办？

调这个方法site wait，然后声明 t因为是按位存，你要指定我现在是第几位索引是多少，以及它这个值是多少，比如说我索引是一，当然索引从零开始第一个位置，那么它是0还是1这个值，但是这里边他让我们传的是布尔的true force，说白了我们g0和1其实就是用它来代表true force，所以说它这里面是传的是一个逻辑一个，而不是0和1，这也合理。

好，再来两个数据，比如说这是第四个位置处，然后比如说这是第七个位置处，有人说那里没有存force吗？ Force不用存，你只有设置它默认的话，连续的人默认每个位就是false0，那么你存了这个数以后它才是一，而我们最终要统计的往往就是处的个数为真的个数，就以签到的业务来说，你哪到哪天到了，我们很少说统计一共你全天哪天不到，一般都是统计哪天到，当然你不到可以通过这个减法去算出来，但用的比较少。

好，这是记录进去的，记录进去以后我们可以查每一位他这个值是多少，我们再来查查单个某一位的结果。好，我就直接输出这个结果了。

 Release template ops方案6，然后取某一位的值get beta存是site取是get，然后 ready ski，比如说我取第零位，你注意第零位我可没有设置为处，它默认是false，第零位比如说我取第一位，我再取第二位，第二位，好，一会我们看一下这个结果，然后当然这种这不是统计，这只是查某一位的布尔值情况，我们要统计说一共有多少个数怎么办？

再。

演示一下统计的方法是不在这个对象之内，我们从对象访问不了，我们需要通过radio底层的连接才能够访问那个方法，我们怎么去获取radio底层的连接呢？可以这样去做。

 Ready是太累的。

点sq就是说这个方法是我们要执行一个rights命令，那么执行的时候它需要我们传入一个回调的接口，我们在这里做一个匿名的实现 new。

Red is called back，它自动的帮我把实现的方法加进来了，然后它里边有一个方法接口里边有个方法叫doing ready，然后这个方法传会有一个参数是readus连接，这写的简单一点connection，就是说当我们Diao sq的方法的时候，这个方法底层的会掉，我们提供的 call back，然后它在调的时候它会自动调这个方法，它会把 reds连接传进来，这是red底层的一个逻辑，我们这里可以去做一些处理，并且返回一些值，反馈结果最终会返回给 sq的方法，我们可以通过这个地方接受一下最终的结果。

那么接受以后我可以最后把 OB机打印出来看。

好。

剩下的就是说我在这里怎么去利用品牌安全统计这个数值了，非常简单。有了connection以后，我们只要调它的 Beta count方法，然后的话传入 red SK但是因为是按位统计，它需要我们传的是bad数组，好吧，red ski不是死菌吗？

我们点get best就得到了 better速度传进去就可以了，它会帮我们统计这种back里边的一一的个数，这代码就写完了，我们试一下看这个结果怎么样执行。

好，我们看一下最终的结果，首先是这个地方我们按位取布尔值第零位false第一位数第二位false没问题，因为我们存的时候其他的默认都是false，但是只有147是处，所以这里面一处往其他处放没问题，那么统计最终的数的个数三个也没错。

Ok没问题。

好了，这是我们往里存值，以及我们如何去统计这个值。那么如果你有多组数据，这之间还可以进行一个布尔运算，因为我们纯的值是数放，那么它能做什么运算？它能做与或非的运算，比如说处或force结果还是出真或假结果还是真，是这样的。

好，那么这个也有用，我们下次课

会用到这样的逻辑。

好，我们这次跟他先演示一下怎么去做这样的事情，几个注释统计，三组数据的布尔值一共有三组数据，然后我并对这三组数据做二运算，就是我们做二运算的情况用的多。

当然如果你是做这个案的，其实和二一样，就操作时候换一下而已。好，我再写一个测试方法，叫test bat，因为是运算运算符， Operation。然后这三组数据我得先造一下，首先 steam red is t二等于text bm然后02，然后我要往这里存一些值 release template，点ops for value，点set fit，write this key。二比如d0的位置，我要存的是true。

好，再来俩，然后第一个位置是处，第二个位置是处012都是处我这样存的，然后再来一组都去copy了。 k就是33把都换成三，然后这个第二组数据我是234为数，01和其他的方式，你会发现这两组数据是不是有交叉的情况，对吧？就是二都是处他们有交叉的情况，好再来一组4。好，这个我设置是4，56是数，其他的位置是force。你这么看这3组数据，比如说你都把它看成是一个每一组数据都是有6位00六七0~六七位的这么一个值，那么第一组数据就前三个是处，第二组数据是中间三个是处，第三组数据是后三个是处。然后我们对他说奥运算会得到一个什么结果，主要是看这样的一个事情。

那么运算也是和刚才 help log类似，它运算以后会产生一个新的结果，需要存到一个新的地方。

所以我们需要再声明一个 key，我就叫red，red is keep等于test beyond。然后的话or因为我做的是奥运算直接一点。好，那么运算我们也需要用到 connection，因为预算更高级了，你像刚才我们统计一个数量都得用 connection合并，也需要用到connection，所以说我们需要写刚才那个代码结构，

object obg。

等于write this template点，s cute。

然后 new。

 red。

 is called back。

好，那么在内存的方法里，我们需要做奥运算用的connection，就connection参数名改短点， connection点bit op bit operation就是要做运算了，然后你要做什么运算，你首先要把运算符指定我们通过一个就是一个接口 bit operation第二二是red is string command。

第二bit operations，第二先证明运算符，然后你要指定我预算结果存到哪个key里，应该是存到 release key里。那就ready ski there get back。因为位运算它需要你存的是这个二进制的数据 Bat的数组，然后你要对哪几组数据做运算，你再把那几组数据的p传进来，那不就是234对吧？

然后就是write this key二，当然也得改成也得置换成办法。 Read this case三，get backs， where is k4？Get backs。好，这样就行了，那么他就把234这三组数据之间做一个奥运算，你要知道二元算的出结果就是出，对吧？好了，执行完以后执行完以后我们会得到一个 red SK里就成了一个新的值。

我们要统计这里边数据的情况，就是里边真为真的数据的结果，我就connection点bit count。 K你要写的是ready ski要get best好。

返回这个结果，

我最终把这个结果打印出来是吧？Ob界。好了，当然了，这个时候你也可以把 ready key对应的每一个值弹出来，它最多也就是0~0~六七个值，因为这些数据合并在一起最多就7个值，我依次给打印出来 c是out，ready，stop late。If you ask for value，然后 get bit where it is key连。然后打印出来以后我们看的就更直观一点。

好，那么写完以后我再执行一下这个方法。

好，那么执行完以后我们看一下统计结果是7，然后你看我们打印的0~6，这7个值都是数统计的没有问题，为什么是这样的？因为 Sk2他012去处，虽然说其他的两组数据可能012 false，但是和它一二运算以后变成了处。同理它中间三个值是处，它后面三个值是处，它们互相一做运算都是处了，就是这样的。

好了，以上这两种rise高级数据类型，我们在使用的时候往里存数据以及统计数据的一些API的演示，当然我们更多的在意的是统计的一篇，或者说我们能够利用它统计什么，那么现在语法知道了，我们下次课再去给大家演示，我们到底能够解决项目中的哪些实际的问题。好，这节课我们就进行到这里，咱们下次课再见。