52-优化网站的性能.mp4

这次课我们来学习如何优化网站的性能。那么优化网站的性能其实有一个非常行之有效的手段，就是加缓存，那么但是加缓存它是有一定的策略，有一些原则的，也有一些方式方法，我们需要对这个如何加缓存有一个系统的了解。

再一个我们之前也加过缓存，加完缓存以后我们是想象着说它的效率会提高，但是具体来说它到底有没有提高，它的性能到底提高了多少？我们没有一个明确的这么一种感受，或者是没有一个明确的证据。

所以这次课我们在优化完某一个功能的性能以后，我们用压力测试工具给他测一下，当然我们之前也测一下，这样的话两者做一个对比，你一看就明白说

加上缓存和没加之前，那么它性能差多少？

那么你把这个缓存加上去，并且做了一一个详细的测试，有了一个详细的数据，那么你面试的时候去跟面试官讲这个是有理有据比较让人信服的，而且你自己从这个数据上也能够感受到这个缓存能够给我们带来的一个价值，所以说你以后在开发的时候也就也就主动的愿意去用这个缓存了，你也会主动的多往这方面去考虑，这也是你一个经验的提升。

好了，那么缓存我们在使用的时候有三种，第一种叫本地缓存，我们把缓存数据存到我们的应用服务器上，那么这样的方式性能最好是因为客户端发请求发给发给的是应用服务器，应用服务器一看我本地就有缓存的数据，我就直接给你返回，对吧？

它最快。

然后把数据缓存在本地的话，常用的缓存工具有 eh catch，还有瓜味儿，还有咖啡因，然后那么一会儿我会给大家演示咖啡因，因为目前咖啡因它是性能最好的一个缓冲工具，我们就用其次是分布式缓存，分布式缓存是把缓存的数据存到一个note和数据库上，那么它的优点就是能够跨服务器，而前者像本地缓存就是有一些数据是不适合存在本地缓存的，你比如说登录凭证，因为这个数据它和用户有直接的关联，那么如果说用户访问 a服务器在分布式这个系统里，他访问a服务器，得到一个凭证，这个凭证存到了a本地，下次请求它会被打到了b而b上就没有这个缓存，那么可能就影响它登录的状态，所以说这种情况不适合存到本地缓存。

而分布式缓存它能跨服务器，因为我们 ABCD多个服务器都访问同一个 No circle数据库，所以它的优点在于这儿，然后它的性能肯定是比这种my circle数据库要好，但是它的性能比本地缓存略低一点。其实低在哪？低在网络开销上，因为我们请求发给了应用服务器要访问。

 No circle的话，它往往是在两台机器上，所以说它之间有网络开销，网络开销主要是有一个影响，所以它比略低一点。

然后常用的缓存的工具有 Memory开始还有 radius，我们的项目中用的是 radius，而实际上 rise我们怎么用它缓存数据，咱们都用过，我们不是用rise缓存过验证码的头啃对吧？也缓存过user等等，我们缓冲其实好多数据了，这个其实我们已经会了。

另外我们也可以把本地缓存分布式缓存把它们结合在一起，形成一个多级缓存，那么多级缓存通常是这样的，通常我们是有两级，然后当请求到达服务器以后，服务器看一下我本地缓存作为一级缓存有没有，你要的数据有就返回，如果没有的话他就会去访问，峰值缓存也就是二级缓存，看一下你这里有没有缓存数据，有返回，如果没有怎么办？

最终去查数据库。那么如果查到数据库查到数据以后，它会把这个数据存到二级缓存里，存到一级缓存里，最终再把数据返回给你，在这次请求当中数据库得到了数据更新了缓存，返回的数据给你，是这么一个流程。

好，总之这种做法是尽一切可能尽最大的可能就是避免你直接访问数据库，或者说我们这种方式，因为我们在DB之前加了两级缓存，它能够避免缓存雪崩，什么叫缓存雪崩？就是缓存失效。如果你只有一级缓存，比如说缓存在radius上，万一 Radius它瘫痪了挂了是吧？这一下子所有的请求都会到达DB，可能就一下就把DB给弄瘫了，是吧？或者说如果你所有的缓存都在万一本地缓存，由于某些原因不行了失效了，所以说也有可能请求直接就到达了 Db而到达DB大量请求到达DB，对DB是一个有毁灭性的影响，所以说这个是要尽量避免的。

我们有了两级缓存以后可能一级缓存挂了，还有二级缓存，二级缓存挂了还有一级缓存对吧？两个缓存同时挂掉的概率就比较小，所以说那么这样的话就能够提高我们系统的可能性。

好，这是我们对缓存大致做一个了解做一个介绍，然后我在写代码之前我想在介绍的更直观一点，因为这个是从文字从口头说明的时候，可能有的地方你就是理解的不是很到位，所以我画个图再给大家再说一说，很有必要说得更清楚一点。

好，我们说的是我们将来这个系统它的就是最终的部署，现在的网站都是分布式部署，都是多台服务器组成集群，那么我也不画那么多服务器，我就画两个服务器，一好服务器里头我们有的是什么，有的是我们的一些组件，当然我们的核心其实是 service是业务总监，我们最终的control是要叫service，当然service会去访问数据库，这里我画的是service表示我们要处理的业务，它部署在了我们的服务器里，或者说这样我画成APP就是我们的应用部署在了这个服务器里，好。

然后那么一级缓存服务器的缓存就是服务器的一个内存空间，这个就是本地缓存，然后这是我第一台服务器，那么我们实际部署的时候可以有多台，比如说我再换一台，这是第二台，这两台服务器上它的代码 APP一样的，然后它的缓存都是占有它各自的内存也是就类似的。

然后我们的请求，比如说用户第一个请求恰好被分发到了服务器一，他访的是这个服务器一的 APP就应用，然后应用要应用缓存它怎么办？它会去缓存里找这个数据，然后看一下这个数据有没有，有就给你直接返回就不用去访问数据库了，这样效率就高，我现在的假设它没有没有怎么办？但是我现在假设只有这一级缓存的情况，我们就换个图先说一下本地缓存它的就是工作的场景。

好，假设我暂时先没有二级缓存，没有分布式缓存，所以说当你从本地缓存中取不到数据的时候，你就直接需要访问DB了。所以这个时候服务器就会去访问DB，然后得到数据以后，它会把数据更新到本地缓存，就有一个更新的过程，然后这个数据就被返回给客户端。那么刚才我说了本地缓存的局限性就在于如果说本地缓存的时候用户息息相关的数据，那么你看刚才这不是第一次请求吗？如果第二次请求这个请求被分发给了第二台服务器，这个就糟糕了。

因为此时你缓存的是和用户有关的数据，可能是关乎他是否登陆的一种状态，这个时候 App会从缓存中取数取数据，然后取不到他可能就认为你没登录，比如说我们存的是缓存凭证，这个时候他可能就不会访问这个DB了，他就认为你没有登录，根本就是word，所以说这样的话如果是和用户息息相关的数据缓存到本地缓存，那么会不合时宜，但是如果是其他的数据，比如说我们缓存热门的帖子倒可以，我们第一次请求访问 APP这个应用，然后它没有数据访问数据库，然后更新缓存，第二个请求不管是谁访问APP应用，它也是同样的道理，它也是访问数据库，然后根据缓存，你这样的话这两次请求完成，完成以后后续的请求，那么无论是你打到服务器一还是打到服务器二上，这个缓存里就都有数据了，整体性能就被提高了，只要数据和用户不是有直接的强关联，那么我们在每个服务器上都缓存一份，也可以也是ok的。

那么 readiness缓存它的好处就是刚刚能够解决刚才我说的那种和用户相关联的那种问题。

我们在琢磨一下，比如说我第一次请求访问服务器一他看本地缓存没有数据，如果说我们这时候用的不是本地空调，而是ready start，那么假设我们用的是ready，比如说应用看 release里有没有数据，这里得改个名字，一看没有怎么办，他就访问 DB，访完DB以后他需要把这个数据同步传到radios里，然后把数据返回给客户端。

如果用户下回请求被打到了第二台服务器上，第二台服务器它也是我先看rise里缓存里有没有这个数据，一看有那就直接从这里取到这个数据，返回就完了，就避免了访问DB，所以说这个readiness它可以跨服务器，ready这里你是缓存什么样的数据都可以，它就没有局限性。

所以说我是希望通过画图的方式给你直观的让你感受一下就是本地缓存和reds这种分布式缓存它的区别在于哪里。

另外你也能看得出来本地缓存的效率要比reds要高，因为本地缓存应用直接去访问，在同一台机器上对吧？这个速度很快没有网络开销，而ready我服务器要访问它，两台服务器中间有网络开销是吧？

所以说各有优劣，但总体来说 ready是适用的程度更广，本地缓存有些地方不能用，你要注意好了，然后再画一个图，再画图说什么说一下。

我们整个缓存在使用的时候详细的使用的过程，假设我部署的是两级缓存，本地缓存和release我都用这个过程是怎么样的，我这里我就不去花两台服务器了，我就是用一台服务器来说也能说得清楚。

好这是我的服务器，然后这里面部署的是应用要写上APP，然后当然我的服务器有一部分的内存空间是被划分做成了，缓存的空间，它就是本地缓存，也就是那么当请求抵达这个服务器访问应用的时候，那么应用首先它不是上来就去访问滴滴，它是先去看本地缓存里有没有你想要的数据，如果有就直接返回给你，这是第一步。先看一级缓存，本地缓存里有没有你要的数据就返回，如果没有怎么办？

再看二级缓存，二级缓存呢就是readus，当然我们的应用里是ready，你也可以用别的，所以如果说第一次看本地缓存没有数据，就真正的看 release里有没有这个数据，然后如果有数据就给你返回，如果没有数据怎么办？假设此时恰好就没有，这是第二次进入，第二次查看缓存没有，这个时候就需要访问DB了。

好，所以这个时候他要访问DB，访问DB肯定是有你要的数据的，这是第三次访问，访问到数据以后，这个时候它需要对数据进行同步，同步到缓存里，这样的话下次缓存里还有数据好能用，所以这个时候就第三次访问以后，应用会把数据同步到二级缓存里，进而再同步到一级缓存里，然后再给你返回，是这么一个过程。

所以当你下次再去访问这个服务器的应用的时候，那么本地缓存就有数据了。

当然了我们通常的缓存会设置一个自动的过期时间，万一说本地缓存过期了，或者说我们这个缓存一个是要设置自动过期时间，还有一个还会设置它的总的大小，本地缓存一般的大小会比较小，因为它要占有服务器的内存，服务器还要运行应用，它分不出太多的内存给你，它都空间总的空间比较小，能存的缓存的数量比较少，所以有可能你这个数据被其他的数据给挤出去了，有可能访问的时候一级缓存里没有数据，而你访问release里面release里有，所以这就是两级缓存的意义了，从这方面也可以去理解它的风险小，而它的空间很大，能存很多缓存的数据。

所以当你下次再访问的时候，看一看本地缓存有没有有就返回，如果没有这份 readiness，通常这两个一般就会有，万一实在没有再访一次数据库，但有了这两个缓存以后，访问数据库的概率就会大大的减少，那么整个的服务器的处理能力就会大大的提高，速度就会提高很多的。

好了，这是我对缓存做一个大概的介绍，然后刚才也提到了缓存它都有一些这个基于大小，基于时间淘汰数据的这么一个策略，你要设置缓存里能存多少个数据，超过这个数据就要淘汰一些，有的是按照先进来的数据先淘汰，有的时候是按照他用的使用率，他使用的不频繁，就淘汰缓存，它有底层的一些淘汰策略，然后再一个也是有基于时间的淘汰，不管你使用的频不频繁，反正我比如说到了10分钟我就一定要淘汰你，也有这样的一个情况，这样的话好腾出空间给其他的这个数据有一个公平竞争的机会，这样。

好了，大概了解了缓存的这些个原则以后，下面我们就要通过缓存来解决我们项目中的某一个功能的问题，提升它的性能，并且我们通过工具去测试，看一下提升多少，咱们有个直观的了解。

我们的这次课的目标是什么？是要优化热门的帖子列表，我们都游客社区的首页是个帖子列表对吧？它默认的话是按照这个帖子的时间的倒序来排的，但我们还有一个按照这个热门程度来排，我们对热门程度的列表数据进行一个缓存，你提高它的性能。

有人说为什么你不是对默认的时间倒序的，按照时间排序的帖子里边去设置缓存，因为不合适，什么样的数据适合缓存，一定是数据变化的频率相对较低，数据变化的不那么频繁，而我们的默认的首页按照时间倒序排，经常有人发布新帖子，经常有人去评论去改这些帖子相关的数据对吧？

所以说会导致第一页的数据变化的比较频繁。

所以你缓存的话缓存老变，你经常要去更新缓存反而效率会低的。而按照热门程度来排序，我们热门程度上算分的，分我们是过一段时间算一回的是吧？所以说它是一一隔一段时间更新一下，它能够保持一个比较长的时间几乎不变，所以我们可以把数据缓存到内存当中，所以基于这样一个原因，所以我要修改要提升功能的性能，大家注意，好这是我们的这一次课的目标了。

然后我刚才也说了，我们要用什么来实现呢？那么本地缓存咖啡因可以用本地缓存，因为我缓存的是帖子，谁都能看，你登不登陆都能看，和用户其实没什么关系，所以我们就是用本地缓存咖啡因来做。

至于分布式缓存我就不演示了，因为我们如何把数据缓存到readily，大家都会了，我们之前很多功能里都演示过，这里我就不去做了，但是我写程序的时候会告诉你，你看在这个地方我们可以先查一下release，然后如果没有再查买色口这样就实现了。

二级缓存我会告诉你那个位置你可以自己去做一个尝试。

好，然后我们使用咖啡因实现本地缓存，可以单独用，也可以用spring去整合，其实这些这几个缓存都可以用spring整合，但是我不建议咱们用spring整合缓存的工具，为什么？

因为spring整合缓存它是用一个 catch manager一个缓存的管理器去管理所有的缓存，我们程序中可能有很多缓存，a缓存缓存帖子b缓存缓存，其他的数据有很多缓存，那是不愿意用一个缓存管理器管理所有的缓存，然后的话把它的过期时间缓存空间大小是统一进行设置，这个不太合适，因为每个缓存缓存的业务数据的不同，它的要存多少个数据，它的强制数据淘汰的时间应该有所差别，不可能是一刀切的。

当然我们用spring能不能就是说每个缓存给它单独一套设置也可以，你需要多个缓存管理器，那样反而麻烦了。既然他麻烦了，我们还不如就直接单独使用这个工具就算了，所以我就不用死人去整合了。那么关于咖啡因，他的手册你需要去get up上去找你在 Get up，然后去搜咖啡因，搜到的结果就是这样的。

第一个点进去以后，它后面会说你要看手册，点链接，好，这是他详细的手册在这里。

看好这是我们手册从这里找，然后的话我们要使用它的包，我们还是去妹妹repost那边去搜，比较方便。

我搜一下搜咖啡因，好，那么第一个这就是这里少说了一点，其实之前很长一段时间瓜娃很流行，那么现在是咖啡因更流行，但其实它俩使用方式几乎一样，咖啡因就是仿照着刮过去做的，但是他想到最新的算法，那么它的效率要优于优比它提升很多，所以现在我们就使用第一个我点进去，选择一个新的版本把它拷过来，粘贴到我们的配置文件里，很快就下载好了，下载好以后包有了包有以后怎么办？

接下来我们还需要设置一下参数，这个参数是我们自定义的参数，并不是说咖啡因强制要求的，为什么要自定义这个参数？

因为我们在缓存帖子列表的时候，我们要声明能缓存多少个数据，我这个缓存空间能存多少个数据，然后多长时间要把这个数据释放掉，好让新的数据进来，还有一个更新的自动更新的这么一个机制，这个参数最好做成可配的，因为我们现在在本机是这样的，我们将来可能部署到这个上服务器性能好的时候，我们可以把这个数调大一点对吧？

所以最好是能可配的，我就打开 practice配置文件配一下，配置是与咖啡因有关的，也就叫咖啡因，然后的话这是我自己取一个key咖啡因点，pose。为什么叫pose字？帖子我们要缓存的是帖子列表，是pose是缓存的名字，如果你后面还要缓存其他的数据，比如说你要缓存评论你可以叫咖啡因点，comment or posts点。

max size。

等于多少？

就是说缓存空间里一共能存多少个对象，我写的少1.15个，有人说这也太少了，你要知道我们缓存列表，我们是缓存列表是缓存一页一页的数据，因为用户看的话看的是第一页第二页第三页，我们每次缓存缓存是第一页第二页第三页的数据，你有必要缓存那么多页吗？对吧？

因为你可以想象得到我们即便是热门的帖子，大家也不可能看到几十页之后去，你可能看个两三页就差不多了，当然最频繁的肯定是第一页，对吧？能够缓存15页基本上就够用了，咱们没有必要浪费那么多内存空间，所以我就缓存15个数据，但缓存15页它未必就是前15页，那没准说有的人就前5页看的人多，然后最后也末页看的人多，末页反而被混合进去了，不是15对吧？

也有这样的，可能总之就是混合15个数据。好，然后再来咖啡因点，posts。Xp。Seconds。就是过期的时间，单位是秒，我写成180秒，三分钟就是这个数据不管怎么样到三分钟，就是你存到这个缓存里的数据到三分钟自动就会被清理掉。

然后当你下次再访的时候，它会从数据库里又查一遍，然后再更新到缓存里头去。为什么要这么做？因为其实缓存它的数据的淘汰有两种机制，一种是主动的淘汰，比如说我这个帖子数据发生变化的时候，我把这个缓存清掉，当你在缓存的时候就重新加载了。

再一个就是一种自动淘汰定时的，而我们有的一般我们很多的功能可以两个都用，数据变的时候我也淘汰，然后定时也有个淘汰，我们只有定时淘汰，为什么不主动淘汰？因为我缓存的是一页数据，如果里边某一个帖子数据稍微发生变化，我把整个这一页都给刷了，这个挺麻烦的，对吧？

不太合适，所以说我们就没有这样的一个淘汰机制，你这一页某一个帖子，比如说他被做了一定的修改，多点了个赞，多了个评论，我不去更新缓存，然后的话到三分钟刷新一下，所以可能是你看到的这一页的帖子，它里边的点赞的数量一些数量可能会有一定的延迟，但这个并不影响使用，没有关系好了，这个参数也就设置好了，设置好以后我再去优化我们查询的方法，我们优化什么方法，通常都是优化 Service，业务方法，因为你无论前端访问哪个controller，最终你要查这个帖子肯定是调 service的对应的方法去查对吧？

我只要把service优化了，你去调性能就高了。

所以我们去优化 Service，这个service就是 discuss。Post service好，首先我先初始化一个logo，因为我在一会儿写代码的时候要用到 logo，记一些日志。好，另外把刚才我上面的那两个参数注入进来肯定是要用的，对吧？第一个就是max。

 size。

缓存能存多少个数据最大的数量。好，第二个是x片second过期时间，我把这两个key拷进来，好。

参数有了，有了以后，我们现在是要使用咖啡因去缓存帖子列表，同时我也把移动的总行数也缓存一下，这个也可以缓存，因为我们每次去查询帖子列表都会调这个方法调的比较频繁，我们也可以把它缓存一下。

为什么可以缓存？因为总的行数它影响的是我们算的总页数，我们利用它算总的页数，如果说你去访问这个帖子列表，总的页数稍微有点延迟，在你看来少了一页，其实问题不大。

再一个其实你看牛客网，总的页数它运营一段时间以后帖子特别多，页数特别多，那么总的页数它最多限制到100，你永远看都是100末页，其实还有有更多的不让你看了，因此其实总的行数我们做一个缓存也是ok的，然后我们用咖啡因做缓存，咖啡因的核心的组件接口叫catch，就核心接口叫catch，就代表一个缓存，然后的话它有两个子接口，有好几个子接口，有两个比较常用的，一个叫做loading。

Catch，还有一个 A sack loading test，那么其中 loading test比较常用，它是同步缓存，比如说我有多个线程，同时访缓存里的数据同一份数据，那么它会但是缓存里数据没有怎么办，他会让这些人都等着他去，数据库取完以后再给你们返回，他是让你们去排队等着的，是这样的。

然后三个录音开始它是义务的，可以怎么说？可以支持并发的同时取数据，但是我们希望是这样的，我把这个数据取好以后，再去给你们返回，你先不要着急做并发的取，所以一般我们会用 Loading开始。

好，那么要用 loading开始，我需要利用它把两个缓存声明好，一个缓存是缓存帖子列表，一个是缓存这个总的行数，其实我们需要两个环节能够把它先声明出来，然后再做初始化。

好，第一个是帖子列表的缓存声明一下，类型就是loading。

Catch。

 t是string值list。Discuss。Post是一个列表的集合，那么这个名字我叫post list。

当然。

这个开始需要初始化才能用。好，然后另外这里说一下为什么 Loading开始需要两个值，一个是 key这一个是value，其实所有的缓存它都一样，都是按照key缓存value，都是按照k缓存外流，这是一个k为什么是个死病？

咱们一会再详细再说。好再来接下来我还要说明一个缓存是缓存帖子的总数，帖子总数是吧？也是楼顶开启。 Key我用inter， value也是inter，然后我就要post rose。

 catch。

好，这个缓存我们什么时候初始化，它不需要初始化多次，在我们服务启动或者你首次调 service的时候，初始化一次就够了，我可以这样，我可以给当前的类增加一个初始化方法，在初始化方法里它唯一的调用一次的时候，我去初始化这两个缓存， post开始转，在这里我要分别要初始化帖子列表缓存，另外还要初始化帖子整数的缓存，把它们一次初始化了。

好，具体怎么初始化咱们一会再写详细的内容。我后面先告诉你怎么去调，这样你好对 key有一个了解，比如在这里怎么去调。首先我们说一下这个方法，因为是多种场景都会调，首先我们访问首页，按照这个时间的方式来默认方式来排序，那么回调其次我们按照热门帖子的热门的方式来排序也会掉。

再一个用户有一个查看自己发布的帖子的功能也会掉，这个方法多多个地方掉，但我只想缓存的是热门帖子，也就是说好的mood等于一的时候它不等于一的时候我不缓存，再一个我是缓存首页的，首页的首访问首页的时候， uz ID是不传的，uz ID是0的对吧？

所以当uzid等于0，当它等于1的时候，这个时候我才缓存，而我缓存的是一页数据，而这一页和谁有关？是和这两个条件唯一确定一页，所以你说 t应该是什么？应该是它俩的组合对吧？我怎么组合其实怎么组合都行，把它俩加起来，中间隔个逗号，隔个冒号都行是吧？我就隔一个冒号就以它俩为k因为它俩的标识一页，而和另外的两个参数无关，甚至我还要对它做限制好，所以我做个判断， User ID等于0，并且order mode等于一，这个时候我才去启用缓存，否则我就不用我启用缓存怎么用，我就直接return post list，catch点get，然后再把key传进去。

Key刚才不是说了 offset加上一个冒号加上厘米对吧？以此为k就行了，我直接从缓存里返回结果。如果是这种情况下，否则我就还是该访问数据库还是访问数据库，我就不启用缓存了。

当我访问数据库的时候，我记个日志 log debug咱们debug一下漏的post历史，让 DB当访问数据库的时候，我这记个日志说从数据库查数据了，这样直观一点，这样我们一会写测试案例的时候，能够通过这句话能看到我这数据到底是访问数据库取的还是从缓存取的，对吧？如果有这句话从数据库取的，没有从缓存取的。好，这就完了。

再看第二个方法，这个方法也是因为我是缓存的，是我要缓存的是帖子列表总行数对吧？其实我这个方法主要是针对帖子列表来用的，用户查看自己的帖子的时候，他传的用户ID进来，这个时候我是不走缓存的。

好我这样我就判断一下，如果优质ID等于0的时候，这个时候是首页查询我要缓存种的数量。Are you return？Post？Rope。Catch the gate。写一个t其实我们当前就没有，其实不用tea，不用什么条件，因为和use ID没什么关系，他不就在地一定是0，我才去走这个缓存，但它一定要求有一个t怎么办？我就干脆你就是ID作为t它 T永远都是0，那也没关系，然后也是记个日志 log对吧？

然后这里我写漏的post，rose不让DB好，调用的时候是这样，通过调用的时候我们说说明白了 k到底是怎么回事。

再一个我们是这个方法并不是说所有场景都缓存，有限的场景它是走缓存的，好，剩下我就是要对这个缓存进行一个初始化，那么初始化的方式也是固定的，你去咖啡因的官网它有这个实例，我就直接给你写出来了。

Post list cash等于咖啡因，这是一个相当于是个工具类点，new builder这个builder用来构建 new builder点，max，maximum size。

意思是。

你这个缓存你最大的数据量是多少？就是参数max对吧？然后再点 XP after，right？当你把缓存写入到缓存空间里头去以后，多长时间它自动过期还是参数？Spr seconds，然后它的单位是什么 Time？Unit点second单位是秒，然后点就设置好这俩参数以后，这build点调用build的方法，build的方法之后就是让参数生效，同时返回 loading开始对象，build返回loading开始对象，而build需要传一个参进来，这个参数是一个匿名的是一个接口，我们可以通过匿名实现，这个接口需要叫做开始楼的，我匿名实现 new。

 catch load好。

它自动的把这个方法就给我加上来了。

New catch loader，当然 key你看key是string， y6是集合，其实和 k是保持一致。接口是干嘛的就是说当我尝试从缓存里取数据的时候，它会咖啡因会看一下这个缓存里有没有数据，有我给你返回，如果没有怎么办？没有的话他得知道我该怎么去查这个数据，然后把它装到缓存里，所以你要给他提供一个查询数据库，得到初始化数据的办法，漏的方法就是实现查询的这么一个一个办法。

一个方法在这里，你要实现我怎么去访问数据库查数据，或者是这个数缓存的数据的来源是怎么来的，你要在这里解决。好了，然后它参数就是t把它改成叫k就是我们常说的k你要返回 K对应的值。

好，我先判断一下，如果说k等于now或者说 key点less等于0，就是说key是空的，我觉得抛异常了，就不允许为空，就直接说参数错误再来，然后如果不为空，我要解析这个key不是两个数字拼在一起的，我就split一下对吧？

 P点 speed用冒号来切割，切割完以后得到一个string字符串，这是我们要的参数，然后你也判断一下，万一说切完之后不是你想要的， parents等于 nor或者是tyrants点lance，它不等于二，我一定是两切切出来两个值，如果不是两个值就不对，这个时候我还是抛异常。

好，就一定这个参数是对，我才能查到我想要的数据对吧？然后凯尔姆斯里两个值它应该是整数，我把它转型一下。第一个是off site等于integer管理office，0同理 Limit interval of parents e那么有了这俩参数以后，我就可以在这委托我就可以查了，有这两条路我就可以查查我想要的数据了，调什么查调迈克尔。This cast post my program select，然后 uziuzid是0，然后这个是off site，然后是limit，然后是1为什么第一个参数和第四个参数是固定的？

因为我们只这个缓存只适用于这一个场景，其他场景我不管，这俩值此时就是固定的就可以了。

然后在这里我告诉你就这个地方我们在访问数据库之前，你可以自己加一个二级缓存，你可以访问release，如果rise没有你再访问my circle，你这块的逻辑我是直接访问数据库了，你可以把它改成这样子，我先访问release看一下有没有数据，如果没有再访问my circle，这样的话又多了一级缓存，这个就比较容易，反正就缓存到red就可以了。好了，然后这里又访了数据库，我再打一个日志，只要访了数据库我就记个日志，好这就可以了。

同理我们在初始化第二个缓存初始化的方式和刚才一样的， post rose点6x等于咖啡因点new build，然后点max最大的多少个数据，我就和刚才第一个可能保持一致了，我还是利用这俩参数就是缓存15个数据，然后的话180秒，其实这个也够了，我们缓存一个表里的总的多少行数，其实我们1个就够，但15个也无所谓，他也用不上，15个就15个，反正用不完够用就行，这块我写成max，然后再点。

This is pair after，right？然后 x pair seconds，然后 time unit there are seconds。

最后点build。同理里边也是有一个匿名的实现， new catch。low点，那么这个事情还叫key，好这里边这个就比较简单了，我们也不用做判断，反正这是一个整数，我们直接就利用它来查就可以了，我就return this cast post map。对 c let rose把k传进来。可以了。然后在查询之前记个日志，好这就完成了。

那么完成以后我们要看一下这个缓存有没有效，我们调取这个方法，它会不会就让缓存能用起来，我们写一个测试类来试一下，其实测试类我在上这节课之前已经建好了，叫咖啡因test，为啥我提前建这个测试类，我主要是在这个测试类中写了一个测试方法in it data for test。

我想给这个测试初始化一些数据，因为一会我要做压力测试，压力测试的话你最好数据库里数据多一点，然后让访问数据库的性能差一点，这样的话我们好和访问缓存做一个对比，如果你数据特别少，就一两百条数据，其实访问数据库也很快的，突出不了缓存的价值。

当数据越来越多的时候，在数据库里堆积越来越多的时候，访问数据库慢了，缓存价值就越来越大，所以我把它初始化了30万条数据，我就是循环了30万次，然后的话每一次我就另一个post，数据都是一样的，然后插进去，这已经执行完了，他需要跑好一阵，因为30万的数据也不少，然后你看一下我的表里执行现在是30万零一百零一百五十九条数据还好。

好，那已经初始化好了，初始化好以后不用管了，我不跑它了。跑不起，然后的话我在写一个测试方法来测一下这个缓存叫test。

Catch。

怎么测非常简单，我就直接查询调用post service点find this cast pose我就只测这一个方法，这方法没问题， Find rose有没有问题？

好，然后传零0 10一就是不关注用户，然后是按照热门排序，然后0时代表着第一页10条数据对吧？我一共查三次，但我们能猜到第一次缓存里没有数据会访问一次数据库，访问完以后缓存里就有了对吧？这个时候这次访问就能够取缓存中的数据，这次访问又能取缓存中的数据，只访问一次数据库，我们只打印一个日志，所以三次访问只打印一个日志那就对了。

好再来一个第四个我这样我就写一个0，你看这个是查询这个帖子列表，但是我是按照默认的方式排序，这个是不走缓存的，它也会访问数据库，我们看一下是不是我们缓存对特定场景是生效，对这场景是无效这个意思，写完以后我就来执行一下，看一下看输出结果，主要是看日志，你看漏的一开始漏的post from DB访问了一次数据库，然后后面还打印出了对应的circle，然后输出了第一个列表数据，它是一个数组，它打印的是一个数组形态，然后第二次输入第三次输出直接输出值了，就没有漏的，说明没有访问数据库，这个数据从哪来，一定是从缓存里来对吧？

它不可能凭空造出来。然后最后一个输出一条数据输出之前你再看是不是又漏了一次，然后的话又有一个circle，所以跟我们预期的一样，说明这个缓存是有效的。

另外查行数逻辑是一样的，我就不测了。当然了我一会压力测试会测，现在就压力测试，好，那么当然我压力测试之前我还得把这个缓存去掉，我先不加缓存去测一下，然后加缓存再测一下，我先把它去掉。初始化缓存的代码好不容易写的不用它把这几行除掉就可以了，就不走缓存直接查数据库对吧？这也是不走缓存，直接查数据库，再有一个我提前还把 Aspect除掉了，因为要不然每次访问service都打一个日志，我们压力测试有频繁的访问特别烦，我得先提前的把这俩注解注掉，你注意一下。

好，那么压力测试我们需要找一个好的工具来测，咱们不能靠眼睛去观察，或者是我们自己写代码比较麻烦，有好用的工具。那么我选择的工具是解麦特，其实还不止一个工具能搞定，我用的是解麦特，这是阿帕奇提供的一个软件，那么在哪下载？在这个网站上叫解麦，特点阿帕奇点org然后下载的话是点这当漏的，有历史，然后在这里边他有一些版本，那么我下载的是 Zip，压缩包已经下载好了看一下。

在这这个工具很简单，只要把它就是解压缩到哪，然后直接就能用，也不用做什么特殊的配置。好，我就解压缩一下。D盘我去d盘work看一下就在这，然后要用我们就进入b目录，然后的话双击解麦特点bat就可以启动。

当然启动以后这样我需要先把这个服务启动起来，因为你压力测试是利用那个工具模拟客户端去访问这个服务器，然后看一下它的性能，而且是模拟很多人同时访问的是吧？

所以你得先把它起来，我先把这个服务启动一下，好，启动以后我再回到解麦特，为了大家同时能看到解麦特又能看到跑的时候又能看到控制台，我把它弄得扁一点，这就够了。

好，然后的话我们不能上来就运行，我们还需要给它一就做一个测试计划，然后做之前我先点这儿点，选择语言，选择中文简体，这样看起来舒服一点，好。

我就建一个计划添加，这个软件的功能很强大，它能做各种各样的测试，我这只是一个比较基本的简单一点，添加线程组，因为你要模拟大量的用户访问这个数据库，你肯定是要模拟出多个线程来，我需要创建一个线程组可以给它改个名字，我这里就叫index，community index，社区的首页，然后你要模拟多少个线程数，我这里模拟100个，不要搞得太多，因为你的我们是家用电脑性能没有那么好，100个已经不少了，就100个。

然后什么rap up时间，就是这100个线程是在多长时间之内把它创建好一秒，默认就这样。然后再放大一点这个地方选择永远我们是持续执行的，持续执行你也不能一直执行，你要执行到什么程度，我们这里选择一个调度器，然后这里写成60秒，反正我一启动以后，他就创建100个线程就在那跑，就在那访问这个服务器，一直访问直到60秒这么一个意思。

好这是线程组，然后在这个线程组织还要创建一些内容，添加取样器，HTTP请求，你要访问谁对吧？你用什么协议访问谁，这里我们选择的是HTTP请求协议填HTTP这个地方的IP地址，你可以写logo house或者是127.0.0.1端口号，8080方法get，因为这是一个查询对吧？路径 Community。Index。注意我们测的是热门帖子对吧？所以 order food等于是吧等于1，然后编码-8utf-8，好，这是对应请求的一个设置。

然后接下来点线程组我们再添加一个定时器，添加一个统一随机定时器，就是说如果你没有定时器的话，你一启动这个就是压力测试，它就不间断的去访问你这个服务器，很快服务器就瘫痪了，它中间没有间隔，我们 CPU处理不了，没有间隔，我们需要有一定的间隔，你可以中间有固定的间隔或者是随机的间隔，我这用的是随机的间隔，比较模拟自然的状态，因为自然情况下我们访问一个网站也不可能说是一点间断都没有，中间肯定是有一点间隔是随机的，然后随机多长时间，我这里写的是1000，它是随机从0~1000毫秒之内的一个数，是这样，0~1秒之间的一个随机的数，它中间有这么一个间隔，好，再来点线程组再添加一个监听器点聚合报告，最终测试结果我们通过这个报告能够看到，当然它有很多形式的报告，我们看这个就可以了，而且这么多数据我们不用都看，我们主要是看什么吞吐量吞吐量就是什么，每一秒这个服务器能处理多少个请求，这就很能说明问题。

比如说我没有压力测试没有优化之前，它每秒只能处理10 10个，请求优化完以后它能处理100个就很显然它性能提升了不少10倍甚至更多对吧？好，这就配好了，配好以后我们就可以运行了，我点这个按钮就运行，启动时他问你要不要把这个计划保存一下，yes or no都可以，yes吧？

然后它默认存到 b目录下，我就c保存，保存以后它就开始执行了，这个时候你看控制台他就开始走，每次请求他都访问数据库，他就打印 circle对吧？

然后你看这个就卖头，看这个聚合报告，看这个吞吐量大概就是在789不断往上涨，但是可能涨到10甚至多一点就差不多了。

我们跑完一分钟看一下，应该就是10左右，每秒10左右个请求，这是它的处理能力。

那么这个服务器在处理请求的时候，就是说你们在测的时候也不能把线程数测的太少，如果你线程测的太少的话，那么你的电脑就是一个比较清闲的状态，它没有满负荷，这个时候它的性能没有激发出来，还没有到达它的瓶颈，所以它处理的是比较有游刃有余的。因此

它的吞吐量比较大。

然后当你随着你给它加线程数以后，它的当这个线程数到达了它能处理的一个接近瓶颈的时候，它的性能会下降，最好你能找到性能下降的点，比如说你可以一开始给50个线程，然后80个然后100个，然后你看一下，如果说吞吐量一开始还比较大，后来慢慢反而小了，当你线程越多它反而小的时候，就说明它的性能开始下降了，就说明到达它的瓶颈了，我们就用这个点去测。然后的话我们在没有优化之前记录一个值，你看我一分钟完了以后，他怎么1分07秒，因为到一分钟以后他开始释放线程，让线程释放掉，释放这个线程或者说它是线程走完，执行完花了7秒钟，最终是9.5，不到10的吞吐量，每秒处理大概10个请求这就比较差了。

好了，我们就把刚才的优化的代码放出来，我们再执行一遍，当然你为了准确你可以多执行几遍，因为我们间隔时间是随机的，你多执行两遍，反正也大概就是这个数不会偏差太大，我就执行一遍了，然后把刚才的注释去掉以后重启一下，启用缓存以后我们看一下执行结果会怎样，那么再回到这个工具，那么因为刚才你跑了一下，这里面有一些数据，你要把它清掉再跑，不然的话它会累加的，所以你点 SARS扫把清一下没了，完了以后还是100个请求对吧？

我没有变，然后的话好你看控制台这回他是执行了两个circle以后就不执行了，因为这俩数据都被缓存，你以后再去访问数据库的时候，再去访问这个服务器的时候，它基本上直接就返回这个数据就不用走数据库了，这个时候你看它的吞吐量直接飙到了160多，还在往上涨，而原来都不到10，差了10甚至20倍左右，那么他处理的请求这是请求的数量比原来快得多了多得多了。

然后有的同学可能会发现什么呢？这个时候它可能会有一定的异常出现，有可能就是我电脑处理的性能还可以，它可能没出现，有的电脑就是性能比较弱一点，它可能会这异常是表示什么？不是我们服务器报错了，而是说他们看到他处理不了这么多请求，因为你现在处理请求的速度太快，他处理不过来，然后有一些请求就丢掉，丢失了他就没有响应了，是这样的。

或者你一开始执行的时候没有这样多，执行几遍以后就这样了，那说明你 Cpu就已经跑不动了，跑了一会儿你看这回到一秒他释放马上就释放完了。

100个线程不用1分07秒，然后的话最终的是吞吐量的定格在188.9，差了大概十八九倍的样子。

那么经过这样的测试以后，你就很清楚的知道我们优化和不优化加了缓存和不加缓存它有多高的一个性能的差别，无论是你从自身对缓存的认识上，还是你去从面试的角度来说，这都很有好处。

以后我们在工作的时候，

遇到那些性能比较有瓶颈的，访问量比较大的，然后的话这些功能我们都可以用这种方式去解决这个问题。那么一个缓存解决不了的，我们尝试再来个二级缓存，那么可能性就大大的提高，而且性能也会很好。好了，那么这次课我们就演示到这里，咱们下次课再见。