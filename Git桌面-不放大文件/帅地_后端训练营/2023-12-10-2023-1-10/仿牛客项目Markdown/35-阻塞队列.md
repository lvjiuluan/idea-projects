35-阻塞队列.mp4

这一张卡我们主要是学习卡夫卡，那么卡夫卡它是一个目前来说性能最好的消息队列服务器，那么它能够处理tb级别的海量数据处理的数据量是非常大的。所谓的消息队列其实就是用来发消息的，你像游客网这样的社交网站发消息，发送消息是一个非常常见的功能，比如说当用户给你点给你做了一个评论的时候，那么系统会自动的给你发一个消息，告诉你谁评论了你，那么点赞的时候关注的时候也都会做类似的处理，当然也有其他的功能也会发消息，那么这里所谓的发消息并不是说像我们之前开发的私信不是这个用户与用户之间的私信，而是服务器自动的给某些人发送系统的消息，或者说系统的通知，我们私信列表里不是有一个私信，旁边还有一个通知，那个通知我们要用这一张来解决的问题。

那么像这些功能是社交网站的非常常见的功能，而且这些功能它的频率是很高的，很多地方都能够触发发通知，所以说我们需要保证性能的问题，那么我们采用性能最好的卡夫卡去发消息，那么就能够保证性能，所以说这张我们主要是来解决发送系统级的消息或者说通知的这样一个问题。

好，那么第一节我们先来学习阻塞队列，有人会说为什么要学主次队列？不是说要学这个卡夫卡吗？这里我解释一下，因为什么卡夫卡也好，还是其他的消息对这框架也好，它都是框架，他都是做了深度的封装。

那么如果不用这些框架，我们能不能解决类似的问题是可以的，那么我们可以采用注册队列解决类似的问题，也可以用它来实现这个消息系统。

所以但是因为主色队列它比较简单，那么照比这个卡夫卡要简单很多了，所以我们很容易就能了解理解主色队列，理解它以后，他对你这个理解消息系统对你理解卡夫卡它底层做了哪些事儿很有帮助，而且帮助是很直观的。

再一个对我们将来的面试也有帮助，因为面试的时候面试官可能会问你卡不卡相关的问题，也可能会连带着问一些稍微原始的实现方式的一些问题，看看你 Java的基本功怎么样。

因为主色队列其实是Java自带的API具体来说什么是阻塞队列？其实它就是一个接口叫blocking q阻塞队列，那么这是Java核心API中的一个接口，那么这个接口主要是用来解决县城通信的问题。当然了我们解决线程通信的问题其实不只是这一种手段，我们利用什么不Jack的类当中的胃疼的饭这样的方法也是可以进行线程通信的，只不过那个方法比 Blog跟q它还更原始更麻烦。

所以说我们通常如果说我们在gdk中直接选APA解决这个问题的话，我们还是更倾向于选 block、q注册队列，那么注册队列它怎么解决问题，其实它主要是依靠两个方法，这两个方法都是阻塞的，一个是put往队列里存数据，一个是take从队列中拿出一个数据，是存一个，take是拿出一个。

那么右边我这里画了一个图，就是解释了一下 block q它的大概的一个工作的方式，那么中间这些蓝色的小格子就是我画的一个假设它就是主色队列，假设队列的空间一共有8个位置，它里面能存8个数据，有8个空间，然后那么它是解决线程之间的通信的问题，比如说线程一和线程二想要通信，那就可以这样形成一调用库的方法，把数据放到队列里，然后线程二调，用这个方法从队列中取一个值。

好，有人说这样做有什么好处吗？你注意这样处理问题的方式，其实它是满足一种模式，叫做生产者与消费者模式。那么在这个场景下，新城一往队列中存数据，或者说它是产生数据的线程，我们称其为生产者线程。二是从队列中拿数据使用数据，我们称之为消费者，我想很容易理解它很直观。

那么 Blocking q其实它就是在两个线程之间，或者说生产者与消费者之间构建了一个桥梁，构建了一个缓冲的空间，避免你两个线程之间直接打交道。

如果两个线程抛开了 block q他直接打交道可能会有一些问题，比如说有可能我生产者他生产数据的速度特别快，远远快于消费的速度，你可想而知了，如果说他直接把数据给他，他这边处理的速度慢，很快，他就达到了瓶颈，这边生产的话就得但是如果说它没有一个缓冲的话，它还在一直生产，还在占用的 CPU的资源，它没有被阻塞，这个时候系统的性能就会白白的浪费掉。

或者反过来说，如果说生产的速度很慢，消费的速度很快，很快它的数据就被消费光了，但是这边还抢着要数据，还在占用系统 CPU资源，还在获取数据，但是取不到，所以说也是做无用功，也是浪费系统资源。

如果说中间有这么一层block and q那就好了，那么我生产的数据放到队列里，我就可以继续生产，直到如果说我生产的速度快，直到把 q堆满了，当队列满了以后，那么破的方法就被阻塞了，或者说线程一就阻塞了，你知道阻塞的时候就是说他什么也不做，只是在这等着这个时候他也不会占用系统资源，这就是阻塞的好处。

或者反过来说，比如说我生产的速度慢，消费的速度很快，这个时候他很快把队列中的数据消费光了，这里没有数据了，这个时候线程二被阻塞，也就是说他在这等着从队列中取值，当你有值的时候，这个时候它也不去占用 CPU资源，对系统的性能也没有影响。

总之这个阻塞队列其实是在两个线程之间起到了一个缓冲的作用，能够避免 CPU的资源的被浪费掉，能够从这个角度来提升系统的性能。

好总而言之，那么总之我们多个线程之间的通信用这种方式是非常切实可行的，你有数据就往队列里丢，然后你该做的事儿如果丢满了你就阻塞就完了。这边反正我就等着有数据我就去处理，没有数据我就等着，这样的方式非常的高效。

那么 block q它是一个接口，我们不能直接拿来用，我们需要使用它的实现类，然后 GDP当中带来很多实现类，有这么多，有 every blocking q底层是用速度实现的队列，有link blocking q用链表实现的队列还有其他的等等各种队列的形式，然后当然这里的每一种队列，那么它都有它的一些特点，或者说它有它的一些特定的规则，特定的用法。

那么我们这次课其实主要是告诉大家阻塞队列是什么，然后的话它基本上是怎么用，所以我这里随便拿一个简单的瑞普拉QQ给你演示一下。至于其他的，如果你想了解自己查一下 Java的一篇就可以了。

好了，接下来我给大家写一个小的程序，咱们来演示一下阻塞队列它是怎么用的，那么我打开我的开发工具，这只是一个演示的案例，不算是我们正式代码，所以说我把它写到 test包下。

然后这里我新建一个类叫blocking q test，主测队列的一个测试的案例，然后主测队列我就直接在main方法中写程序进行测试，我就不写这个结论里头了。

然后阻塞队列它仅它是满足这个生产者与消费者模式的，所以说你这里得有生产者现成，还得有消费者现成，通常我们会额外的定义两个类，所以我在这里直接定义一个生产者和消费者的类，当然你在外面定义也可以，在这里面直接定义也行，但前提是不要写public，因为一个文件里只有一个类可以是public，好，我上面一个类叫生产者，producer，那么因为它是一个线程，所以说我要实现 one more接口，当然你要实现这个接口需要实现它的乱方法。

好，那么除此以外，就是当我实例化 producer的时候，线程的时候，我要求你调用方把队列传进来，把阻塞队列传进来，因为我们这个线程是要交给阻塞队列去管理，调用方式你要把队列传进来，所以这里我增加一个变量来接收一下你传入的组织对立 block q。

好，那么 block control这里你可以通过泛型声明，它里边存的是什么东西，比如说我就存整数，但是你存什么都行，这里我简单点存整数，然后我就要给变量取名叫q我希望你在实例化 producer类的时候，就把 q传进来给我，所以我再给它加一个有参的构造器， public producer，然后的话你把 blocking q传进来，好，然后我把它赋值给当前对象的 q变量。

好了，然后接下来我就写 run方法，这只是一个小的事例，没有什么业务逻辑我就随便写了，这样我先去开始一下，开始到异常以后我就简单的输出一下，好，那么在这里比如说

我要频繁的不断的往队列中存放一些数据，这样比如说我要循环个100次，就是说我是一个生产者，我要生产一共生产100个数据，每一个数据我要把它放到队列里，放的时候我们最好中间有一个间隔，因为你不管是生产什么的企业也好，还是组件也好，它不可能是中间没有任何间隔的，所以说我们给他有一点间隔，所有的实力这里我停顿20毫秒，好，那么每每20毫秒我要生产一个数据，就是一个数 I我要把 I交给队列来管理我就q这是一个put，这个方法就是一个阻塞可以阻塞的方法，当队列满的时候它就能阻塞我们一会执行的时候能看到这个效果，我就把 I存进去，I就是我生产的数据。

好，然后放到队列中之后我打印点东西，打印什么？我首先打印当前的线程。是谁？ Straight character。点。Get name，我获取当前线程名，然后加上生产。

我希望它打印出当前谁在生产，然后生产完以后我再打印出q点sin它生产了一个数据以后，这个时候队列中有多少个数，我想直观的看一下，好，就这样了。

总之我生产者的产能有限，它只能最多生产100个数，每次把树放到队列里，然后我打印了这么一句话就完了。好，接下来我们再写一个消费者线程，然后我们再去调，同样的我也是在这里写一个类消费者，然后也是你要实现让他们结合好。

接下来处理方式也和刚才的生产者线程是类似的，就是说我们在实例化类的时候也需要传入 q这样我copy一下，当然这个类名你要改一下，其他的地方不用变，肯定三码没有问题，那么这个乱方法之内我写一个逻辑，就是说我生产者消费者我就一直不停的消费，只要你对这种有数据我就消费，我这样写也是先处理个异常。

有异常我就随便输出一下。

好，然后只要有数据我就一直消费，我就用 while循环死循环，然后每次循环我要获取数据，获取数据就是调用队列的，每次take就是从队列中弹出对手的值，然后我们消费的时候也有一定的时间间隔，也有个时间间隔，我就是热爱的点，实力的这也是模拟一个真实的业务，你想我们用户访问一个网站，无论是它产生一些数据也好，还是它使用一些数据也好，它肯定是有时间间隔的，不可能是无间隔的。

而且用户消费数据使用数据时间间隔往往还是不确定的，有时快有时慢，所以这个时间我不把它写死，而生产者服务器它处理这个数据的时候，我把它间隔写死成20毫秒，但这个我不写死。

我写一个稍微随机一点，那就new render点。

 next internet。

然后1000，这句话的意思是在0~1000之间属于一个数，你可以可想而知，我们大概率的隧道的数应该比20要大，对吧？

因为这么大一个范围它属于到20更大的比二十大的数的几率是更多的，也就是说其实我消费者他的消费能力没有生产者那么快，好，然后间隔完以后我就q点take使用这个数据，至于这个数据是几我并不关心，反正使用了，使用以后我再打印一句话，还是要spread一点儿。

其他人失败的概念内容，我想看一下当前的消费者线程是谁，然后写上他消费了，然后再消费完以后，我再把 q的size打印出来。

好知道消费完以后队列中有多少数据，好了，生产者与消费者线程的处理的逻辑我就简单写完了，只是一个模拟，写完以后我回到命运方法当中我要去调，那么我在命运方法当中先实例化主色队列，因为生产者与消费者要共用一个主色队列，不到QQ。62位 lock in q然后它的底层是由数组来实现的，所以说你要传入一个数字，表示说默认的话这个数组的长度是多少，或者说队列的容量是多大，我写个10，这个队列中最多只能存10个数。

然后接下来我就实例化一个生产者，我需要实例化一个生产者的线程，线程体是 producer，当然你new producer的时候需要传入q好，那么然后我要启动这个现象，new spread以后要启动start，这就是有一个生产者现场在不断的生产数据，但是它最多生产100个，然后我们再创建消费者现场6选3。然后也需要传入 q然后启动这里我把消费者多搞几个，就好像一个工厂一样，我工厂只有一个，但是消费者有很多个。

好我再写两个，我整个程序当中就一个生产者不断的生产数据，三个消费者同时消费数据并发消费数据。好了，这个测试程序就写完了，写完以后咱们执行一下，看看看一下什么效果，它是一边生产一边消费，需要有一个过程，但过一会就停了，因为最终的话也就是

一共生产100个数据，过一会就停了，咱们稍微等一下，停完以后我们再从头开始看好。

停了。其实我们主要是看头和尾就能看出一些问题来。总体来说刚才我们也分析了是生产者生产的速度快，它每隔20毫秒就生产一个数据，消费的速度慢，但它的速度是随机的，也有可能快，但是快的几率很小。

因此你看一开始生产的生产者的速度快的优势就体现出来了，那就生产数生产数据生产完队列是一、234一直到10，因为它速度快，所以很快生产者就生产了10个数据把队列给堆满了，这个时候他就不再生产了。

然后这个时候消费者开始消费完以后变成了酒，变成酒以后，队列布满了生产者就又可以生产，立刻填充为10，然后再消费9又10，再消费9，又10，以此类推。

无论如何生产者生产完以后数量是10，它是这个规律是保持不变的，它不可能超过1010是上限，总之在中途就是不断的交替了，反正你你刚消费一个我就生产一个，而且你看消费者他应该是交替的，一线程一消费，线程二消费，线程三消费对吧？

他们是交替进行的。

好，然后最终中间过程都是这样的，然后我们看最后快结束的地方，最后那么你看最后是生产者，最后第一百次生产完数据以后，这个时候队列是满的10，然后他就不再生产了，这个时候这三个消费者就开始消费，这个时候没有生产的行为，消费完以后9876543210直到0为止，这个时候程序还没有结束，消费者还在等着消费，但是因为生产者不生产了，停产了，所以说这个时候程序就一直阻塞在这不动了，这是这样一个过程。

所以说通过这个过程头和尾能看到 Put和take方法它的一个主色的效果，你明白这一点就可以了。

好了，那么这次课我们主要是介绍了主色队列，介绍了生产者与消费者模式，然后的话也给大家写了一个小的事例，把主色队列做了一个演示，那么课后的话如果你有时间，最好你去看一看其他的时间内他们的作用，因为当你去面试的时候，面试官可能不只是问到这个地方，不只是问到这种程度，他有可能问你其他的这些实现类，你自己去看一看会比较好。好了，那么这次课我们就演示到这里，咱们下次课再见。