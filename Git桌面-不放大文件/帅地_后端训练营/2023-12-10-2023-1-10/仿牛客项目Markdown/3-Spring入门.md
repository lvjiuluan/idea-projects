## 1.3 Spring 入门

这次课我们来学习 Spring，Spring 之前我们也提到过，它不是一个框架，是一套框架。我们项目中基本上所有的需求 ，Spring 都能帮我们解决，它能够给我们提供了非常全面的解决方案。Spring 这套框架把他们加在一起，我们通常称其为 Spring 全家桶。Spring 全家桶它大体上分为 4 个方面：

1. Spring Framework，它是基石，是核心。

2. Spring Boot， 我们可以利用它的构建项目，在这个项目的基础上去做 Spring 开发，会更容易更方便，上次课我们也做了演示。

3. Spring Cloud，就是做微服务的，如果说我们有一个很大的项目维护起来比较困难，我们可以利用 Spring Cloud把它拆分成若干个子项目，把他们再集中在一起，每一个子项目它的规模比较小，就便于维护了，但同时开发的难度会有所提高，是这样的。

4. Spring CloudData Flow，就是 Spring 做数据集成的这么一个功能，比如说你的应用有很多客户端，包括移动设备传感器，还有可穿戴设备，甚至是汽车等等，有很多客户端，这些客户端所采集到的数据形态各异，怎么把它们集成在一起，整合在一起，形成更有价值的数据是他所做的事情。

当然这 4 部分功能我们不会都用上，因为我们这个项目本身它就是牛客网的一个模块，他还没有必要去往下拆分，所以微服务就不用去做了。

我们这个项目只有浏览器一种客户端，也没有多客户端，所以 Data Flow 也用不上，我们会用前两种。

Spring 全家桶它所有的内容文档手册，都在它的官网上， spring.io 上能够查阅到，咱们可以看一下。这个就是它的官网，你往下看，它这里有一些大概的介绍，你的应用如果只是做基本的Web相关的开发，你用Spring Boot是可以搞定的。

如果你想做微服务，Spring Cloud可以帮你搞定，如果你想有更多的客户端数据集成可以用 Data Flow，它能连接一切，这就是它的整个产品的一个生态的结构。

总之无论是什么样的应用都能用它来解决。当然这些内容它都是基于Spring框架的，它是基础是核心。

这一页是对整个 Spring 产品的一个概要的介绍，更详细的内容你可以在这里找到 Projects，其他的模块其实也是Spring的子模块。因为Spring Data相对独立，也比较用的比较多，因此它也单独的拿出来，让你能够直接方便查到我们的课程里后面会用到Spring Boot访问数据库，用到 Spring 的 Security 做安全的控制，权限管理，还有 amqp 用来做这个消息队列，主要是用到这些内容。

好了，我们再回到 PPT，我们这次课重点是讲 Spring， Spring 它有很多功能，我们课程中也不会都用到，我们用到的是 4 大部分，第一部分是 Spring 的核心，它包括 IOC和 AOP两部分， IOC和 AOP它都是用来管理对象的一种思想，由Spring所管理的对象，我们通常叫做 Bean，它是用来管理Bean的思想。

 IOC也是基于面向对象的一种管理对象的思想，而 AOP是一种面向切面编程的思想，它是对面向对象思想的一种补充，总之Spring有了这两种思想能够管理一切Bean。

所以说哪怕是你有一个别的框架，第三方的框架，拿过来他也能够进行管理进行整合。所以 Spring 它牛，不是说它的功能多，而是它牛在它有这两种管理Bean的思想，就能够管理一切。

那今天我们重点学的是 IOC，后面的课程里，我们会学第二个 Spring Data Access，就是 Spring 的访问数据库的功能，我们会用到用它来管理事物，我们会用它来整合 MyBatis。

第三个是Web开发，我们会用到它的 Spring MVC 这一块。最后一部分是集成，我们会用 Spring 去发邮件，去做定时任务，去做消息队列，发送消息，去做安全控制，这是我们课程中要用到的内容。

Spring 还有更多的内容，你可以从官方的手册里面能够查阅到。咱们简单看一下，就 Spring 进来以后这是一个概要的介绍，详细的是在论之内。

标有 Ga 的是它的正式发布的版本，最高的版本是 5.1.7，你可以点这个 reference，这里面它是归类：核心，测试，访问数据库等等。我们课程中所体现的内容其实就是这些内容中的一部分，你想看哪一块点进去看就是了。

好，因为这个内容比较长，所以说我们课堂上不去给大家看了，这个是你们课后自己可以去查阅的，作为一个课堂内容的补充。

好，我再回到 PPT，关于 Spring 我们首先要学的是 IOC其实 Spring 所有其他的这些个功能都是构建着 IOC 之上的，或者说他们都是以 IOC 为基础的，所以必须先学好 IOC，其他的功能才容易学会。关于 IOC首先你要理解什么是 IOC。IOC它是一组单词的缩写，叫做 Inverse Of Control。

翻译过来就是控制反转的意思，这是一种面向对象编程的设计思想。

初步解释一下，比如说我们不用 IOC，我们自己管理对象通常是这样的，我 new 一个对象 a， 再 new 一个对象 b， a 点 set传入 b 这样的话 a 和 b 就有了联系，我可以通过 a 去调用 b 对吧？这是我们经常会做这样的事情，这样做的话是比较直观的，也比较直接，但是它有一个缺点就是 a 和 b 产生了耦合，直接就耦合在一起了。

当我们的项目规模变得比较大的时候，可能就会不好去维护，可能你改了 a，b 也要顺带改， 这是他的问题。

IOC 思想就是说他不用这种方式去建立Bean之间的关系，他用另外的办法去建立Bean之间的关系，从而减少Bean之间的耦合度，让这个项目能够便于维护，是这样的。他是怎么去实现这个思想的，主要靠的是依赖注入的一种方式，这是它的实现方式，而依赖注入的实现方式。它又基于 IOC容器，它是实现依赖的关键，其实它本质上就是一个工厂，一会我们看代码能够深有体会。

右侧这个图是我从官网手册上截取了一个图，他演示的是 IOC 大概的一个原理，其中 Spring Container 就是 IOC 容器，容器帮我们管理 Bean 的前提，是你要给他提供两份数据，两种数据：一种是你要管理哪些Bean，这个Bean的类型你要给他；第二个你要给他配置文件，给他配置，通过配置描述这些Bean之间的关系，它就能够自动的实例化这个Bean，让你去调用。所以说在容器管理Bean的前提下，这个Bean与Bean之间不会直接产生关联，他们的关联关系是体现在配置当中的，Bean的耦合度就降低了。

好，这个思想还是有点抽象，没关系，下面我们写一些代码，通过代码去体会一下它到底是怎么回事。

好，下面我就打开这个 IDEA，在写代码之前我先解释一下我们上次课所写的代码当中的核心的类，CommunityApplication，就解释一下这个类它运行的时候它都做了哪些事情，你了解了大概的过程以后，对理解 IOC 也是有帮助的。

类其实代码挺简单的，类方法就一句话，SpringApplication.run，就是 Spring 应用运行了启动了。

当然我们知道它的底层启动的 Tomcat 对不对？因为我们访问过，其实它的底层不只是启动了 Tomcat，除了启动Tomcat之外，他还做了另外一件事儿，他自动的帮我们创建了这个 Spring 容器，就是说在Web项目当中Spring容器，不需要我们主动去创建，它是被自动的创建的，在这个方法底层做了这样的事情。

Spring容器被创建以后，它会自动的去扫描某些包下的某些Bean，将这些Bean装配到容器里，哪些Bean会被扫描到，我们得看这个类，它是run方法的参数。

Spring 应用在启动的时候，它是需要配置的，这个类其实就是一个配置文件，因为你看这个类上有注解所标识的类，就表示说它是一个配置文件。我们可以点 ctrl 进到类的底层去详细看一下，这个注解是由其他注解所组成的，你看注解，SpringBootConfiguration表示类是一个配置文件，再看注解内部 Documented，Configuration。比方说要启用自动配置，所以为什么我们几乎不用做配置，也能把服务启动起来呢？

因为它启用了自动配置，给我们配了很多东西，这个是组件扫描，那意思是它会自动的扫描某些包下的某些Bean，装配到容器里，所以说为什么它会自动装配？并因为你启动了组件扫描，它会扫描哪些？不是全部的。是这样，它会扫描配置类所在的包以及子包下的Bean。你想我们的程序当中像 controller 以后还会建别的包，所有的类都在这个包下，都是它的子包对吧？所以说所有的Bean都有机会被扫描到，这是第一。第二个还有一点，这个Bean上需要有像 controller 这样的注解才能够被扫描，如果没有这样的注解就不会被扫描。

和这个 controller 就是等价的功能一样的，还有几个注解，还有搜一下看还有 service 在这，service 就是说如果你加 service 注解也是能够让这个Bean被扫描，你看这个 service 其实它是由 Component的来实现的，所以说如果在 bean 加上 Component也可以实现被扫描，还有一个叫 repository，它也是有可能的实现的，所以说你加它也可以被扫描。其实这个 controller 也是有 controller 的实现的也可以被扫描，就是说我们平时一共有 4 个注解，可以用你把任何一个注解加到一个类上，这个类就能够被容器所扫描了。他们的实现机制其实都一样。他们都是有component来实现的，所以说他们的功能都一样，那区别是在于语义上的区别，就是说如果说你开发的是一个业务组件，你最好用 service 注解来标明，如果你开发的是一个处理请求的组件，你用 controller 来标识，如果你开发的是一个数据库，访问的组件，你用这个Repository注解，如果你开发的它在任何地方都能用访问数据库处理请求或者是处理业务都能用，你可以用 component通用的好了。总之这 4 个注解加到Bean上，使得这些Bean都能被自动扫描到，我们用哪一个都行，但是最好是按照刚才所说的建议去做，你一开始可能记不住，没关系，后面的话我们的课程里会经常的用熟了就好了。

好，关于 CommunityApplication 这个类，他大致做了哪些事情以及注解，他主要做了哪些事情，我们做了一个解释，让你知道了这个容器是什么时候被创建的容器中的，Bean是怎么来的，了解到这一点。IOC 的话，其他的内容就容易理解了。好了，介绍完以后，接下来我们就来写一些代码，来演示一下 IOC 的使用方式，这个代码我在这个测试类里进行演示。

我们正式运行程序是运行这个类，刚才也说了，它也是个配置类，一运行就以它为配置类来执行程序，我们测试的代码当中肯定也希望也用配置类，也希望和正式环境用的配置类是一样的，对不对？

怎么在测试代码中启用类作为配置类呢？其实也很容易就加一个注解叫 ContextConfiguration，括号里面加上 classes = CommunityApplication.class，我们一会运行的测试代码就是以它为配置类的。

我们 IOC刚才说了，它的这个核心是 Spring 容器，而容器又是被自动创建的，我们怎么去得到这个容器其实也很方便，哪个类想得到 Spring 容器，你就实现这样一个接口，叫 ApplicationContextAware，有一个方法需要你实现。

这个测试代码我先不要了，一会用的时候再加上，这是一个set方法，传入参数，叫ApplicationContext， 这个参数其实就是Spring容器。它是一个接口，看一下这个接口要继承于它BeanFactory，BeanFactory 就是Bean工厂，它其实 Spring容器的顶层接口， ApplicationContext是它的子接口，它比父接口扩展出了更多的方法，它的功能更强一点。

所以通常我们会用子接口、ApplicationContext。

好再回到测试类当中，如果说我一个类实现了接口的方法，Spring容器会检测到，Spring容器在扫描组件的时候会检测到这样的，并调用它的set方法把自身传进来，把容器传进来。

所以我们只需要把这个容器暂存一下，记录下来引用一下，我们后面的话就能够使用它了，所以我在这个类当中加一个成员变量，用来记录什么？容器applicationContext。

好，加个成员变量，这里边把它记录一下。好了，当这个当程序运行的时候， ApplicationContext就自动的被传进来，我就自动的做了记录，我在其他的地方就可以去使用了。

下面我就写一个测试方法，在这个测试方法里面去使用一下，这个方法名我叫做 testApplicationContext 测试，Spring 容器在这儿怎么测，我就这样，我就直接把这个对象打印出来看，看它有没有值，看它是一个什么样的对象。

好，我就运行一下测试方法。

好，我们看控制台，你看它打印出来信息，打印出来的是org.springframework.web.context.support.GenericWebApplicationContext@7671cb68，这是对象的输出的形式。这个类型是 GenericWebApplicationContext，这是实现类的一个类名，我们 application contact 是接口好了，那就证明了这个容器是存在的，是可见的。

下面我们演示一下这个容器我们怎么去用它来管理 Bean，当然你要用它管理 bean，首先你得有 bean 让它去管理对不对？

下面我们就写一个 bean，这样我再建一个包，比如说我要访问数据库，我要去查询某些数据，我再建一个包，这个包下专门存放访问数据库的那些个Bean，好这个包我叫做 dao 就是 data access object 数据库访问的对象，我的包下创建一个访问数据库的接口，这选成接口，这个接口名字我们现在不是真正去访问数据库，就是一个演示，所以我就取得稍微随意一点这个名字叫AlphaDao。

这个接口我需要定义一些方法，因为是演示我也简单一点，定义一个非常简单的方法，谁来比如说我要查询没有参数，返回一个字符串就可以了。当然了这个接口还不能直接用，你还得有实现对吧？我再给它加一个实现类，我再创建一个该接口的实现类，这个类我叫AlphaDaoHibernateImpl 假如说这个时间内我是采用 Hibernate的技术来实现的查询，所以我叫AlphaDaoHibernateImpl 实现的意思， Ok。

当然它需要实现刚才的接口，AlphaDao增加接口的未实现的方法，这个方法我也简单一点，就直接返回一个字符串， Hibernate完了就这样，当然这样还有所欠缺，你这样的话，这个Bean是不能够被容器所管理的，或者说容器是不能够扫描并装配它的，容器扫描Bean，对什么样的Bean，包下他满足了对吧？

其次它的上面有一个注解，所以说我给他加一个注解，访问数据库的 Bean 应该加什么？ Repository。好，这样就可以了，只要我们运行程序，Spring 容器会自动的扫描到这个Bean，把它装配到容器里，我们可以看一下，再回到 test 方法。

好，我还是在刚才的测试方法里进行一个演示，这回我要从这个容器里获取它自动装配的Bean，好，它的类型我可以把它向上造型为接口，阿尔法道等于 application，content，容器你获取Bean就调它的获取Bean的方法，get 你可以通过名字获取，可以通过类型获取，我们通常可以按照类型获取，这个Bean的类型就这个类型，当然你写成接口类型也可以，阿尔法到 there class，我要从容器中获取类型的Bean，得到了得到以后，我调用一下阿尔法到点 select，我调用它的查询方法，并且将结果输出出来。

好了，下面我们运行一下这个方法，再看你看最终的输出结果还有问题，成功了对吧？我们成功的获取到了这个Bean，得到了查询的结果，没有问题。有的同学可能会有所怀疑，我倒是看明白了，但是这样有点麻烦，还不如我们自己实例化，这有什么好处，我们得了解它背后有什么好处。下面我再写一个Bean再写一个Bean，通过这个Bean你去体会它的优势。

比如说有一天我们这个项目发展到一定阶段，有一个新的技术诞生了，比如说买卖类似，假设它比 heaven 更为更有优势，我们在项目中想把 happiness 替换为 MyBatis，在这样的项目中我可以这样做，我可以再新建一个到的实现类，而不用把它删掉，我叫阿尔法到 I bet is apple 也是实现类，好，也是要实现接口增加待实现的方法。

这个方法我要返回的是 MyBatis，说白了实现方式和刚才同时它也得加上注解，也可以被扫描到被抛弃的人。但是你注意这样还不行，这样还不够，你这样去运行刚才的程序就会有问题了，有什么问题呢？就是说我要按照类型去获取，并这个类型是个接口，这个接口满足条件的并有两个，一个是一个是它对吧？

这俩都满足接口，所以说死Bean容器就不知道该给你哪一个Bean了，有歧义了，这个时候就会报错，这种情况怎么解决也好办，我只需要呢在我希望的Bean上再加一个主角 prime，加上以后这个Bean会被优先的装配，或者会当你调用的时候，它会优先给你，它有更高的优先级，好，加上以后咱们再试。

我再回到刚才的测试方法，再次运行一下，好，你看这回它打印的结果就是买卖点，所以你想一下，这就是它的优势，就是我的程序当中，原先所有的到的时间内都是由 happen 的实现的。

我调用这个Bean的地方会很多的，会很多的。当有一天我想把这个Bean替换掉的时候，其实很简单，我只需要再加一个Bean，多加一个 promise，prime 注解就行了。

我们调用的地方完全不用变，因为我们调用的这个地方依赖的不是这个Bean本身，依赖的是它的接口，这也是利用了面向接口变成的思想，我依赖的是接口，它实现类变了，我这是不用动的，这非常的容易好。

所以说 Spring容器就通过这种办法降低了并执行的额度，我们调用方和时限内不会发生任何的直接的关系，是这样的。

但是这样可能会带来一个就是新的问题，比如说我程序的某一块儿，我还想用这个 habit，我不想用 MyBatis，就比较特别，我就这一块儿要用 habit，但是你这样获取的话，永远都获取的是 MyBatis 的实现，我怎么能得到哈尔滨的实现的Bean也好办，其实Bean每一个Bean它都是有这个名字的，being 的默认的名字是类名，首字母小写，如果你觉得这个类名比较长，你也可以拿去自定义一下他的名字，我们怎么定义一个Bean的名字，还是用注解加个括号，括号里面写上字符串就是并的名字，比如说这里我写上阿尔法，还有问题，这个Bean的名字阿尔法还有问题。

好了，给这个Bean重新自定义完名字以后，我可以通过名字强制容器返回这个Bean给我，我们来演示一下看看。

在这个位置我再重新的获取一次Bean，阿尔法到等于 application context 点 get，并这回你要通过名字获取就不是类型了，那名字是阿尔法到阿尔法还不能听，他得到的类型是默认是 object，因为他不知道是什么类型的，因为你这样 get 并没有给它类型，它返回的是一个 object，你需要强制转型，或者是你可以再加一个参数。阿尔法到克拉斯意思是说你得到的 Offer 价格你帮我转型成它也可以，我就再访问一下到时代，写完以后我再次执行这个方法好。你看第一次输出的是 my business，因为它优先级高，第二次我是指定了Bean的名字，就得到了哈尔滨的Bean，没有问题。

好了，以上就是我们从这个容器中获取Bean的基本的方式，这个容器管理Bean不只是局限在能帮我们创建Bean，它还有更多的管理并的手段，下面我再给大家演示 Spring 容器管理Bean的更多的方式方法，Spring容器它除了创新Bean之外，它还能够帮我们管理Bean的初始化以及销毁的方法，接下来我再写一个Bean给你演示一下，这样我这回就不用这个道了，我怕把道的代码改给它改乱了，我们再新建一个Bean，假如说我要开发一些业务组件，处理一些业务，我们通常会把业务组件单独放一个包下，这个包叫做 service 会有很多这样的组件，现在我在我就新建一个例子，比如说我取名叫阿尔法 service，这个名字也是比较随意的，我也希望这个Bean是由通过容器进行管理，所以我需要在类上增加一个注解，它是一个业务组件加的注解，应该就是 service。

好了，刚才我说了，说这个Bean我希望由容器来管理，不只是创建，它还希望容器管理它的初始化和销毁的方法，怎么管理？我首先给并增加初始化方法 in it。这里我随便的打印一句话，叫做初始化阿尔法 service。

要想让容器帮你管理这个方法，其实就像容器在合适的时候自动的调这个方法，你只需要在这个方法之前加上一个注解叫 post construct，注解的意思是这个方法会在构造器之后调用，初始化方法通常是在构造之后调用用来初始化某些数据，为了便于观察这个方法，它调用的时刻到底是不是在构造器之后，我给这个类加一个构造器，好，咱们好对比一下。

构造器里我也是打印一句话，就是实例化阿尔法 service 除了管理初始化方法，还能够管理销毁方法，我再给这个类加一个销毁方法，叫 destroy。

好，这里也打印一句话说销毁阿尔法 service，这个方法上也需要加一个注解，这个容器会自动的调用它，注解是 I destroy 就是说在销毁对象之前去调动它，为什么销毁之前，因为如果是在对象效果以后你就没法调了，对吧？

一定是在销毁之前调一下，你可以在这里释放某些资源，写完以后咱们测试一下，看一看我们通过容器能不能自动的去调初始化以及销毁的方法，我再回到测试类进行演示。我就再写一个新的测试方法，这个方法我叫 test，并 many 的就是测试一下Bean的管理的方式。

首先我要演示的是我要通过容器去获取 Service，看一下会出现什么样的情况，阿尔法 service 等于 application。Contact 点 get 我们就按照类型去获取，因为这个阿尔法 service 就是它是一个类，我没有写接口，这样方便一点。阿尔法 service their class。好，获取到 b 以后，我去把 b 就直接打印出来，看一下这个对象是否存在。好，我就运行一下，看一看会是什么样的结果看控制台最终他确实打出了这个对象，说明确实能够实例化， b 没有问题。

我们看一下这个点，这个是程序启动的过程，输出的内容，包括 Spring容器的一个创建的过程。

在这个过程当中你会看到有这样的输出，实例化，阿尔法 service，初始化阿尔法 service，最后销毁阿尔法 service，也就是说并的初始化方法确实是在构造期之后被调用的，销毁方法确实是在程序结束之前，对象销毁之前调用的，在初始化和销毁之间，我们打印出来Bean的实力没有问题，好了，因为我们看到了这样的现象，就是说在程序启动的时候， Bean 被实例化，程序停止的时候，Bean 被销毁，能说明一个什么问题呢？

就说明这个Bean其实它只被实例化一次，它只被销毁一次，它在容器中只有一个实例，它是单立的，为什么这么说？你想象一下我们的Web程序是不是只启动一次对吧？ Main 方法只启动一次，所以说并被实例化一次，它就只有一个实例，不信的话我们可以再来一次，我再去获取一下这个Bean，再获取一下这个Bean，把它打印出来。

我们看一下它是实例化两次还是一次就能就知道了，这个结果我运行一下这个方法，首先你看打印结果，打印出来这两个对象好奇客户的是一样的，是一个对象。

在程序启动的过程中看日志，也只实例化了一次，就说明被容器Spring容器管理的Bean，它默认是单个实例单立的。如果说你不希望它单立，你希望每次 get 并它都新建一个实例，也不是不可以也可以怎么办呢？我们就需要在Bean上再加一个注解，叫 scope。它的作用范围是整个容器中有一个还是整个容器中有多个？死扣不它的默认参数就是辛苦的，心都疼，这是单例的，这你不用写，如果是想多个实例，你要写这样一个单词，PRO to tap。

当加上这个单词以后，我们每次访问遍，他就会给我们创造一个新的实例，咱们来试一下，再运行刚才的测试方法，好，你看这个控制台输出结果，这回就不是启动时初始化了，而是在具体我们盖的Bean的时候，每次盖的Bean他都实例化一个，每次盖的Bean都实例化一个，是这样，所以实例化两次就是两个Bean奇克的也不一样。

当然了，我们通常情况下都用它默认的方式，这个Bean都是用单例的形式，很少说有用多实例的形式比较少，基本上我们的项目中都是单立的，所以说我把注掉，以免让大家以为我们要经常这么做，以免对你造成误解。

好了，这是 Spring 它能帮我们管理这个Bean，其实是管理Bean的作用域，它的有效的范围这么一种情况。

以上我们用死Bean容器管理的都是我们自己写的Bean，都是我们自己写的类，有些时候我们可能希望这样做，我希望在容器中装配一个第三方的笔类是人家写的是在 Jar 包里，这个时候我就不能像这样，我去类加上一个注解，因为那是人家写的类对吧？

你不能轻易改，再一个他打到 Jar 包里去了，可能还没有源码，这种情况怎么做？其实也很方便，我们需要自己写一个配置类，在配置类当中通过并注解进行声明来解决这个问题，下面我就给大家写一个配置类，装配一个第三方的 Bean。

好，我们项目当中会把以后会有更多的配置类，我们会把所有的配置类都放到同一个包下，新建一个包叫我在这建一个配置类的示例，也是没有什么业务含义，我还是叫阿尔法可能这一块。

好，当然了我们标识配置类也可以用类似于这样的注解，什么 Spring application，但是其实没有必要，通常是程序的入口用注解，我们一个普通的配置类，一般我们用叫腾飞哥瑞森表示这个类是一个配置类，不是一个普通的类，你要定义第三方的 Bean 需要加一个Bean注解在方法之前，这里要定义一个方法，我要装成一个什么，并假如说我要把咱们 Java 自带的 simple date format 装配到容器当中，因为 simple 的，因为我们在一个项目当中可能是几乎所有的地方日期的格式都一样，我把 simple 对对方卖的实例化一次，装配到 b 类，可以反复用，达到这样一个目的。

好，我要装配的是 c 不对的放卖的，所以这个方法的返回的类型就得是 same 不对的方面，给它取一个方法名，注意这个方法名就是 bin 的名字，Bean 的名字是以方法命名的， Bean 类当中这个方法当中，我就实例化 cmd 的方面，给他指定一个格式，好这样就可以了。

这段话的意思就是说这个方法的返回的对象将被装配到容器里，这个Bean的名字，写完以后我们再回到这个测试类，我们去看一下能不能取到这个Bean，我就再写一个测试方法，这个方法名我取名叫 taste，并挺 big Bean的配置，我要从Bean中从容器中取的是 cmd 的方脉，先说明这个类型，我换个行按照类型来 get，simple date for MAC 点 plus。

好，我就使用一下，我就用 cmpod 的方脉去格式化一个当前的日期，看看能不能达到我的预期。好，我就执行一下这个方法。咱们看结果是当前的年月日时分秒。没错就是这样，好了，Spring容器基本上就是这样去用的，但这种用法是我们主动的去获取容器，去从容器中的拿一个Bean过来去用，但其实这种方式很麻烦，这个 Spring Spring的，还有更简便的使用一个容器的方式。

刚才我们 PPT 上不是说了，它的 IOC 的实现方式是依赖注入，而我们现在主动获取感觉也不是主流，对吧？

所以说这种方式还是一个比较笨拙的方式，为什么要演示之前这种主动的获取的笨拙的方式，因为我是希望你能够理解死笨容器它到底是一个什么东西，它的底层到底有什么方法，我们到底是怎么去直接使用，这是它的底层的一些内容，你需要了解。

我们从使用角度来说怎么方便怎么用，下面我再给你演示一下，怎么用会更方便一些，什么叫依赖注入？

比如说我当前的Bean要使用阿尔法道，我没有必要去通过容器去 get 获取，我只需要声明，我要给当前的Bean注入阿尔法道就可以了。注入的话需要用一个注解叫 o to o to where 加在一个程序变量之前就可以我加了一个阿尔法到程序变量之前，这句话的意思是说我希望十分容器能够把阿尔法道注入给属性，我就可以直接使用属性就可以了。好，咱们试一下，我再写一个测试方法，叫 test。

 Di 是什么意思呢？就是依赖注入，对攀登 c infection 的缩写，测试依赖注入。好，我在这个测试方法里面直接使用这个程序变量，看看能不能取到这个Bean，我就直接把它打印出来看一下运行。好，你看打印出来结果是这个 MyBatis 这个时间内没有问题对吧？同理，你想获取阿尔法 service，也可以这样做，你想获取 simply 的放卖也是可以的，好，我在这也把那两个Bean打印出来看，再执行这个方法看，结果这个是 my business 实现这个是阿尔法 service，这个是 safety 的方面都取到了，比方说没有问题可以用，注意还有一种情况，比如说我二发到我希望注入的不是 MyBatis，不是默认的优先级，我希望注入的还是 happened，怎么办？

这种情况我们需要再加一个注解，叫考利菲尔，括号里边写上 Bing 的名字，阿尔法 happily，此Bean容器就会把这个Bean你认为这个的Bean注入给他，我们再来测试一下，你看这个Bean就变成了 heaven 的实现。

所以你看说 Spring 他管理并就是用这样的方式，就是依赖注入的方式，我们只要声明一个属性，写一个注解，这个Bean就有了，我就可以直接拿来用了。像这种情况，我当前Bean依赖的是接口，底层的实现我是不直接跟它耦合的降低了耦合度，好，而且它也很方便对吧？不用你去实地化。

好了，依赖注入的基本的使用方式就是这样的，非常的方便非常的简单，我们通常都是这样用的，其实注入注解，也可以加在类的构造器的前面，通过构造器注入也可以或者是把注解加到set方法之前，通过set方法注入也行。

但通常我们都是把它加在属性之前，直接注入给属性，这样更简洁更方便，我们项目中基本上都是这样去做的，所以另外的两种方法我就不给大家演示了，如果你有兴趣的话，可以翻翻手册去自己查阅一下。

好了，以上是我们演示的一些语法小例子，我们在实际的项目的开发的过程中怎么去运用，下面我们在综合一下来演示一下依赖注入，演示一下我们项目中怎么去使用这种思想解决问题。

我们的开发的过程中是这样的，由 controller 来处理浏览器的请求，它在处理浏览器的请求的过程中，会调用业务组件去处理当前的业务，业务组件会调用 deo 去访问数据库，所以说是这样的，d controller 调 Service 调 deo 他们是彼此互相依赖的，他们的依赖关系就可以用这种依赖注入的方式去实现。

好，我们来演示一下，首先我打开阿尔法 service，比如说我要调道，阿尔法道我就可以把阿尔法道注入给阿尔法 service，当然你需要加 how to win，我希望注入默认的 MyBatis 的实力就可以了，所以我就不加科雷菲尔了，加上一个注解，成员变量，好这就注入了。

我在处理查询的业务的时候就可以调用它了，下面我就写一个方法，模拟实现一个查询的业务，这个方法我返回死菌方法名叫犯的，这里我调的是阿尔法到来实现的查询，我直接把查询结果返回，这就是 service 依赖于到的方式。

 controller 在处理请求的过程中可以叫 service，同样的道理，我首先在 controller 那里将 service 注入给他好，我这里写一个处理查询请求的方法，模拟处理一个查询请求，这个方法比如说我还是简单点返回字符串，因为是查询叫 get 查询某些数据，我就直接 return 阿尔法 service 点 find，把 find 的结果返回给浏览器。

当然浏览器要访问这个方法的前提是它得有注解声明声明它的路径就和一样，按照 copy 路径我给它改名叫 data 写完以后，我们可以运行一下正式的代码，访问一下试试。

好，运行一下，运行完以后我打开浏览器访问一下，阿尔法 data，你看它的结果是什么？是买卖 s 怎么来的？是因为我掉了 service 的饭的方法，而 service 的饭的方法调用的是 Dao 的 select 方法。

 deo 我们注入的时候，注入的是默认的优先级的，也就是买卖点，实现了这个Bean好了，所以说你通过这个例子可能就更容易去理解我们之前所讲的 IOC 的概念。在这个思想的管理 Bean 的前提下，我们项目中的 Bean 不是我们自己去实例化，也不是我们自己去set，而是通过容器统一的管理，降低了Bean之间的吻合度。好了，这次课我们关于 IOC 的内容就演示到这里，咱们下次课再见。