15-显示登录信息.mp4

这次会我们来实现显示登录信息的这么一个功能。什么叫显示登录信息？就是说我们在每个页面的头部在这个地方，都要把登录的用户的头像在这里显示出来，另外你点三角展开的信息当中，在这你要显示用户的名字，除此以外还有一些处理的地方就是说，如果用户没有登录，我们给它显示的是首页注册和登录这样的链接，如果他已经登录了，我们要给他显示首页消息以及头像相关的内容。

所以说根据它登录与否，我们需要调整的头部显示的这些内容，我们可以统称为显示登录信息，那么很显然大家也看到了我们的静态页面每一个页面里头部都有这些内容，或者说它都需要显示登录信息，就是说你开发这个功能，你需要每一个请求都要做同样的处理。

当然我们用一个比较笨拙的方法就是说你可以CTRL当中每一个方法都加上这样的逻辑，但是这样会很麻烦，即便是你把这个逻辑进行了一个封装去调，你也去调需要调很多次对吧？我们一个网站可能会有很多功能，可能会有特别多的请求，几百个请求上千个请求，你调了那么多次会很麻烦，万一说将来的话哪个地方要变是吧？你要调整的地方也很多，侵入性太强了，或者说耦合度太高了。

因此像这种情况，我们有没有办法说能够集中的统一的用一种很低的耦合的方式把它解决了，那答案是有的，我们可以利用spring的拦截器去统一解决问题，那么拦截器跟它的名字表现的是类似的，它的功能体现在名字上，它能够拦截浏览器访问过来的请求，当然可以拦截多个请求，甚至是全部的请求可以配置，然后拦截到这些请求以后，它可以在栏请求的开始或者是结束的部分插入一些代码，从而就能批量的解决多个请求共有的业务，这就是拦截器的它的一个好处，总之它能够以一个非常低的耦合度解决通用的问题。

那么我们这次课是这样，我先给大家演示一下拦截器的示例，你了解一下它语法它怎么用，了解完以后我们再去解决我们最终要解决的问题，这样就顺理成章了，对于拦截器我们在使用的时候也是挺简单的，第一步就是你写一个类，然后实现接口，借口有几个方法，我们根据情况然后去实现。

第二个就是我们需要把拦截器配置一下，你要指定它拦截哪些请求，不拦截哪些请求，这两步开发完就完了。那么我们开发的拦截器和处理请求的 Ctrl没有任何直接的关系，但是也能解决问题，所以说这就是它的好处，耦合度是很低的。

好了，接下来我给大家写一个案例，我们来体会一下拦截器它的方便之处。

那么我打开我的开发工具，然后因为拦截器它处理的是请求，那么其实它也属于表现层的逻辑，因此我把拦截器代码也放到CTRL这里，但是我新建一个接口，新建一个包放到新建的包下，这个包我就叫intercept拦截器，然后我就写一个拦截器的示例，这个类我取名叫阿尔法intercept。

好，拦截器首先我要把他声明一下，让他把他交给 space容器去管理，所以加上一个注解，另外要给它实现一个接口，刚才我们说了实现的接口叫做 handler intercept。

好，那么这个接口里主要有三个方法，这三个方法一个是play handle，一个是post handle，一个是after come complexion。

那么这三个方法它的前面都有一个default标志表示说这个方法是一个默认实现的方法，当然它是空实现，所以说你实现这个接口以后，你可以不实现这个方法，也可以是实现这个方法，就是根据你的实际需要你挑挑你需要的去实现就可以了，这也是它方便之处，它不强制你就是实现所有的方法。

好，这里我把这三个方法都实现一下，然后我们看一下它有什么用。首先第一个它是有一个叫普瑞憨豆的方法，放大一点Free handle的方法，那么这个方法就是说它在拦截请求的时候，它是在 CTRL处理请求的代码的前面执行的，它是在请求的前面执行，这里我写清楚，就站很抽了，之前执行。

好，那么这个方法是返回布尔值，如果说你方法内部你return false，那么就是说我要取消这个请求了，那么它程序就不会往下执行， controller就不会被执行，所以我们通常是反馈错误的，除非你有特殊情况说这种情况不应该往下执行，我才return force，这里我就改成return处。

好未来一会我们看到程序执行到这，所以说我想给他在这里打一个日志，我先把日志组件实例化一下，好。

那么以当前的类作为 logo的名字，我在这里就简单的就打个日志，日志是起到一个调试的作用，所以说给它设置为第八个级别就可以了，那就是log点。

第八个随便写句话，我就写这个方法名，比方说这个方法被调用了，不是憨豆，然后这样我再加一些信息，因为你看这个方法它是有一些参数的，首先有一个request，参数，因为你是拦截请求，所以说你想在拦截的过程中，你想自己怎么说加个塞儿，在处理请求过程中加个塞儿，加一些自己的逻辑，所以说你也想处理请求，因此他把request对象给你，response对象给你，你可以去处理请求和响应，另外还给了给了你一个奥派克，这个update是什么？

我们可以打印看一下，这样比较直观一点，我就加上 handle点兔子菌，我们看看这里这个是个什么东西。

好，就这样了，我们再看另外的两个方法，然后还有一个方法，刚才我们看了叫post candle，我也把它在这里实现一下，这个方法我就直接告诉你他在什么时候执行的，他是在调用完CTRL了以后去执行的，所以说它是在 controller之后执行，当然我们一会通过程序能够更直观的能够看到这一点。

然后它也有几个参数，第一个参数request，第二个response不用说了，这个handle跟这个一样，除此以外它还有model and will，因为什么？这个方法是在control了之后执行的，那control了之后表示说我主要的请求的逻辑已经处理完了，下一步就是要去模板引擎了对吧？

要去给页面返回要渲染的内容了，因此你再去模板引擎的过程中可能需要用到 Model and view，你可能需要获取这里的数据，或者你需要往这里装一些数据，因此他把这个参数给了。

你好这里我也打个日志 log点底半，然后写上pose handle，同样的我也把不知道是什么东西的对象，打印出来我们看一看它会是什么。

好，除此以外，最后还有一个方法，那个方法叫after Complete。

好，那么这个方法它是在程序的最后执行是在这个模板引擎执行完以后执行，你注意这两个是有区别的， pose title是在control了之后，模板之前，而它是在模板之后，最后执行他们的时机你要搞清楚，这里我也注释也写清楚了，它是在 template安整就模板引擎之后执行。

好同样的这里我也打一个日志 log点debug，然后还是写上方法名，然后写个冒号也是加上 handler。

第二兔子病它的参数还是这样的request，response，然后 handle最后还有一个异常对象，就是说如果说你在调用 control这个过程当中或者是调用这个模板的过程当中出现了异常，它会把这个异常信息也给你，你也可以对异常做一些处理。

好了，那么这个代码就写完了，我们只是通过它来看一下程序执行的过程，这个时机对不对？打日志，就写完以后要想让它生效，你还得对它配置，不然的话死光也不知道我应就组件应该拦截哪些请求。好，所以我要写一个配置类，我在肯目录下新建一个类，那么这个类要取名叫外的 Mvc can figure ym VC倍。为什么这么叫？一会你就知道了，首先我要在这个类上写上一个注解，表示它是一个配置类， Can figure reason我放大一点。

然后我们之前所写的配置类主要是想在配置类里声明一个第三方的病对吧？

通常是做这样的情况，但拦截器其实这个逻辑相对来说和别的不太一样，我们想配拦截器配置类，它要求实现一个接口，而不是简单地装配一个GB实现哪个接口，是vibe的 mvc can figure，所以因为当前这个类要实现这个接口，而这个接口的名字是这样的，所以说我在命名类的时候是参考了接口的名字这个意思。

好，当然了我们在配置类当中主要是要配拦截器，所以我们可以把拦截器注入进来，然后再对它进行配置，先不用着急实现这个接口好，那么它叫做阿尔法 intercept对吧？把它注入进来以后，我们就实现接口在某一个方法里去注册拦截器，那么我们需要实现这样一个接口，名字也很直观了，叫爱的 intercepts。

其实这个接口里有很多的方法都是做了默认的实现，那么你根据自己的需要去实现就可以了，我们注册接口就是实现这个方法，爱的interceptors，那么这个方法就是spring在调用的时候，它会把对象传进来，我们是利用它传进来的对象去注册 intercept，怎么用很容易 registry，然后点at intercept就添加一个拦截器，你就把这个been添加给他就可以了。

如果你只是这样写的话，就比方说拦截器会拦截一切请求，那么如果说有些请求你不希望它拦截，你可以这样就可以先就是include pass patterns。意思是你可以排除哪些路径，哪些路径不用它进行拦截，哪些路径不用拦截呢？我们的项目中除了浏览器可以访问CTRL，其实我们项目中还有一些静态资源， cssjs以及图片对吧？

这些静态资源其实浏览器访问的时候，你就任他访问，你不需要进行拦截，因为你访问一个静态资源，没有什么业务逻辑，而且你随便访问的这些东西，因此你要把这些静态资源的访问给它排除掉，所以我在这里把就写一下这个路径排除的路径，我这样写杠星星，然后星点css，为什么这么写呢？你看一下我们静态资源存放的目录放到了style之下，而且我都是把它放到了某一个目录下，对吧？访问静态资源怎么访问不就是 Logo house的80 80，然后community然后站斜线，直接就css什么其实相当于在项目的路径的下直接就访问到这儿了，所以说我们要配的话，直接项目以及域名可以忽略掉，从这一级目录开始配。

所以我杠星星表示什么意思？就比方说时代的一个目录下，所有的文件夹当然你这里写CS也可以，刚星星我觉得省点事，就哪怕说还有目录有css也是ok的，它能匹配所有的目录，就这个意思。

好，那就是说所有目录下的css文件我都要排除掉，同理 GS也是这样类似的逻辑对吧？杠星星杠星点GS我们就这样采用通配符的方式一个去排除，然后再排除图片，然后是星点偏近。

好好再来，当然图片不只是PNG格式，然后还有 Gapg还有接peg好，就这样了，我排除掉了这些静态资源，其他的请求我就都被他拦截了。

比如说我不希望其他的请求都被拦截，我希望一部分请求若干个被拦截怎么办？这里我再进一步演示，你可以再点爱的pass patterns，你添加一下你明确你要拦截的哪些路径，我这里比如说我就希望它拦截的是注册的功能，你就可以写register，这是注册的功能的仿路径，比如说我还希望它拦截这个登录就烙印，那这样就可以了，你就可以在这里加很多个路径。

当然其实如果有些路径有相同的规则，你也可以用通配符，假设我们有一个 CTRL，它的仿路径是 User下有好多个方法，你可以这样对吧？你可以这样，当然目前我先没有先不管，好了，我拦截器就这样配好了，基本上就这么用就可以了。

那配完以后，你看我这两个类和我们要拦截的 CTRL其实没有任何的瓜葛，从表面上来看对不对？那么它能起到作用吗？我们测试一下就知道了，好，我就把这个项目重新启动一下。

好，启动完以后我就打开浏览器，然后我访问一下 Host，我先访问首页， index访问到了，然后我们看一下控制台，你看一下有没有拦截器，记录的那些日志，什么pre hand post这些东西有没有？经过检查没有，为什么没有？因为我们配的是拦截器不拦截index，它只拦截就是 Register老兵对吧？我再访比如说 Rest或者老兵看看他能不能拦截到，比如说我就访问这个登录，我点一下这个登录，打开登录页面。

好登它的路径就是log in，我们看一下有没有拦截到看工作台，在这我这个屏幕就是说分辨率调的比较低，所以说一屏显示的内容比较少。在最后你看这个地方 Free handle阿尔法intercept20行Free handle，post handle after completion。

所以说你看到了它确实起到了拦截的作用，代码执行了，而且这个顺序也是我所说的顺序，这个先然后是然后这个方法另外它也打印出来了拦截器的参数， object是什么东西，你看一下。就是CTRL点这个方法就说明什么？ Object是什么是拦截的目标，我们刚才访问的是log in方法， object就是log in方法，那个方法它是拦截的目标是这样的。

好了，当然这么看的话，只能说看出来三个方法执行的顺序，但是你并不能看到说他确实是在controller之前，他确实是在controller之后，他确实是在模板之后看不出来，你想看看也很简单，我在程序中打几个断点，我们看一下断点，执行的顺序就知道了，对不对？

下面我就在 log in control这里先打个断点，我找到烙印就打开登录页面的逻辑，我在这里打个断点，然后再打开拦截器，在这三个方法当中也是依次打上端点。

好，我打开浏览器刷新一下，或者再点一下登录点，然后你看这个断点卡在哪了，首先是卡在了普瑞憨豆这个地方，这个地方是不是啃出了还没执行对吧？

因为执行的话就会卡到这，但他先在这说明他是在肯德勒之前被调用的，然后我就按一下这个f9让程序接着向下执行，直到执行到下一个端点为止。

你看第二步就卡到了登录的这个地方，然后再f9就卡到了POS探头这个地方，就证明了这个顺序，就如我所说的，他在肯出了之前，他在肯出了之后，然后再执行 f9到这这个地方就是模板，然后我让程序接着走下去，然后把这个断点都去掉。省的一会我们在用的时候它有点碍事。

好了，我们再回到 Ppt就是说通过这个小例子你就了解了拦截器它是怎么用的，就非常简单，反正写一个类，然后简单的配一下，它就能够起到这么一个很强大的这么一个功能。好了，接下来我就用它来解决我们项目中的实际问题，想办法要在页面上显示用户的登录的状态。

那么怎么去处理？这里我给列举了几个步骤，首先就是我们在处理浏览器的请求的时候，我们应该在请求开始的那个时候，先把登录用户先查到，因为你要显示登录信息，你要把登录的用户查查到以后，这登录用户后面模板上要用，所以你要想办法把它存一下，存到内存里。

这里我说的是在本次请求当中持有用户数据，其实就是存到内存里，后面好用，然后在后面我们在模板上要显示用户在模板的地方要用，最终用完以后，在请求结束时你把这个用户数据清理掉就可以了，所以说是分这么4步，但是我这样说的话，可能是大家并不能够把这个逻辑怎么实现和我们拦截器就是match起来，或者说也不能够把这个逻辑和我们之前做的登录匹配起来不够直观。

所以下面我给大家再画个图，把这个逻辑再串一下，然后你把这个思路理清楚以后，我们再去写这个代码，画个图先画个框，这个框比如说代表了浏览器，我再画一个框，用它来代表这个服务器，那么假设目前用户已经登录了，他登录以后，我们服务器不是给浏览器发了一个凭证，浏览器是通过可以发的，所以浏览器就存了凭证，上一次课我们看到了对吧？

因此库克里存的数据存的是 ticket在浏览器里存了。

好，那么除了以后浏览器只要是在访问服务器，不管是访问哪个功能，那么他都会把这个数据发送给服务器，因为我们对 Cookie设置的有效路径是整个项目对吧？所以他会把库可以发送给服务器。好，那服务器就可以从库里得到凭证对不对？得到一个凭证，得到这个凭证有什么用凭证关联的是用户，对吧？因为每个用户我们生成的凭证是不一样的，凭证关联的是用户，所以我们很容易能够通过凭证得到当前用户是谁，当然你想得到当前用户是谁，你需要查询一张表，这张表叫做log in ticket对吧？

我们上次给他创建的，所以这个服务器可以根据凭证去访问一张表，然后通过这张表得到用户的信息，其实得到的就是用户的ID，得到用户的ID就好办了，你再查user表不就最终能得到这个user了吗？对吧？

所以我这里就省了查查优则表这一步了，反正我就通过它能得到优则的明确的信息了，得到优质的信息以后，最终我们是要把它运用在模板上，因为模板上你要显示头像显示用户的名字对不对？所以说你要把它用在模板上，那好吧，你就把它放到model里，然后模板就可以使用它了，对吧？

所以很容易就能把它提交给模板，就是把它放到model里。

好，最终的话这个模板像浏览器响应生成了一个html，这个html里就可以携带上当前的登录用户的消息，所以说整个流程是这么一个过程，那么这个过程当中关键点是登录的时候，我们除了 take it，所以再次访问时我们可以获取 take it。

另外我们库里除了 take it，我们在服务器可以通过take it，找到这个数据，从而找到 user，是这么一个过程。

然后这里你也应该能理解说我们当初为什么没有在浏览器上直接存user数据，因为user数据比较敏感，你直接存到服务器端，浏览器端的话不安全而存一个take的只是一个key，相对来说不那么敏感，这样比较合适。

好了，整个的过程大概是这样，下面我就给大家写代码，把这个过程实现一下，好。

我们再回到我们的开发工具里，当然了还再说一下，我们这个实现这个逻辑就是获取得到 txt查询，从而得到user，然后在模板上渲染这个过程是每次请求都要这么干的，因为每次请求最终的模板上都要显示用户信息对吧？

所以这个东西是要反复去实现的。因此这套逻辑我们应该是用拦截器来处理，而不是写多次对吧？所以我一上来就应该写一个拦截器，我就在 intercept包下再新建一个拦截器。好，新建一个。那么拦截器我取名叫做log in。Take it。然后 intel sector看来这个就不用了，暂时也不用把它先关掉，放大一点。那么他的书写的方式和刚才我们写阿尔法inside是类似的，对吧？我就先给它加上 complaint，注解，然后另外让他也实现接口 Handler intercept。

好，然后按照刚才我画的图的逻辑，我们应该是在请求的一开始就去获取 txt，从而利用 txt去查找有没有对应的user，然后如果有的话就暂存一下最早做这个事儿，为什么要一开始就做？

因为我们在整个请求的过程当中，可能随时随地都要用到当前用户，随时随地都要有用的，所以你最好一开始就就找到他，所以我就重写一下 pray，憨豆这个方法，然后先先写成return处不要return，否则后面就不会执行了。

那么在这个方法里，我第一步就是要通过cookie中的数据，通过cook得到 ticket，那么你注意这个方法是由接口定义的，它的参数可不能说你随便去加的，你说我加一个参数不行，接口定义好了，所以我们不能加参数，因此我们就不能在这里用酷ky6注解了。不过也没关系，好在他给了我们传过来的 request，那么cookie是通过request传回来的，对不对？我们从这里能得到 cookie，我从request中取cookie，我希望把它稍微封装一下，因为我们后面其实还有别的工具，也会有类似的情况，用瑞克斯获取酷品，而它从对象中获取库还有点麻烦，所以最好封装一下以后好复用。

那么这样我在 YouTube的报价在这新建一个类，然后类我取名叫cookie YouTube。

然后在这里边我就写一个静态方法，咱们直接调就可以了，我就不用这个容器去管理它了，就是一个简单的小工具，静态的方法，那么它最终的返回的就是库克中我们得到的一个值是死菌，然后这个方法名我就get y6，从库克中取一个值，那么我们从库克中取值，首先你得给我传入这个request、对象，另外你还得告诉我你要取那个值它的 name是什么， k是什么，把这两个条件给我，我就帮你取，但是我首先得判断一下，你这个request对象传的是不是空的，你万一给我传个空值怎么办？

对吧？

第二个 name它是不是空的，如果你传个空的又怎么办？如果你传的参数是空的，我解决不了，我就抛一个异常，就伊利狗给我们exception，给个提示说参数为空，这是不对的，处理不了。好，那么如果参数不为空，我就可以去获取了。从request当中取cookie也很容易就点get cookies。

我们一下能得到所有的cookie，所有的cook对象得到的是一个数组，好，是个数组，那么我们想找到某一个值，你很显然得遍历这个数组，然后就判断当前的对象的k是不是等于这个name，如果是我就返回它的值，如果不是就继续对吧？这个逻辑很容易想到，我就当然得判断一下，cookies如果cookies不等于not，万一一个cookies都没有对不对？

判断一下我就便利它，便利 Cookies。对于每一个cookie，我去判断 Cookie的name它是否等于你传入的参数，如果是的话我就返回，就是我们要找的数据，我就返回cookie的 baidu。当然如果不是你就继续，如果说整个程序都执行完了，你还没有返回，那就说明其实就没有你要的数据，我就得听到就可以了。

好，这个工具我就写完了，还是比较简单的，咱们再回到拦截器，在一开始的地方就可以解决我们第一步要解决的问题了，获取 Cooking。从酷配中。对吃完了从酷配中获取凭证，当然你得登录我才能取得到，如果没登录是取不到的。好，我就使劲 Take it。等于调那个工具， cook you too点get value。把这个request给他，然后把 key给他， key就叫take it。

好，我们尝试取这个值，它有可能是空的，有可能不是空的，你得判断，如果teacake它不等于不等于，那就表示你登录了，那么你登录的时候，你登录的时候我要怎么办？我要要查询一下 ticket，从而找到用户的数据对不对？你要查询的话，我们还得调一个service去做查询，我们最终要查的是user以及推给的相关的内容，我们就需要看么user service里目前我没有加查询凭证的代码，我给他加上去，在后面追加一个方法，他不得然后返回的是 log in。

Take it。我要查的是log in ticket，然后方法名我就叫find log in ticket。

那么传入的条件就是凭证这个字符串，这个方法实现非常的简单，就是你就调 log in tk的map，对查询方法一步就实现了，没什么可说的。那么有了这个方法以后，我拦截器又可以继续写了，如果take的不等于我就把整个take的对象查到，当然我要查还得调 Service，我还得把 service住进来。

User service，好，我这里调用user service点find log in ticket，把凭证传入我就会得到 log in ticket对象这一步写注释，查询凭证，我们查到这个凭证就能直接用吗？其实也不是，你得判断一下凭证当前还有没有效，因为凭证不是有状态，它有可能是已经失效了对吧？

第二个凭证还有一个过期时间，如果说他已经超时了，那也就无效了，所以你这里要判断一下凭证有没有有效了，我才能把它暂存后面才能用，如果无效我就当做你没登录一样。

好，所以这一步我要检查凭证是否有效，那也很好检查。比如说如果说 ticket它不等于闹，并且 ticket不是txt，只是老跟特别大，log in it不等于no，然后 log in take it点，get status。它等于0，并且log in，take it。

Dear get expired there after new date。我这写完以后再解释，你看只有说我们查到的凭证这个结果它不为空，并且状态是0，有效的，并且它的超时间晚于 after当前时间，超时时间在当前时间之后就说明它还有效，否则达到了当前时间就无效。

所以这些人都满足才有效对吧？那么如果凭证有效的话，我就可以认为你是登录成功的状态，我就可以利用凭证去查询user。

那么查询user我们调 User service的点，find user by ID， ID从哪来？从对象中取，这里有这里写个注释就是根据凭证查询用户，那么查到以后，刚才我PPT上也写了，我说了我们查到以后不是在这用，是在后面在模板上用，但或者是在我们CTRL处理这个业务时也可能会用，总之我们在后面整个处理的过程中，随时随地都有可能会用。

为了后面的使用，我需要把 U的暂存一下，或者说我们换个角度来说是就是说在本次请求当中持有用户，让本次请求持有用户随时随地都能拿到好，我怎么去存 user呢？当然有人可能会想我就创建一个公共的类把它放进去，或者是我把它放到容器里会怎么样，其实就是这样处理简单的处理都不对，因为你要考虑什么？

咱们浏览器访问服务器是多对一的方式，就是一个服务器能处理多个请求是并发的对吧？那么每个浏览器访问服务器，其实服务器会创建一个独立的线程来解决你的请求，所以说服务器在处理请求的时候，其实是一个多线程的环境，你要考虑到这一点，所以你在存用户的时候要考虑到独者程的情况。

如果你只是简单的存到了一个工具当中，存到了一个容器当中，那么是一个变量的话，那么有可能会产生冲突的。并发的情况下，我们想把一个数据存到一个地方，让多线程并发访问都没有问题。怎么办？你得考虑什么呢？考虑线程的隔离，就说我每个线程单独存一份，他们互相之间不互相干扰，大家学Java的时候，你学过独者程的话，应该了解到有一个工具就是解决这方面的问题，工具叫此外的logo。

好，所以下面我就想办法要把优点存到那个时代的路口里，在多个线程之间隔离存这个对象，但是这个逻辑我最好把它分成一个小的工具，因为其他地方也可能会用到。

好了，当然了我就先写这个工具，然后写的过程中我们再去看一下那个时代的logo它是它是怎么隔离的，其实通过源码能看到，我们一边写一边看，我就在 Youtube包下再新建一个类，这个类我们习惯于叫host，当然你叫别的名字其实也无伤大雅，没有关系，按照习惯我们喜欢叫host。

好的，然后这个工具我把它放到容器里是加上一个component，然后这个工具其实主要是它就起到一个容器的作用，这里我写个注释，它起到一个容器的作用，那么它的作用是持有用户的信息，其实说的直白一点，它是用于代替筛选对象的。

因为我们程序中不太想用筛选对象，然后如果有三成对象它可以直接持有数据，而且它是线程隔离的， host其实就代替它的功能。

我们刚才也说了，我在这里要用到的是smart的logo，所以说我把 smart的logo就是初始化一下，所有的logo范型指定它里面存的是什么对象，存的是user，那么这个对象的名字名字我叫users，因为它里边存的是每个线程对应的user，那就是new时代的路口。

好，那么死的路口它主要提供了一个赛的方法，就往里存纸，一个钙的方法取值，那么在存和取的过程中，它用一个很简单的办法就实现了线程隔离，咱们看去看一下它的源码，我进入到这个类当中来了，我就看一下，你看他有赛的方法往里存，纸存的是你指定的类型的对象，你看它怎么存的，它首先是spread点carry on the spread，就当前的线程，他先获取当前的线程，然后根据当前线程去获取一个map对象，然后把值存到 map里，所以你看它存数据是根据线程来存的，每个线程得到 map对象不一样，它是通过这种方式进行了一个隔离。

然后你再看盖的方法，他取的时候也是先取到当前的线程，然后取到当前线程所对应的 map，然后的话从 map中取值，所以说它以线程说白它是以线程为k存取值的，是这样一个逻辑。

好了，回到刚才的工具类当中，我需要再给它加上两个方法好，让外界能够调用一个就是site，user方法好，让外界能够把user传进来，然后我这个工具把它存到style local里，那就很容易就users点site，user就行了。

好再来一个get， get就得返回user， get user你要从时代的look里取 users点get好就可以了。然后我们再提供一个方法就是清理，请求结束的时候，我们把死在路口中的 u的再给它清理掉，不然的话你每次只往里存，不往外清越来越多，它占有太多的内存不好，所以说用完就清掉。

Public、world颗粒清理，我们直接调users。第二为目，你看这个人物方法，他也是获取当前现成的map，然后把里边的值清掉，所以说也是和线程相关的。好了，这个工具我就做了一个简单的封装，那就可以用了。接下来我们再回到刚才的拦截器当中，我这回就可以用刚才的工具去持有用户了，有人说为什么他能持有？

因为我们在这儿把数据存入到了当前线程对应的map里，这个线程只要是这个请求没有处理完，这个线程就一直还在，当请求处理完服务器向浏览器做出响应之后，这个线程被销毁，所以在整个处理请求的过程中，在后续现场一直是活着的，然后死在路口里面的数据是一直都在的，所以这里我就写上好还不行，我还得把 House toda给它注入进来，好，然后在这儿我就可以house toda，然后点site，user好了，普瑞汉德我们要做的事就完成了，在请求开始之初，我就通过凭证找到了用户，并且把这个用户就是存到了暂存到了 house头的里，就暂存到了线程当对应的对象里。

好，我们再往下，什么时候我们需要去用 user，那就是在在模板引擎之前就要用，因为模板引擎上要用，所以我们在模板引擎被调用之前，应该把 user给它存到model里它就可以用了，所以我们可以重写这个方法，post handle。还记得 Post handle是在模板之前掉的，对不对？而且它恰好有 model and view对象，所以我们在这可以怎么办？可以先从host里得到 User，得到当前线程持有的user，然后判断一下user他如果说不等于null，然后并且 model and view不怎么弄，因为我最终要把数据传到model and view里，我得判断一下万一它为空对吧？

好，如果这两者都不为空，就达到了我要处理的条件，我就mode and will点I的object，然后往里存一个值，存的就是登录用户， key我叫log in user值就是user对象，我就存进去了，那么紧这个方法执行完以后，紧接着模板就被执行了，那模板在执行的时候，model里已经有了user，它就可以拿来用就很方便。

好，什么时候把 house的厚点里的优点给它清掉，咱们刚才不是要清吗？在整个请求结束的时候，我们就得重写 after来选这个方法这样模板都执行完以后，最后我要调它的颗粒方法，把数据清理掉就完了。

好，你看虽然说我们本次课要解决这个问题，主要用的是拦截器批量的处理请求，但是我们还需要有一些技巧，需要结合着之前所学的内容才能解决掉这个问题，所以说你要把之前的学习到的东西都串联起来，综合的去理解。

当然如果说你独者程那块的知识就是遗忘了，你需要课后做一个回顾，做一个复习，再多看看，那么下一步干什么？咱们拦截器写完了，下一步不是得把它进行一个配置，对不对？所以下一步我就再回到外部mvc config，我需要把刚刚写的拦截器进行一个配置，和上一个拦截器一样，我要把它先注入进来。 Log in take it，interceptor。

好，注入进来，然后注册的方式和一上一次注册也是类似的，我就直接复制粘贴了，我们注册的是拦截器，然后这些静态的资源的访问，我们也需要把它排除掉，不处理好，然后我们需要具体来说除了静态资源以外，要拦截哪些请求是全部的，因为所有页面我们都要做这样的处理，所以我就不去写 ID了。

好，拦截器我就写完了，写完以后我们在模板上需要进一步处理，因为最终咱们不是要在模板上显示用户的登录信息，就在头部对吧？

我们所有的页面都是复用 index的header，所以我们需要去改写 index的 head的部分，我找到这个页面找到它还得这一部分，好，咱们看一下，首先首页你不用去处理，因为无论是你登陆没登陆，首页我都能看见，谁都能访问，这个不用管。

然后第二个我们看这个消息，这个就不是了，如果说你没有登录，你应该看不到任何消息，别人都没法给你发消息，所以这个地方你得做一个判断，如果没登录不显示登录了，才显示你这里可以用 if th冒号，if等于。

好，我如何判断它有没有登录很容易，你看一下model里有没有有没有 loving user，对吧？如果你登陆了，它一定会有 log in user，因为我所有请求都做了这样的处理对吧？好，所以这里我就写 log in user，它不等于not，那么这个时候才显示它，否则我是不显示的，你要注意好，这是我们对这个消息做的一个处理。

同理其他的也是类似的，你像注册和消息刚好相反，他得是你没登录才显示注册，你登录了就不用再注册了，对吧？所以这里把这个复制一下，这个得是等于now。

Love you又等于now，比如说你没有登录，此时我就给你显示注册，你就可以注册，登录也是一样的， log in u等于no的时候我就才显示登录，否则你已经登录了，还写着登录干什么呢？有没有必要重复登录对不对？然后再来最后的这个地方就是这个位置，很显然这个位置应该是登录以后才显示的，你没登录也没有什么头像对吧？也没有这个用户名对吧？

所以这个地方它和消息是类似的，是 li复制一下，如果用户登录用户不为空，我就显示它，然后在显示的时候下面的路径我们需要处理一下，看一看，下面有些数据需要处理一下，首先这个地方是用户的头像，目前我是写死的，这个得是动态的，你要显示的是当前登录用户的头像，所以你可以这样写 th冒号s二c把这个静态的路径换掉，换成login user的tide URL属性，换成动态的值就好了。

除此以外，咱们下面不是还有一个用户名，它也得显示一个动态的值，对吧？就当前登录用户的用户名，这里用的是Utecht，因为我怕万一有些用户注册它里面带了一些特殊的符号，我就用一个u text，然后这里显示log in user点。User name。

好了，首页我就处理完了，接下来我们测试一下看看能不能行，我重新重启一下点重启一下，重启以后打开浏览器，我先访问一下首页，当前他没有登录，所以你看显示的是首页注册登录没有错对吧？我就登录了，我就用这个 CC账号密码123，这个验证码是gn7c登录密码不正确，我少填了一个3小键盘有点不好用。

 Nqec登录不不对， U38g密码还不正确，难道我忘了密码ln10，刚才可能是我第一个字母就敲错了，我也不知道敲什么去了。

反正这回就好了，然后你看我登录成功以后，请求一刷新就跳转到了首页，然后的话这次请求就被拦截拦截到了，就被我们 log in take it in the Sept拦截到了，那么在请求之初它就根据登录的凭证得到了用户然后放到了host hold里，并且在 control了执行完以后，他把又取到了，然后放到了model里，我们在模板上就index这个模板上写的这些代码就生效了。

他能够正确的得到 log in order这个数据。

所以你看登录成功以后，我只看到了消息和这部分这头像，然后你展开看，其实也是没有问题的是吧？然后你也可以点退出登录，然后再退出一下，一退出他又跳到了登录页面这个时候，因为退出的时候我们把凭证给他设置为失效了，对吧？

所以在这次警示当中的拦截器虽然找到了凭证，但是一看失效了，他就没有去存放，没有去找 user，没有存放 user，所以说最终页面上我们的逻辑判断是没有登录，因此显示的是这样的。

所以说你看头部根据登陆与否，它变成了一个合理的展现，这就是我们这次课要这个给大家呈现的内容。好了，这次课的目标我们就达到了，课后的话你也把功能实现了，好好体会一下拦截器它的强大之处。我们这次课就讲到这里，咱们下次课再见。