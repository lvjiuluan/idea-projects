第1章 开宗明义【告诉你：学什么+收获什么】
  1-1 Java并发成神之路――精通JUC并发工具十八般武艺
第2章 鸟瞰Java并发【上帝视角建立并发知识框架】
  2-1 并发工具类纵览――建立起Java并发体系的大厦吾爱IT教程网
第3章 线程池【治理线程的最大法宝】
  3-1 线程池的自我介绍
  3-10 线程池状态和使用注意点
  3-2 增减线程的时机
  3-3 keepAliveTime和线程工厂
  3-4 演示内存溢出的情况
  3-5 线程池用法演示
  3-6 对比线程池的特点
  3-7 五虎上将收服线程池
  3-8 钩子：给线程池加点料
  3-9 Executor家族的辨析
第4章 ThreadLocal【一次解决老大难问题】
  4-1 ThreadLocal的两种用法
  4-10 ThreadLocal的好处
  4-11 ThreadLocal原理
  4-12 ThreadLocal的重要方法介绍
  4-13 重要方法的源码分析
  4-14 两种场景，殊途同归
  4-15 收不回来的value
  4-16 ThreadLocal的空指针异常问题
  4-17 ThreadLocal在Spring中的应用
  4-2 进化之路：故事从两个线程说起
  4-3 进化之路：线程池来帮忙，却好心办坏事
  4-4 走过的弯路，你的套路
  4-5 ThreadLocal是救火队长
  4-6 悔不当初：回顾进化之路
  4-7 ThreadLocal的第二种用法 part1
  4-8 ThreadLocal的第二种用法 part2
  4-9 ThreadLocal的两种用法总结
第5章 不可不说的“锁”事【种类繁多，如何一一突破？】
  5-1 本章纵览
  5-10 是否允许一部分人“先富起来”
  5-11 代码演示：先来后到的特例、优劣、源码分析
  5-12 共享锁和排它锁的用法
  5-13 深入理解交互思想
  5-14 看似读锁按部就班
  5-15 超越95%面试者的秘籍 part 1
  5-16 超越95%面试者的秘籍 part 2
  5-17 读写锁的由奢入俭“易”
  5-18 循环尝试，不释放CPU
  5-19 可中断锁
  5-2 内置锁的能力不足以满足需求
  5-20 我们如何才能让锁变得更好用？
  5-21 “锁”事总结
  5-3 tryLock尝试获取锁
  5-4 代码演示：获取锁时被中断
  5-5 锁的可见性保证
  5-6 互斥同步锁
  5-7 非互斥同步锁
  5-8 可重入锁的用法
  5-9 可重入性质和源码解析
第6章 atomic包【一刻也不能分割】
  6-1 什么是原子类，有什么作用？
  6-10 总结原子类
  6-2 6类原子类纵览
  6-3 AtomicInteger案例演示
  6-4 Atomic数组，每个都安全
  6-5 Atomic引用在自旋锁的应用
  6-6 把普通变量升级为原子变量
  6-7 对比新旧工具的运行速度
  6-8 剖析高速运转的原理
  6-9 功能升级，不限于加操作
第7章  CAS【不可中断的典范】
  7-1 什么是CAS
  7-2 CAS的等价代码、使用案例
  7-3 CAS的应用场景、源码分析
  7-4 CAS的缺点和总结
第8章 以不变应万变【最便捷的并发安全之道】
  8-1 什么是“不变性”？
  8-2 final变量的赋值时机
  8-3 final的注意点
  8-4 栈封闭技术
  8-5 面试题：真假美猴王
第9章 ConcurrentHashMap等并发集合【面试超高频考点】
  9-1 并发容器概览
  9-10 HashMap 1.7和1.8的结构图和特点，红黑树的概念
  9-11 ConcurrentHashMap 1.7和1.8结构图
  9-12 ConcurrentHashMap源码分析-
  9-13 ConcurrentHashMap1.7和1.8的对比，做了哪些升级？
  9-14 ConcurrentHashMap难道也会发生线程安全问题？：组合操作的玄机
  9-15 实际生产中并发安全事故的分享、ConcurrentHashMap复习
  9-16 CopyOnWriteArrayList的适用场景、读写规则
  9-17 CopyOnWrite设计理念、数据过期问题
  9-18 CopyOnWrite源码、缺点分析
  9-19 并发队列简介
  9-2 集合类的历史，演进过程：Vector和Hashtable
  9-20 彩蛋：轻松绘制漂亮的UML图
  9-21 BlockingQueue入门
  9-22 ArrayBlockingQueue代码演示、源码分析
  9-23 LinkedBlockingQueue等典型介绍
  9-24 并发容器总结
  9-3 前身：同步的HashMap和ArrayList
  9-4 ConcurrentHashMap概览
  9-5 Map接口的典型实现类、常用方法演示
  9-6 彩蛋：调整JDK版本，以便查看对应版本的代码
  9-7 HashMap的死循环导致CPU100%的问题分析
  9-8 彩蛋：多线程调试技巧，每个线程独立调试
  9-9 HashMap的死循环分析_慕课网.pdf
第10章  控制并发流程【做好线程之间的协调人】
  10-1 如何控制并发流程？
  10-2 倒计时门闩，一等多
  10-3 综合用法：运动员跑步
  10-4 Semaphore颁发许可证
  10-5 Semaphore用法和注意点
  10-6 条件对象的作用和用法演示
  10-7 用条件对象实现生产者模式
  10-8 循环栅栏的作用
  10-9 总结控制并发流程的要点
第11章 AQS【进阶必备，并发灵魂人物】
  11-1 如何学习AQS？
  11-10 AQS补充材料（选修）_慕课网.pdf
  11-2 Semaphore和AQS的关系
  11-3 比喻：HR和AQS的职责统一
  11-4 AQS的三要素
  11-5 AQS源码分析
  11-6 AQS的许可证颁发
  11-7 利用AQS实现独占锁
  11-8 DIY一次性门闩
  11-9 AQS的核心思路
第12章 获取子线程的执行结果【来而不往非礼也】
  12-1 Future和Callable的关系
  12-2 代码演示：submit返回Future对象，快速抽取返回值
  12-3 批量接收结果
  12-4 执行时异常和isDone演示
  12-5 代码演示：默认广告的超时和取消
  12-6 cancel方法与中断线程
  12-7 用法二：用FutureTask获取结果
  12-8 总结Future本章
第13章 从0到1打造高性能缓存【学以致用，直击痛点】
  13-1 从最简单的缓存出发
  13-10 用线程池测试缓存性能
  13-11 用CountDownLatch实现压测
  13-12 用ThreadLocal确认时间的统一性
  13-13 打怪升级之路总结
  13-2 暴露出来的性能和复用性问题
  13-3 用装饰者模式解耦
  13-4 用ConcurrentHashMap保证并发安全
  13-5 用Future解决重复计算问题
  13-6 原子组合操作填补漏洞
  13-7 计算错误如何处理？
  13-8 缓存“污染”问题的解决
  13-9 缓存过期功能和随机性
第14章 结语【总结全课精华】
  14-1 全课精华总结 part 1
  14-2 全课精华总结 part 2